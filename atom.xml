<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HansChen 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.hanschen.site/"/>
  <updated>2019-09-02T06:30:29.829Z</updated>
  <id>http://blog.hanschen.site/</id>
  
  <author>
    <name>chenhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Protocol Buffers 手册</title>
    <link href="http://blog.hanschen.site/2017/04/08/protobuf3/"/>
    <id>http://blog.hanschen.site/2017/04/08/protobuf3/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Protocol Buffers 是 google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。</p><p>至于protobuf是什么、使用场景、有什么好处，本文不做说明，这里将会为大家介绍怎么用 <code>protobuf</code> 来定义我们的交互协议，包括 <code>.proto</code> 的语法以及如何根据proto文件生成相应的代码。本文基于<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3</a>，读者也可以点击了解<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto2</a></p><a id="more"></a><h1 id="proto3语法"><a href="#proto3语法" class="headerlink" title="proto3语法"></a>proto3语法</h1><h2 id="定义一个-Message"><a href="#定义一个-Message" class="headerlink" title="定义一个 Message"></a>定义一个 Message</h2><p>首先我们来定义一个 Search 请求，在这个请求里面，我们需要给服务端发送三个信息：</p><ul><li>query：查询条件</li><li>page_number：你想要哪一页数据</li><li>result_per_page：每一页有多少条数据</li></ul><p>于是我们可以这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 指定使用proto3，如果不指定的话，编译器会使用proto2去编译</span><br><span class="line">syntax = &quot;proto3&quot;; //[proto2|proto3]</span><br><span class="line"></span><br><span class="line">message SearchRequests &#123;</span><br><span class="line">    // 定义SearchRequests的成员变量，需要指定：变量类型、变量名、变量Tag</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2;</span><br><span class="line">    int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义多个-message-类型"><a href="#定义多个-message-类型" class="headerlink" title="定义多个 message 类型"></a>定义多个 message 类型</h2><p>一个 proto 文件可以定义多个 message ，比如我们可以在刚才那个 proto 文件中把服务端返回的消息结构也一起定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2;</span><br><span class="line">    int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line">    repeated string result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>message 可以嵌套定义，比如 message 可以定义在另一个 message 内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">    message Result &#123;</span><br><span class="line">        string url = 1;</span><br><span class="line">        string title = 2;</span><br><span class="line">        repeated string snippets = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    repeated Result results = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在 message 内部的 message 可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SomeOtherMessage &#123;</span><br><span class="line">    SearchResponse.Result result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义变量类型"><a href="#定义变量类型" class="headerlink" title="定义变量类型"></a>定义变量类型</h2><p>在刚才的例子之中，我们使用了2个<code>标准值类型</code>： string 和 int32，除了这些标准类型之外，变量的类型还可以是复杂类型，比如自定义的<code>枚举</code>和自定义的 <code>message</code></p><p>这里我们把标准类型列举一下protobuf内置的标准类型以及跟各平台对应的关系：</p><table><thead><tr><th align="left">.proto</th><th align="left">说明</th><th align="left">C++</th><th align="left">Java</th><th align="left">Python</th><th align="left">Go</th><th align="left">Ruby</th><th align="left">C#</th><th align="left">PHP</th></tr></thead><tbody><tr><td align="left">double</td><td align="left"></td><td align="left">double</td><td align="left">double</td><td align="left">float</td><td align="left">float64</td><td align="left">Float</td><td align="left">double</td><td align="left">float</td></tr><tr><td align="left">float</td><td align="left"></td><td align="left">float</td><td align="left">float</td><td align="left">float</td><td align="left">float32</td><td align="left">Float</td><td align="left">float</td><td align="left">float</td></tr><tr><td align="left">int32</td><td align="left">使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint32</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">int64</td><td align="left">使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint64</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">uint32</td><td align="left">使用变长编码</td><td align="left">uint32</td><td align="left">int</td><td align="left">int/long</td><td align="left">uint32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">uint</td><td align="left">integer</td></tr><tr><td align="left">uint64</td><td align="left">使用变长编码</td><td align="left">uint64</td><td align="left">long</td><td align="left">int/long</td><td align="left">uint64</td><td align="left">Bignum</td><td align="left">ulong</td><td align="left">integer/string</td></tr><tr><td align="left">sint32</td><td align="left">使用变长编码，带符号的int类型，对负数编码比int32高效</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">sint64</td><td align="left">使用变长编码，带符号的int类型，对负数编码比int64高效</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">fixed32</td><td align="left">4字节编码， 如果变量经常大于$ 2^{28} $ 的话，会比uint32高效</td><td align="left">uint32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">uint</td><td align="left">integer</td></tr><tr><td align="left">fixed64</td><td align="left">8字节编码， 如果变量经常大于$ 2^{56} $ 的话，会比uint64高效</td><td align="left">uint64</td><td align="left">long</td><td align="left">int/long</td><td align="left">uint64</td><td align="left">Bignum</td><td align="left">ulong</td><td align="left">integer/string</td></tr><tr><td align="left">sfixed32</td><td align="left">4字节编码</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">Fixnum or Bignum (as required)</td><td align="left">int</td><td align="left">integer</td></tr><tr><td align="left">sfixed64</td><td align="left">8字节编码</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long</td><td align="left">int64</td><td align="left">Bignum</td><td align="left">long</td><td align="left">integer/string</td></tr><tr><td align="left">bool</td><td align="left"></td><td align="left">bool</td><td align="left">boolean</td><td align="left">bool</td><td align="left">bool</td><td align="left">TrueClass/FalseClass</td><td align="left">bool</td><td align="left">boolean</td></tr><tr><td align="left">string</td><td align="left">必须包含utf-8编码或者7-bit ASCII text</td><td align="left">string</td><td align="left">String</td><td align="left">str/unicode</td><td align="left">string</td><td align="left">String (UTF-8)</td><td align="left">string</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td align="left">任意的字节序列</td><td align="left">string</td><td align="left">ByteString</td><td align="left">str</td><td align="left">[]byte</td><td align="left">String (ASCII-8BIT)</td><td align="left">ByteString</td><td align="left">string</td></tr></tbody></table><p>补充说明：</p><ul><li>In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit.</li><li>In all cases, setting values to a field will perform type checking to make sure it is valid.</li><li>64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">2</a>.</li><li>Python strings are represented as unicode on decode but can be str if an ASCII string is given (this is subject to change).</li><li>Integer is used on 64-bit machines and string is used on 32-bit machines.</li></ul><p>关于标准值类型，还可以参考<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">Scalar Value Types</a></p><p>如果你想了解这些数据是怎么序列化和反序列化的，可以点击 <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Protocol Buffer Encoding</a> 了解更多关于protobuf编码内容。</p><h2 id="分配Tag"><a href="#分配Tag" class="headerlink" title="分配Tag"></a>分配Tag</h2><p>每一个变量在message内都需要自定义一个<strong>唯一的数字Tag</strong>，protobuf会根据Tag从数据中查找变量对应的位置，具体原理跟protobuf的<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">二进制数据格式</a>有关。Tag一旦指定，以后更新协议的时候也不能修改，否则无法对旧版本兼容。</p><p>Tag的取值范围最小是1，最大是$ 2^{29} $-1，但 19000~19999 是 protobuf 预留的，用户不能使用。</p><p>虽然 Tag 的定义范围比较大，但不同 Tag 也会对 protobuf 编码带来一些影响：</p><ul><li>1 ~ 15：单字节编码</li><li>16 ~ 2047：双字节编码</li></ul><p>使用频率高的变量最好设置为1 ~ 15，这样可以减少编码后的数据大小，但由于Tag一旦指定不能修改，所以为了以后扩展，也记得为未来保留一些 1 ~ 15 的 Tag</p><h2 id="指定变量规则"><a href="#指定变量规则" class="headerlink" title="指定变量规则"></a>指定变量规则</h2><p>在 proto3 中，可以给变量指定以下两个规则：</p><ul><li><code>singular</code>：0或者1个，但不能多于1个</li><li><code>repeated</code>：任意数量（包括0）</li></ul><p>当构建 message 的时候，build 数据的时候，会检测设置的数据跟规则是否匹配</p><p>在proto2中，规则为：</p><ul><li>required：必须有一个</li><li>optional：0或者1个</li><li>repeated：任意数量（包括0）</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用<code>//</code>表示注释开头，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2; // Which page number do we want</span><br><span class="line">    int32 result_per_page = 3; // Number of results to return per page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保留变量不被使用"><a href="#保留变量不被使用" class="headerlink" title="保留变量不被使用"></a>保留变量不被使用</h2><p>上面我们说到，一旦 Tag 指定后就不能变更，这就会带来一个问题，假如在版本1的协议中，我们有个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32 number = 1；</span><br></pre></td></tr></table></figure><p>在版本2中，我们决定废弃对它的使用，那我们应该如何修改协议呢？注释掉它？删除掉它？如果把它删除了，后来者很可能在定义新变量的时候，使新的变量 Tag = 1 ，这样会导致协议不兼容。那有没有办法规避这个问题呢？我们可以用 <code>reserved</code> 关键字，当一个变量不再使用的时候，我们可以把它的变量名或 Tag 用 <code>reserved</code> 标注，这样，当这个 Tag 或者变量名字被重新使用的时候，编译器会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">    // 注意，同一个 reserved 语句不能同时包含变量名和 Tag </span><br><span class="line">    reserved 2, 15, 9 to 11;</span><br><span class="line">    reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>当解析 message 时，如果被编码的 message 里没有包含某些变量，那么根据类型不同，他们会有不同的默认值：</p><ul><li>string：默认是空的字符串</li><li>byte：默认是空的bytes</li><li>bool：默认为false</li><li>numeric：默认为0</li><li>enums：定义在第一位的枚举值，也就是0</li><li>messages：根据生成的不同语言有不同的表现，参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">generated code guide </a></li></ul><p>注意，收到数据后反序列化后，对于标准值类型的数据，比如bool，如果它的值是 false，那么我们无法判断这个值是对方设置的，还是对方压根就没给这个变量设置值。</p><h2 id="定义枚举-Enumerations"><a href="#定义枚举-Enumerations" class="headerlink" title="定义枚举 Enumerations"></a>定义枚举 Enumerations</h2><p>在 protobuf 中，我们也可以定义枚举，并且使用该枚举类型，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query = 1;</span><br><span class="line">    int32 page_number = 2; // Which page number do we want</span><br><span class="line">    int32 result_per_page = 3; // Number of results to return per page</span><br><span class="line">    enum Corpus &#123;</span><br><span class="line">        UNIVERSAL = 0;</span><br><span class="line">        WEB = 1;</span><br><span class="line">        IMAGES = 2;</span><br><span class="line">        LOCAL = 3;</span><br><span class="line">        NEWS = 4;</span><br><span class="line">        PRODUCTS = 5;</span><br><span class="line">        VIDEO = 6;</span><br><span class="line">    &#125;</span><br><span class="line">    Corpus corpus = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举定义在一个消息内部或消息外部都是可以的，如果枚举是 定义在 message 内部，而其他 message 又想使用，那么可以通过 <code>MessageType.EnumType</code> 的方式引用。定义枚举的时候，我们要保证<strong>第一个枚举值必须是0</strong>，枚举值不能重复，除非使用 <code>option allow_alias = true</code> 选项来开启别名。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">    option allow_alias = true;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    STARTED = 1;</span><br><span class="line">    RUNNING = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举值的范围是32-bit integer，但因为枚举值使用变长编码，所以不推荐使用负数作为枚举值，因为这会带来效率问题。</p><h2 id="如何引用其他-proto-文件"><a href="#如何引用其他-proto-文件" class="headerlink" title="如何引用其他 proto 文件"></a>如何引用其他 proto 文件</h2><p>在proto语法中，有两种引用其他 proto 文件的方法： <code>import</code> 和 <code>import public</code>，这两者有什么区别呢？下面举个例子说明：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-36-49.png" alt="2019-9-2-12-36-49.png"></p><ul><li>在情景1中， my.proto <strong>不能</strong>使用 second.proto 中定义的内容</li><li>在情景2中， my.proto <strong>可以</strong>使用 second.proto 中定义的内容</li><li>情景1和情景2中，my.proto 都可以使用 first.proto</li><li>情景1和情景2中，first.proto 都可以使用 second.proto</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// my.proto</span><br><span class="line">import &quot;first.proto&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// first.proto</span><br><span class="line">//import &quot;second.proto&quot;;</span><br><span class="line">import public &quot;second.proto&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// second.proto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="升级-proto-文件正确的姿势"><a href="#升级-proto-文件正确的姿势" class="headerlink" title="升级 proto 文件正确的姿势"></a>升级 proto 文件正确的姿势</h2><p>升级更改 proto 需要遵循以下原则</p><ul><li>不要修改任何已存在的变量的 Tag</li><li>如果你新增了变量，新生成的代码依然能解析旧的数据，但新增的变量将会变成默认值。相应的，新代码序列化的数据也能被旧的代码解析，但旧代码会自动忽略新增的变量。</li><li>废弃不用的变量用 reserved 标注</li><li>int32、 uint32、 int64、 uint64 和 bool 是相互兼容的，这意味你可以更改这些变量的类型而不会影响兼容性</li><li>sint32 和 sint64 是兼容的，但跟其他类型不兼容</li><li>string 和 bytes 可以兼容，前提是他们都是UTF-8编码的数据</li><li>fixed32 和 sfixed32 是兼容的, fixed64 和 sfixed64是兼容的</li></ul><h2 id="Any-的使用"><a href="#Any-的使用" class="headerlink" title="Any 的使用"></a>Any 的使用</h2><p>Any可以让你在 proto 文件中使用未定义的类型，具体里面保存什么数据，是在上层业务代码使用的时候决定的，使用 Any 必须导入 <code>import google/protobuf/any.proto</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">    repeated google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Oneof-的使用"><a href="#Oneof-的使用" class="headerlink" title="Oneof 的使用"></a>Oneof 的使用</h2><p>Oneof 类似union，如果你的消息中有很多可选字段，而同一个时刻最多仅有其中的一个字段被设置的话，你可以使用oneof来强化这个特性并且节约存储空间，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message LoginReply &#123;</span><br><span class="line">    oneof test_oneof &#123;</span><br><span class="line">        string name = 3;</span><br><span class="line">        string age = 4;</span><br><span class="line">    &#125;</span><br><span class="line">    required string status = 1;</span><br><span class="line">    required string token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，name 和 age 都是 LoginReply 的成员，但不能给他们同时设置值（设置一个oneof字段会自动清理其他的oneof字段）。</p><h2 id="Maps-的使用"><a href="#Maps-的使用" class="headerlink" title="Maps 的使用"></a>Maps 的使用</h2><p>protobuf 支持定义 map 类型的成员，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br><span class="line">// 举例：map&lt;string, Project&gt; projects = 3;</span><br></pre></td></tr></table></figure><ul><li>key_type:必须是string或者int</li><li>value_type：任意类型</li></ul><p>使用 map 要注意：</p><ul><li>Map 类型不能使 repeated</li><li>Map 是无序的</li><li>以文本格式展示时，Map 以 key 来排序</li><li>如果有相同的键会导致解析失败</li></ul><h2 id="Packages-的使用"><a href="#Packages-的使用" class="headerlink" title="Packages 的使用"></a>Packages 的使用</h2><p>为了防止不同消息之间的命名冲突，你可以对特定的.proto文件提指定 package 名字。在定义消息的成员的时候，可以指定包的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br><span class="line">message Open &#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 带上包名</span><br><span class="line">    foo.bar.Open open = 1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><p>Options 分为 file-level options（只能出现在最顶层，不能在消息、枚举、服务内部使用）、 message-level options（只能在消息内部使用）、field-level options（只能在变量定义时使用）</p><ul><li>java_package (file option)：指定生成类的包名，如果没有指定此选项，将由关键字package指定包名。此选项只在生成 java 代码时有效</li><li>java_multiple_files (file option)：如果为 true， 定义在最外层的 message 、enum、service 将作为单独的类存在</li><li>java_outer_classname (file option)：指定最外层class的类名，如果不指定，将会以文件名作为类名</li><li>optimize_for (file option)：可选有 [SPEED|CODE_SIZE|LITE_RUNTIME] ，分别是效率优先、空间优先，第三个lite是兼顾效率和代码大小，但是运行时需要依赖 libprotobuf-lite</li><li>cc_enable_arenas (file option):启动arena allocation，c++代码使用</li><li>objc_class_prefix (file option)：Objective-C使用</li><li>deprecated (field option)：提示变量已废弃、不建议使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">option java_package = &quot;com.example.foo&quot;;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_outer_classname = &quot;Ponycopter&quot;;</span><br><span class="line">option optimize_for = CODE_SIZE;</span><br><span class="line">int32 old_field = 6 [deprecated=true];</span><br></pre></td></tr></table></figure><h1 id="定义-Services"><a href="#定义-Services" class="headerlink" title="定义 Services"></a>定义 Services</h1><p>这个其实和gRPC相关，详细可参考：<a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a>， 这里做一个简单的介绍<br>要定义一个服务，你必须在你的 .proto 文件中指定 <code>service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service RouteGuide &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们的服务中定义 <code>rpc</code> 方法，指定它们的请求的和响应类型。<code>gRPC</code> 允许你定义4种类型的 service 方法</p><h2 id="简单RPC"><a href="#简单RPC" class="headerlink" title="简单RPC"></a>简单RPC</h2><p>客户端使用 Stub 发送请求到服务器并等待响应返回，就像平常的函数调用一样，这是一个阻塞型的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the feature at a given position.</span><br><span class="line">rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端流式-RPC"><a href="#服务器端流式-RPC" class="headerlink" title="服务器端流式 RPC"></a>服务器端流式 RPC</h2><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在响应类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Obtains the Features available within the given Rectangle.  Results are</span><br><span class="line">// streamed rather than returned at once (e.g. in a response message with a</span><br><span class="line">// repeated field), as the rectangle may cover a large area and contain a</span><br><span class="line">// huge number of features.</span><br><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h2><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在请求类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of Points on a route being traversed, returning a</span><br><span class="line">// RouteSummary when traversal is completed.</span><br><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h2><p>双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Accepts a stream of RouteNotes sent while a route is being traversed,</span><br><span class="line">// while receiving other RouteNotes (e.g. from other users).</span><br><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h1><p>使用 <code>protoc</code> 工具可以把编写好的 <code>proto</code> 文件“编译”为Java, Python, C++, Go, Ruby, JavaNano, Objective-C,或C#代码， <code>protoc</code> 可以从<a href="https://developers.google.com/protocol-buffers/docs/downloads" target="_blank" rel="noopener">点击这里</a>进行下载。<code>protoc</code> 的使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>IMPORT_PATH：指定 proto 文件的路径，如果没有指定， protoc 会从当前目录搜索对应的 proto 文件，如果有多个路径，那么可以指定多次<code>--proto_path</code></li><li>指定各语言代码的输出路径<ul><li>–cpp_out：生成c++代码</li><li>java_out ：生成java代码</li><li>python_out ：生成python代码</li><li>go_out ：生成go代码</li><li>ruby_out ：生成ruby代码</li><li>javanano_out ：适合运行在有资源限制的平台（如Android）的java代码</li><li>objc_out ：生成 Objective-C代码</li><li>csharp_out ：生成C#代码</li><li>php_out ：生成PHP代码</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Protocol Buffers 是 google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。&lt;/p&gt;
&lt;p&gt;至于protobuf是什么、使用场景、有什么好处，本文不做说明，这里将会为大家介绍怎么用 &lt;code&gt;protobuf&lt;/code&gt; 来定义我们的交互协议，包括 &lt;code&gt;.proto&lt;/code&gt; 的语法以及如何根据proto文件生成相应的代码。本文基于&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proto3&lt;/a&gt;，读者也可以点击了解&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proto2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://blog.hanschen.site/categories/gRPC/"/>
    
    
      <category term="protobuf" scheme="http://blog.hanschen.site/tags/protobuf/"/>
    
      <category term="gRPC" scheme="http://blog.hanschen.site/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰模式</title>
    <link href="http://blog.hanschen.site/2017/03/09/pattern_decorator/"/>
    <id>http://blog.hanschen.site/2017/03/09/pattern_decorator/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责，就增加功能来说装饰模式比生成子类更为灵活。它通过创建一个包装对象，也就是装饰来包裹真实的对象</p><h1 id="情景举例"><a href="#情景举例" class="headerlink" title="情景举例"></a>情景举例</h1><p>我们先来分析这样一个画图形的需求：</p><ol><li>它能绘制各种背景，如红色、蓝色、绿色</li><li>它能绘制形状，如三角形，正方形，圆形</li><li>它能给形状加上阴影</li></ol><p>就先列这三个简单的需求吧，下面让我们比较下各种实现的优缺点</p><h1 id="丑陋的实现"><a href="#丑陋的实现" class="headerlink" title="丑陋的实现"></a>丑陋的实现</h1><p>来看看我们用继承是如何实现的，首先，抽象出一个<code>Shape</code>接口我想大家都不会有意见的是不是？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绘制图形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义各种情况下的子类，结构如下，看到这么多的子类，是不是有点要爆炸的感觉？真是想想都可怕<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-35-9.png" alt="2019-9-2-12-35-9.png"></p><p>而且如果再新增一种需求，比如现在要画椭圆，那么维护的人员估计就要爆粗了吧？</p><a id="more"></a><p>为了避免写出上面的代码，聪明的童鞋们可能会提出第二种方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeImpl</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Type &#123;</span><br><span class="line">        Circle,</span><br><span class="line">        Square,</span><br><span class="line">        Trilatera</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Color &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Green,</span><br><span class="line">        Blue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type    type;</span><br><span class="line">    <span class="keyword">private</span> Color   color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shadow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShadow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shadow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShadow</span><span class="params">(<span class="keyword">boolean</span> shadow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shadow = shadow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2017/3/9 根据属性情况画出不同的图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，根据不同的画图需求，只需要设置不同的属性就可以了，这样确实避免了类爆炸增长的问题，但这种方式违反了开放封闭原则，比如画正方形的方式变了，需要对<code>ShapeImpl</code>进行修改，或者如果新增需求，如画椭圆，也需要对<code>ShapeImpl</code>进行修改。而且这个类不方便扩展，子类将继承一些对自身并不合适的方法。</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><blockquote><p>装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责</p></blockquote><p>以下情况使用Decorator模式：</p><ul><li>需要扩展一个类的功能，或给一个类添加附加职责。</li><li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</li><li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类</li></ul><p>但这种灵活也会带来一些缺点，这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂</p><p>下面来看看装饰模式的结构：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-35-32.png" alt="2019-9-2-12-35-32.png"></p><ol><li>Component抽象组件，是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。（注：在装饰模式中，必然有一个最基本、最核心、最原始的接口或者抽象类充当Component抽象组件）</li><li>ConcreteComponent具体组件，是最核心、最原始、最基本的接口或抽象类的实现，我们需要装饰的就是它</li><li>Decorator装饰角色， 一般是一个抽象类，实现接口或者抽象方法，它的属性里必然有一个private变量指向Component抽象组件。</li><li>具体装饰角色，如上图中的ConcreteDecoratorA和ConcreteDecoratorB，我们要把我们最核心的、最原始的、最基本的东西装饰成其它东西。</li></ol><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说了一堆结构和示例代码，但大家可能还是不太好理解，下面用装饰模式来重新实现画图的功能</p><h2 id="用装饰模式实现需求"><a href="#用装饰模式实现需求" class="headerlink" title="用装饰模式实现需求"></a>用装饰模式实现需求</h2><p>先上结构图<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-35-51.png" alt="2019-9-2-12-35-51.png"></p><p>首先定义可动态扩展对象的抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绘制图形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的组件，每一个组件代表一个形状</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"正方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trilateral</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"三角形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义可装饰者的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Shape shape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的装饰者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blue</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 蓝色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Green</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 绿色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Red</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 红色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shadow</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shadow</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        System.out.print(<span class="string">" 有阴影"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在让我们看看具体怎么使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正方形 红色 有阴影</span></span><br><span class="line">        Shape shape = <span class="keyword">new</span> Square();</span><br><span class="line">        shape = <span class="keyword">new</span> Red(shape);</span><br><span class="line">        shape = <span class="keyword">new</span> Shadow(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//圆形 绿色</span></span><br><span class="line">        shape = <span class="keyword">new</span> Circle();</span><br><span class="line">        shape = <span class="keyword">new</span> Green(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//三角形 蓝色 有阴影</span></span><br><span class="line">        shape = <span class="keyword">new</span> Trilateral();</span><br><span class="line">        shape = <span class="keyword">new</span> Blue(shape);</span><br><span class="line">        shape = <span class="keyword">new</span> Shadow(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，装饰模式是非常灵活的，通过不同的装饰，实现不同的效果</p><h1 id="装饰模式的应用举例"><a href="#装饰模式的应用举例" class="headerlink" title="装饰模式的应用举例"></a>装饰模式的应用举例</h1><p>这里再列举一些用到了装饰模式的情景，童鞋们可以根据这些场景加深对装饰模式的理解</p><ul><li>Java中<code>IO</code>设计</li><li>Android中<code>Context</code>和<code>ContextWrapper</code>的设计</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰模式是为已有功能动态地添加功能的一种方式，它把每个要装饰的功能放在单独的类中，并让这个类包括要装饰的对象，有效地把核心职能和装饰功能区分开了。但它带来灵活的同时，也容易导致别人不了解自己的设计方式，不知如何使用。就像Java中I/O库，人们第一次接触的时候，往往无法轻易理解它。这其中的平衡取舍，就看自己咯</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责，就增加功能来说装饰模式比生成子类更为灵活。它通过创建一个包装对象，也就是装饰来包裹真实的对象&lt;/p&gt;
&lt;h1 id=&quot;情景举例&quot;&gt;&lt;a href=&quot;#情景举例&quot; class=&quot;headerlink&quot; title=&quot;情景举例&quot;&gt;&lt;/a&gt;情景举例&lt;/h1&gt;&lt;p&gt;我们先来分析这样一个画图形的需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它能绘制各种背景，如红色、蓝色、绿色&lt;/li&gt;
&lt;li&gt;它能绘制形状，如三角形，正方形，圆形&lt;/li&gt;
&lt;li&gt;它能给形状加上阴影&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就先列这三个简单的需求吧，下面让我们比较下各种实现的优缺点&lt;/p&gt;
&lt;h1 id=&quot;丑陋的实现&quot;&gt;&lt;a href=&quot;#丑陋的实现&quot; class=&quot;headerlink&quot; title=&quot;丑陋的实现&quot;&gt;&lt;/a&gt;丑陋的实现&lt;/h1&gt;&lt;p&gt;来看看我们用继承是如何实现的，首先，抽象出一个&lt;code&gt;Shape&lt;/code&gt;接口我想大家都不会有意见的是不是？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; HansChen&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 绘制图形&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后我们定义各种情况下的子类，结构如下，看到这么多的子类，是不是有点要爆炸的感觉？真是想想都可怕&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-35-9.png&quot; alt=&quot;2019-9-2-12-35-9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且如果再新增一种需求，比如现在要画椭圆，那么维护的人员估计就要爆粗了吧？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="http://blog.hanschen.site/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="包装器模式" scheme="http://blog.hanschen.site/tags/%E5%8C%85%E8%A3%85%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之桥接模式</title>
    <link href="http://blog.hanschen.site/2017/03/01/pattern_bridge/"/>
    <id>http://blog.hanschen.site/2017/03/01/pattern_bridge/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h1><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>现在我们要实现这样一个功能：发送消息。从业务上看，消息又分成普通消息、加急消息和特急消息多种，不同的消息类型，业务功能处理是不一样的，比如加急消息是在消息上添加“加急”字样，而特急消息除了添加特急外，还会做一条催促的记录，多久不完成会继续催促。从发送消息的手段上看，又有系统内短消息、手机短消息、邮件等等。现在要实现这样的发送提示消息的功能，该如何实现呢？</p><a id="more"></a><h2 id="不用模式的解决方案"><a href="#不用模式的解决方案" class="headerlink" title="不用模式的解决方案"></a>不用模式的解决方案</h2><h3 id="实现简化版本"><a href="#实现简化版本" class="headerlink" title="实现简化版本"></a>实现简化版本</h3><p>先实现一个简单点的版本：消息只是实现发送普通消息，发送的方式先实现系统内短消息和邮件。其它的功能，等这个版本完成过后，再继续添加，这样先把问题简单化，实现起来会容易一点。由于发送普通消息会有两种不同的实现方式，为了让外部能统一操作，因此，把消息设计成接口，然后由两个不同的实现类，分别实现系统内短消息方式和邮件发送消息的方式。此时系统结构如下：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-30-41.png" alt="2019-9-2-12-30-41.png"></p><p>先来看看消息的统一接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来分别看看两种实现方式，这里只是为了示意，并不会真的去发送Email和站内短消息，先看站内短消息的方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMessageSMS</span> <span class="keyword">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，实现以Email的方式发送普通消息，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMessageEmail</span> <span class="keyword">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现发送加急消息"><a href="#实现发送加急消息" class="headerlink" title="实现发送加急消息"></a>实现发送加急消息</h3><p>上面的实现，看起来很简单，对不对。接下来，添加发送加急消息的功能，也有两种发送的方式，同样是站内短消息和Email的方式。<br>加急消息的实现跟普通消息不同，加急消息会自动在消息上添加加急，然后再发送消息；另外加急消息会提供监控的方法，让客户端可以随时通过这个方法来了解对于加急消息处理的进度，比如：相应的人员是否接收到这个信息，相应的工作是否已经开展等等。因此加急消息需要扩展出一个新的接口，除了基本的发送消息的功能，还需要添加监控的功能，这个时候，系统的结构如图所示：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-31-39.png" alt="2019-9-2-12-31-39.png"></p><p>先看看扩展出来的加急消息的接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UrgencyMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">watch</span><span class="params">(String messageId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的实现方式还是发送站内短消息和Email两种，同样需要两个实现类来分别实现这两种方式，先看站内短消息的方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyMessageSMS</span> <span class="keyword">implements</span> <span class="title">UrgencyMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watch</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看Emai的方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyMessageEmail</span> <span class="keyword">implements</span> <span class="title">UrgencyMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watch</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，在实现加急消息发送的功能上，可能会使用前面发送不同消息的功能，也就是让实现加急消息处理的对象继承普通消息的相应实现，这里为了让结构简单一点，清晰一点，所以没有这样做。</p><h2 id="有何问题"><a href="#有何问题" class="headerlink" title="有何问题"></a>有何问题</h2><p>上面这样实现，好像也能满足基本的功能要求，可是这么实现好不好呢？有没有什么问题呢？<br>我们继续向下来添加功能实现，为了简洁，就不再去进行代码示意了，通过实现的结构示意图就可以看出实现上的问题。</p><h3 id="继续添加特急消息的处理"><a href="#继续添加特急消息的处理" class="headerlink" title="继续添加特急消息的处理"></a>继续添加特急消息的处理</h3><p>特急消息不需要查看处理进程，只要没有完成，就直接催促，也就是说，对于特急消息，在普通消息的处理基础上，需要添加催促的功能。而特急消息、还有催促的发送方式，相应的实现方式还是发送站内短消息和Email两种，此时系统的结构如图所示：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-32-9.png" alt="2019-9-2-12-32-9.png"></p><p>仔细观察上面的系统结构示意图，会发现一个很明显的问题，那就是：通过这种继承的方式来扩展消息处理，会非常不方便。<br>你看，实现加急消息处理的时候，必须实现站内短消息和Email两种处理方式，因为业务处理可能不同；在实现特急消息处理的时候，又必须实现站内短消息和Email这两种处理方式。<br>这意味着，以后每次扩展一下消息处理，都必须要实现这两种处理方式，是不是很痛苦，这还不算完，如果要添加新的实现方式呢？继续向下看吧。</p><h3 id="继续添加发送手机消息的处理方式"><a href="#继续添加发送手机消息的处理方式" class="headerlink" title="继续添加发送手机消息的处理方式"></a>继续添加发送手机消息的处理方式</h3><p>如果看到上面的实现，你还感觉问题不是很大的话，继续完成功能，添加发送手机消息的处理方式<br>仔细观察现在的实现，如果要添加一种新的发送消息的方式，是需要在每一种抽象的具体实现里面，都要添加发送手机消息的处理的。也就是说：发送普通消息、加急消息和特急消息的处理，都可以通过手机来发送。这就意味着，需要添加三个实现。此时系统结构如图所示：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-32-31.png" alt="2019-9-2-12-32-31.png"></p><p>这下能体会到这种实现方式的大问题了吧。</p><h3 id="小结一下出现的问题"><a href="#小结一下出现的问题" class="headerlink" title="小结一下出现的问题"></a>小结一下出现的问题</h3><p>采用通过继承来扩展的实现方式，有个明显的缺点：扩展消息的种类不太容易，不同种类的消息具有不同的业务，也就是有不同的实现，在这种情况下，每个种类的消息，需要实现所有不同的消息发送方式。<br>更可怕的是，如果要新加入一种消息的发送方式，那么会要求所有的消息种类，都要加入这种新的发送方式的实现。<br>要是考虑业务功能上再扩展一下呢？比如：要求实现群发消息，也就是一次可以发送多条消息，这就意味着很多地方都得修改，太恐怖了。<br>那么究竟该如何实现才能既实现功能，又能灵活的扩展呢？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="桥接模式来解决"><a href="#桥接模式来解决" class="headerlink" title="桥接模式来解决"></a>桥接模式来解决</h2><p>用来解决上述问题的一个合理的解决方案，就是使用桥接模式。那么什么是桥接模式呢？<br>桥接模式定义：</p><blockquote><p>将抽象部分和实现部分分离，使它们都可以独立地变化</p></blockquote><p>应用桥接模式来解决的思路</p><p>仔细分析上面的示例，根据示例的功能要求，示例的变化具有两个维度，一个维度是抽象的消息这边，包括普通消息、加急消息和特急消息，这几个抽象的消息本身就具有一定的关系，加急消息和特急消息会扩展普通消息；另一个维度在具体的消息发送方式上，包括站内短消息、Email和手机短信息，这几个方式是平等的，可被切换的方式。这两个维度一共可以组合出9种不同的可能性来。<br>现在出现问题的根本原因，就在于消息的抽象和实现是混杂在一起的，这就导致了，一个维度的变化，会引起另一个维度进行相应的变化，从而使得程序扩展起来非常困难。<br>要想解决这个问题，就必须把这两个维度分开，也就是将抽象部分和实现部分分开，让它们相互独立，这样就可以实现独立的变化，使扩展变得简单。<br>桥接模式通过引入实现的接口，把实现部分从系统中分离出去；那么，抽象这边如何使用具体的实现呢？肯定是面向实现的接口来编程了，为了让抽象这边能够很方便的与实现结合起来，把顶层的抽象接口改成抽象类，在里面持有一个具体的实现部分的实例。<br>这样一来，对于需要发送消息的客户端而言，就只需要创建相应的消息对象，然后调用这个消息对象的方法就可以了，这个消息对象会调用持有的真正的消息发送方式来把消息发送出去。也就是说客户端只是想要发送消息而已，并不想关心具体如何发送。</p><h2 id="模式结构和说明"><a href="#模式结构和说明" class="headerlink" title="模式结构和说明"></a>模式结构和说明</h2><p>桥接模式的结构图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-32-50.png" alt="2019-9-2-12-32-50.png"></p><ul><li>Abstraction：抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。</li><li>RefinedAbstraction：扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。</li><li>Implementor：定义实现部分的接口，这个接口不用和Abstraction里面的方法一致，通常是由Implementor接口提供基本的操作，而Abstraction里面定义的是基于这些基本操作的业务方法，也就是说Abstraction定义了基于这些基本操作的较高层次的操作。</li><li>ConcreteImplementor：真正实现Implementor接口的对象。</li></ul><h2 id="桥接模式示例代码"><a href="#桥接模式示例代码" class="headerlink" title="桥接模式示例代码"></a>桥接模式示例代码</h2><p>先看看Implementor接口的定义，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看Abstraction接口的定义，注意一点，虽然说是接口定义，但其实是实现成为抽象类。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Implementor impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入实现部分的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl 实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该来看看具体的实现了，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真正的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真正的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看看扩展Abstraction接口的对象实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例操作，实现一定的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现一定的功能，可能会使用具体实现部分的实现方法，</span></span><br><span class="line">        <span class="comment">//但是本方法更大的可能是使用Abstraction中定义的方法，</span></span><br><span class="line">        <span class="comment">//通过组合使用Abstraction中定义的方法来完成更多的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用桥接模式重写示例"><a href="#使用桥接模式重写示例" class="headerlink" title="使用桥接模式重写示例"></a>使用桥接模式重写示例</h2><p>学习了桥接模式的基础知识过后，该来使用桥接模式重写前面的示例了。通过示例，来看看使用桥接模式来实现同样的功能，是否能解决“既能方便的实现功能，又能有很好的扩展性”的问题。<br>要使用桥接模式来重新实现前面的示例，首要任务就是要把抽象部分和实现部分分离出来，分析要实现的功能，抽象部分就是各个消息的类型所对应的功能，而实现部分就是各种发送消息的方式。<br>其次要按照桥接模式的结构，给抽象部分和实现部分分别定义接口，然后分别实现它们就可以了。</p><h3 id="从简单功能开始"><a href="#从简单功能开始" class="headerlink" title="从简单功能开始"></a>从简单功能开始</h3><p>从相对简单的功能开始，先实现普通消息和加急消息的功能，发送方式先实现站内短消息和Email这两种。使用桥接模式来实现这些功能的程序结构如图所示<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-33-19.png" alt="2019-9-2-12-33-19.png"></p><p>还是看看代码实现，会更清楚一些。先看看消息发送器接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发送器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看抽象部分定义的接口，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的消息对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有一个实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MessageSender impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入实现部分的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl 实现部分的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AbstractMessageController(MessageSender impl) &#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，转调实现部分的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toUser  消息发送的目的人员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        impl.send(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看如何具体的实现发送消息，先看站内短消息的实现吧，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以站内短消息的方式发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderSMS</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用站内短消息的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看Email方式的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以Email的方式发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderEmail</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用Email的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来该看看如何扩展抽象的消息接口了，先看普通消息的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonMessageController</span> <span class="keyword">extends</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonMessageController</span><span class="params">(MessageSender impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于普通消息，什么都不干，直接调父类的方法，把消息发送出去就可以了</span></span><br><span class="line">        <span class="keyword">super</span>.sendMessage(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看加急消息的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyMessageController</span> <span class="keyword">extends</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrgencyMessageController</span><span class="params">(MessageSender impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"加急："</span> + message;</span><br><span class="line">        <span class="keyword">super</span>.sendMessage(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展自己的新功能：监控某消息的处理过程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 被监控的消息的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watch</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><p>看了上面的实现，发现使用桥接模式来实现也不是很困难啊，关键得看是否能解决前面提出的问题，那就来添加还未实现的功能看看，添加对特急消息的处理，同时添加一个使用手机发送消息的方式。该怎么实现呢？<br>很简单，只需要在抽象部分再添加一个特急消息的类，扩展抽象消息就可以把特急消息的处理功能加入到系统中了；对于添加手机发送消息的方式也很简单，在实现部分新增加一个实现类，实现用手机发送消息的方式，也就可以了。<br>这么简单？好像看起来完全没有了前面所提到的问题。的确如此，采用桥接模式来实现过后，抽象部分和实现部分分离开了，可以相互独立的变化，而不会相互影响。因此在抽象部分添加新的消息处理，对发送消息的实现部分是没有影响的；反过来增加发送消息的方式，对消息处理部分也是没有影响的。</p><p>接着看看代码实现，先看看新的特急消息的处理类，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialUrgencyMessageController</span> <span class="keyword">extends</span> <span class="title">AbstractMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpecialUrgencyMessageController</span><span class="params">(MessageSender impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        message = <span class="string">"特急："</span> + message;</span><br><span class="line">        <span class="keyword">super</span>.sendMessage(message, toUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hurry</span><span class="params">(String messageId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行催促的业务，发出催促的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看使用手机短消息的方式发送消息的实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderMobile</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message, String toUser)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用手机的方式，发送消息'"</span> + message + <span class="string">"'给"</span> + toUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试一下功能"><a href="#测试一下功能" class="headerlink" title="测试一下功能"></a>测试一下功能</h3><p>看了上面的实现，可能会感觉得到，使用桥接模式来实现前面的示例过后，添加新的消息处理，或者是新的消息发送方式是如此简单，可是这样实现，好用吗？写个客户端来测试和体会一下，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建具体的实现对象</span></span><br><span class="line">        MessageSender impl = <span class="keyword">new</span> MessageSenderSMS();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个普通消息对象</span></span><br><span class="line">        AbstractMessageController controller = <span class="keyword">new</span> CommonMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个紧急消息对象</span></span><br><span class="line">        controller = <span class="keyword">new</span> UrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个特急消息对象</span></span><br><span class="line">        controller = <span class="keyword">new</span> SpecialUrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把实现方式切换成手机短消息，然后再实现一遍</span></span><br><span class="line">        impl = <span class="keyword">new</span> MessageSenderMobile();</span><br><span class="line">        controller = <span class="keyword">new</span> CommonMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        controller = <span class="keyword">new</span> UrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line"></span><br><span class="line">        controller = <span class="keyword">new</span> SpecialUrgencyMessageController(impl);</span><br><span class="line">        controller.sendMessage(<span class="string">"请喝一杯茶"</span>, <span class="string">"小李"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用站内短消息的方式，发送消息&apos;请喝一杯茶&apos;给小李</span><br><span class="line">使用站内短消息的方式，发送消息&apos;加急：请喝一杯茶&apos;给小李</span><br><span class="line">使用站内短消息的方式，发送消息&apos;特急：请喝一杯茶&apos;给小李</span><br><span class="line">使用手机的方式，发送消息&apos;请喝一杯茶&apos;给小李</span><br><span class="line">使用手机的方式，发送消息&apos;加急：请喝一杯茶&apos;给小李</span><br><span class="line">使用手机的方式，发送消息&apos;特急：请喝一杯茶&apos;给小李</span><br></pre></td></tr></table></figure><p>前面三条是使用的站内短消息，后面三条是使用的手机短消息，正确的实现了预期的功能。看来前面的实现应该是正确的，能够完成功能，且能灵活扩展。</p><h1 id="广义桥接-Java中无处不桥接"><a href="#广义桥接-Java中无处不桥接" class="headerlink" title="广义桥接-Java中无处不桥接"></a>广义桥接-Java中无处不桥接</h1><p>使用Java编写程序，一个很重要的原则就是“面向接口编程”，说得准确点应该是“面向抽象编程”，由于在Java开发中，更多的使用接口而非抽象类，因此通常就说成“面向接口编程”了。接口把具体的实现和使用接口的客户程序分离开来，从而使得具体的实现和使用接口的客户程序可以分别扩展，而不会相互影响。</p><p>桥接模式中的抽象部分持有具体实现部分的接口，最终目的是什么，还不是需要通过调用具体实现部分的接口中的方法，来完成一定的功能，这跟直接使用接口没有什么不同，只是表现形式有点不一样。再说，前面那个使用接口的客户程序也可以持有相应的接口对象，这样从形式上就一样了。</p><p>也就是说，从某个角度来讲，桥接模式不过就是对“面向抽象编程”这个设计原则的扩展。正是通过具体实现的接口，把抽象部分和具体的实现分离开来，抽象部分相当于是使用实现部分接口的客户程序，这样抽象部分和实现部分就松散耦合了，从而可以实现相互独立的变化。</p><p>这样一来，几乎可以把所有面向抽象编写的程序，都视作是桥接模式的体现，至少算是简化的桥接模式，就算是广义的桥接吧。而Java编程很强调“面向抽象编程”，因此，广义的桥接，在Java中可以说是无处不在。</p><h1 id="桥接模式在Android中的应用"><a href="#桥接模式在Android中的应用" class="headerlink" title="桥接模式在Android中的应用"></a>桥接模式在Android中的应用</h1><p>如果各位童鞋看到这里仍然对桥接模式还是不太清楚，在这里给大家举个在Android中非常常用的桥接模式栗子：<code>AbsListView</code>与<code>ListAdapter</code>之间的桥接模式。童鞋们可以根据这个栗子体会一下桥接模式的好处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;场景问题&quot;&gt;&lt;a href=&quot;#场景问题&quot; class=&quot;headerlink&quot; title=&quot;场景问题&quot;&gt;&lt;/a&gt;场景问题&lt;/h1&gt;&lt;h2 id=&quot;发送消息&quot;&gt;&lt;a href=&quot;#发送消息&quot; class=&quot;headerlink&quot; title=&quot;发送消息&quot;&gt;&lt;/a&gt;发送消息&lt;/h2&gt;&lt;p&gt;现在我们要实现这样一个功能：发送消息。从业务上看，消息又分成普通消息、加急消息和特急消息多种，不同的消息类型，业务功能处理是不一样的，比如加急消息是在消息上添加“加急”字样，而特急消息除了添加特急外，还会做一条催促的记录，多久不完成会继续催促。从发送消息的手段上看，又有系统内短消息、手机短消息、邮件等等。现在要实现这样的发送提示消息的功能，该如何实现呢？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥接模式" scheme="http://blog.hanschen.site/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="http://blog.hanschen.site/2016/12/27/pattern_proxy/"/>
    <id>http://blog.hanschen.site/2016/12/27/pattern_proxy/</id>
    <published>2016-12-26T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们执行一个功能的函数时，经常需要在其中写入与功能不是直接相关但很有必要的代码，如日志记录、信息发送、安全和事务支持等，这些<code>枝节性代码</code>虽然是必要的，但它会带来以下麻烦：</p><ul><li>枝节性代码游离在功能性代码之外，它下是函数的目的</li><li>枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合</li><li>枝节性代码带来的耦合度会造成功能性代码移植困难，可重用性降低</li></ul><p>毫无疑问，枝节性代码和功能性代码需要分开来才能降低耦合程度，我们可以使用<strong>代理模式(委托模式)</strong>完成这个要求。代理模式的作用是：为其它对象提供一种代理以控制对这个对象的访问。在某些情况下，一 个客户不想直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。</p><p>代理模式一般涉及到三个角色：</p><ul><li><strong>抽象角色</strong>：声明真实对象和代理对象的共同接口</li><li><strong>代理角色</strong>：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象 与真实对象有相同的接口，能在任何时候代替真实对象，代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展。</li><li><strong>真实角色</strong>：代理角色所代表的真实对象，是我们最终要引用的对象</li></ul><p>常见的代理应用场景有：</p><ul><li><strong>远程代理</strong>：对一个位于不同的地址空间对象提供一个局域代表对象，如RMI中的stub</li><li><strong>虚拟代理</strong>：根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建</li><li><strong>保护代理</strong>：控制对一个对象的访问权限</li><li><strong>智能引用</strong>：提供比目标对象额外的服务和功能</li></ul><p>接下来，我们用代码来说明什么是代理模式</p><a id="more"></a><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>先看看代理模式的结构图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-29-26.png" alt="2019-9-2-12-29-26.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面给出一个小栗子说明代理模式，先定义一个抽象角色，也就是一个公共接口，声明一些需要代理的方法,本文定义一个<code>Subject</code>接口，为了简单说明，只是在里面定义一个request方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义Subject的实现类<code>RealSubject</code>，它是一个真实角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"do real request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个代理角色<code>ProxySubject</code>，跟RealSubject一样，它也继承了Subject接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"before"</span>);</span><br><span class="line">        mSubject.request();</span><br><span class="line">        System.out.print(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简易的代理模式模型就建立了，客户端在使用过程中，无需关注RealSubject，只需要关注ProxySubject就行了，并且可以在ProxySubject中插入一些非功能信的代码，比如输出Log，统计执行时间等等</p><h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><p>远程代理，对一个位于不同的地址空间对象提供一个局域代表对象。这样说大家可能比较抽象，不太能理解，但其实童鞋们可能在就接触过了，在Android中，Binder的使用就是典型的远程代理。比如ActivityManager：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-12-29-57.png" alt="2019-9-2-12-29-57.png"></p><p>在启动Activity的时，会调用<code>ActivityManager</code>的startActivity方法，我们看看Activity是怎么获取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">        (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回代理类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终是返回了一个ActivityManager的代理类，因为真正的ActivityManager是运行在内核空间的，Android应用无法直接访问得到，那么就可以借助这个ActivityManagerProxy，通过Binder与真正的ActivityManager，也就是<code>ActivityManagerService</code>交互。其中ActivityManagerService和ActivityManagerProxy都实现了同一个接口：<code>IActivityManager</code>。这个就是Android中典型的代理模式的栗子了。至于ActivityManagerService和ActivityManagerProxy是如何通过Binder实现远程调用，这个就是另一个话题Binder的内容了，这里不再做阐述</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建。假设我们创建RealSubject需要耗费一定的资源，那么，我们可以把创建它延迟到实际调用的时候，优化Client初始化速度，比如，这样修改ProxySubject以达到延迟加载:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延时加载</span></span><br><span class="line">        <span class="keyword">if</span> (mSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        mSubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client在实例化ProxySubject的时候，不需消耗资源，而是等到真正调用request的时候，才会加载RealSubject，达到延时加载的效果</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>可以在Proxy类中加入进行权限，验证是否具有执行真实代码的权限，只有权限验证通过了才进行真实对象的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line">    <span class="keyword">private</span> User        mUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUser = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证权限</span></span><br><span class="line">        <span class="keyword">if</span> (mUser.isLogin()) &#123;</span><br><span class="line">            mSubject.request();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="额外功能"><a href="#额外功能" class="headerlink" title="额外功能"></a>额外功能</h2><p>通过引入代理类，可以方便地在功能性代码前后插入扩展，如Log输出，调用统计等，实现对原代码的<strong>无侵入</strong>式代码扩展，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Log: before"</span>);</span><br><span class="line">        mSubject.request();</span><br><span class="line">        System.out.print(<span class="string">"Log: after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h1><p>静态代理和动态代理的概念和使用可以参考我另一篇文章：<a href="http://blog.csdn.net/shensky711/article/details/52872249" target="_blank" rel="noopener">Java动态代理：http://blog.csdn.net/shensky711/article/details/52872249</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;我们执行一个功能的函数时，经常需要在其中写入与功能不是直接相关但很有必要的代码，如日志记录、信息发送、安全和事务支持等，这些&lt;code&gt;枝节性代码&lt;/code&gt;虽然是必要的，但它会带来以下麻烦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;枝节性代码游离在功能性代码之外，它下是函数的目的&lt;/li&gt;
&lt;li&gt;枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合&lt;/li&gt;
&lt;li&gt;枝节性代码带来的耦合度会造成功能性代码移植困难，可重用性降低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;毫无疑问，枝节性代码和功能性代码需要分开来才能降低耦合程度，我们可以使用&lt;strong&gt;代理模式(委托模式)&lt;/strong&gt;完成这个要求。代理模式的作用是：为其它对象提供一种代理以控制对这个对象的访问。在某些情况下，一 个客户不想直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。&lt;/p&gt;
&lt;p&gt;代理模式一般涉及到三个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抽象角色&lt;/strong&gt;：声明真实对象和代理对象的共同接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理角色&lt;/strong&gt;：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象 与真实对象有相同的接口，能在任何时候代替真实对象，代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真实角色&lt;/strong&gt;：代理角色所代表的真实对象，是我们最终要引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的代理应用场景有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;远程代理&lt;/strong&gt;：对一个位于不同的地址空间对象提供一个局域代表对象，如RMI中的stub&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟代理&lt;/strong&gt;：根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保护代理&lt;/strong&gt;：控制对一个对象的访问权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;智能引用&lt;/strong&gt;：提供比目标对象额外的服务和功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我们用代码来说明什么是代理模式&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://blog.hanschen.site/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入利器 - Dagger ‡</title>
    <link href="http://blog.hanschen.site/2016/12/18/dagger2/"/>
    <id>http://blog.hanschen.site/2016/12/18/dagger2/</id>
    <published>2016-12-17T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在开发过程中，为了实现解耦，我们经常使用依赖注入，常见的依赖注入方式有：</p><ul><li><strong>构造方法注入</strong>：在构造方法中把依赖作为参数传递进去</li><li><strong>setter方法注入</strong>：添加setter方法，把依赖传递进去</li><li><strong>接口注入</strong>：把注入方法抽到一个接口中，然后实现该接口，把依赖传递进去</li></ul><p>下面用一个小栗子来说明三种方式的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">DependencyInjecter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter方法注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonDao</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口注入：实现DependencyInjecter接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectPersonDao</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a id="more"></a><p>我们来看下使用一般的依赖注入方法时，代码会是怎么样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建PersonService的依赖：personDao</span></span><br><span class="line">        PersonDao personDao = <span class="keyword">new</span> PersonDaoImpl();</span><br><span class="line">        <span class="comment">// 通过构造方法注入依赖</span></span><br><span class="line">        mService = <span class="keyword">new</span> PersonService(personDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来还好是吧？但现实情况下，依赖情况往往是比较复杂的，比如很可能我们的依赖关系如下图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-38-41.png" alt="2019-9-2-11-38-41.png"></p><p>PersonDaoImpl依赖类A，类A依赖B，B依赖C和D…在这种情况下，我们就要写出下面这样的代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建依赖D</span></span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        <span class="comment">// 创建依赖C</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        <span class="comment">// 创建依赖B</span></span><br><span class="line">        B b = <span class="keyword">new</span> B(c, d);</span><br><span class="line">        <span class="comment">// 创建依赖A</span></span><br><span class="line">        A a = <span class="keyword">new</span> A(b);</span><br><span class="line">        <span class="comment">// 创建PersonService的依赖：personDao</span></span><br><span class="line">        PersonDao personDao = <span class="keyword">new</span> PersonDaoImpl(a);</span><br><span class="line">        <span class="comment">// 通过构造方法注入依赖</span></span><br><span class="line">        mService = <span class="keyword">new</span> PersonService(personDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity只是想使用PersonService而已，却不得不关注PersonService的依赖是什么、PersonDaoImpl依赖的依赖是什么，需要把整个依赖关系搞清楚才能使用PersonService。而且还有一个不好的地方，一旦依赖关系变更了，比如A不再依赖B了，那么就得修改所有创建A的地方。那么，有没有更好的方式呢？Dagger就是为此而生的，让我们看看使用Dagger后，MainActivity会变成什么模样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dagger注入，读者现在可先不关注里面做了什么操作</span></span><br><span class="line">        DaggerPersonServiceComponent.create().inject(MainActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，mService已经是非空了，可以正常使用</span></span><br><span class="line">        mService.update(<span class="number">1</span>, <span class="string">"HansChen"</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前创建A、B、C、D、PersonDaoImpl等依赖的代码全不见了，只需要调用一个注入语句就全搞定了。调用了注入语句之后，mService就可以正常使用了，是不是挺方便呢？至于这句注入语句具体干了什么，读者现在可以先不管，后面会有详细说明，这里只是做一个使用演示而已。</p><p>我们大概猜想一下，在MainActivity使用PersonService需要做哪些？</p><ol><li>分析生成依赖关系图，如PersonService–&gt;PersonDaoImpl–&gt;A–&gt;B–&gt;C&amp;D</li><li>根据依赖关系图获取相关依赖，比如依次创建D、C、B、A、PersonDaoImpl、PersonService的实例</li><li>把生成的PersonService实例传递给MainActivity的mService成员变量</li></ol><p>其实Dagger做的也就是上面这些事情了，接下来就让我们真正开始学习Dagger吧</p><h1 id="声明需要注入的对象"><a href="#声明需要注入的对象" class="headerlink" title="声明需要注入的对象"></a>声明需要注入的对象</h1><p>首先我们应该用<code>javax.inject.Inject</code>去注解需要被自动注入的对象，@Inject是Java标准的依赖注入（JSR-330）注解。比如下面栗子中，需要注入的对象就是MainActivity的mService。这里有个要注意的地方，<strong>被@Inject注解的变量不能用private修饰</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，不能被private修饰</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PersonService mService;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何实例化出依赖？"><a href="#如何实例化出依赖？" class="headerlink" title="如何实例化出依赖？"></a>如何实例化出依赖？</h1><p>在执行依赖注入的时候，Dagger会查找@Inject注解的成员变量，并尝试获取该类的实例，Dagger最直接的方式就是直接new出相应的对象了。实例化对象的时候，会调用对象的构造方法，但假如有多个构造方法，具体用哪个构造方法来实例化对象？Dagger肯定是不会帮我们“擅自做主”的，用哪个构造方法来实例化对象应该是由我们做主的，所以我们需要<strong>给相应的构造方法添加@Inject注解</strong>。<br>当Dagger需要实例化该对象的时候，会调用@Inject注解的构造方法来实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> <span class="keyword">implements</span> <span class="title">DependencyInjecter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用@Inject注解，相当于告诉Dagger需要实例化PersonService的时候，请调用这个构造方法</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明的你应该发现了，调用PersonService的构造方法需要传入PersonDao实例，所以要实例化PersonService，必须先要实例化PersonDao，Dagger会帮我们自动分析出这个依赖关系，并把它添加到<strong>依赖关系图</strong>里面！Dagger会尝试先去实例化一个PersonDao,如果PersonDao又依赖于另外一个对象A，那么就先尝试去实例化A……以此类推，是不是很像递归？当所有依赖都被实例化出来之后，我们的PersonService当然也被构造出来了。</p><p>问题又来了，如果PersonDao是一个接口呢？Dagger怎么知道这个接口应该怎么实现？答案是不知道的，那么Dagger怎么实例化出一个接口出来？这个就是Module存在的意义之一了。关于Module的讲解我们会在后面详细说明，我们现在只要知道，Module里面会定义一些方法，这些方法会返回我们的依赖，就像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供PersonDao接口实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">PersonDao <span class="title">providePersonDao</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonDaoImpl(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dagger根据需求获取一个实例的时候，并不总是通过new出来的，它会<strong>优先</strong>查找Module<br>中是否有返回相应实例的方法，如果有，就调用Module的方法来获取实例。</p><p>比如你用@Inject注解了一个成员变量，Dagger会查找Module中是否有用@Provides注解的，返回该类实例的方法，有的话就会调用provide方法来获得实例，然后注入，如果没有的话Dagger就会尝试new出一个实例。就像我们现在这个栗子，PersonService依赖于PersonDao接口，Dagger不能直接为我们new出一个接口，但我们可以提供一个Module，在Module中定义一个返回PersonDao接口实例的方法，这样，Dagger就可以解决实例化PersonDao的问题了。</p><p>我们再梳理一下流程，如果我们用@Inject注解了一个成员变量，并调用注入代码之后，Dagger会这样处理：</p><ol><li>查找Module中是否有用@Provides注解的，返回该类实例的方法</li><li>如果有，就调用那个provide方法来获得实例，然后注入</li><li>如果没有，就尝试调用相应的类中被@Inject注解的构造方法new出一个实例，然后注入</li><li>如果没有一个构造方法被@Inject注解，Dagger会因不能满足依赖而出错</li></ol><p>所以假如一个变量被@Inject注解，要么在Module中提供provide方法获取实例，要么该类提供一个被@Inject注解的构造方法，否则Dagger会出错</p><h1 id="Module的使用"><a href="#Module的使用" class="headerlink" title="Module的使用"></a>Module的使用</h1><p>一般而言，Dagger会获取所有依赖的实例，比如当需要一个<code>TestBean</code>的时候，会通过<code>new TestBean()</code>创建实例并注入到类中。但是，以下情况会就不好处理了：</p><ol><li>需要生成的是一个接口，而Dagger不能直接实例化接口</li><li>不能在第三方库的类中添加注解</li><li>可配置的对象必须是配置的</li></ol><p>为了解决以上问题，我们需要定义一个被@Module注解的类，在里面定义用<code>@Provides</code>注解的方法。用该方法返回所需的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">D <span class="title">provideD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> D();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">C <span class="title">provideC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">B <span class="title">provideB</span><span class="params">(C c, D d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B(c, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">A <span class="title">provideA</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供PersonDao实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">PersonDao <span class="title">providePersonDao</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonDaoImpl(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像<code>providePersonDao</code>返回了PersonDao接口实例，Dagger虽然不能直接实例化出PersonDao接口，但却可以调用Module的providePersonDao方法来获得一个实例。providePersonDao方法需要传入A的实例，那么这里也构成了一个依赖关系图。Dagger会先获取A的实例，然后把实例传递给providePersonDao方法。</p><h1 id="Component的使用"><a href="#Component的使用" class="headerlink" title="Component的使用"></a>Component的使用</h1><p>到目前为止，我们虽然知道了：</p><ul><li>Dagger怎么获取实例：<ul><li>从Module的provide方法中获取</li><li>通过@Inject注解的构造方法new出新的实例</li></ul></li><li>Dagger会推导provide方法和构造方法的参数，形成依赖图，并“满足”我们依赖图的需求，获取依赖的实例</li></ul><p>看样子需要注入的依赖可以获取了，但是不是总觉得还有点“零碎”，整个流程还没连贯起来？比如，Module既然是一个类，生成依赖图的时候，怎么知道跟哪个Module挂钩？即使最后生成了需要的实例，注入的“目的地”是哪里？怎么才能把它注入到“目的地”？残缺的这部分功能，正是Component提供的，Component起到了一个桥梁的作用，贯通Module和注入目标。我们来看看最开始那个例子，我们是怎么进行依赖注入的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    PersonService mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        PersonServiceComponent component = DaggerPersonServiceComponent.builder()</span><br><span class="line">                                                                       .personServiceModule(<span class="keyword">new</span> PersonServiceModule())</span><br><span class="line">                                                                       .build();</span><br><span class="line">        <span class="comment">// 注入,所有@Inject注解的成员变量都会同时注入</span></span><br><span class="line">        component.inject(MainActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过component获取实例，注意，这里只是演示用法，其实mService在component.inject的时候已经完成了注入</span></span><br><span class="line">        mService = component.getPersonService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个DaggerPersonServiceComponent是什么鬼？DaggerPersonServiceComponent其实是Dagger为我们<strong>自动生成</strong>的类，它实现了一个Component接口（这个接口是需要我们自己写的），我们来看下它实现的接口长什么样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定PersonServiceModule，当需要获取某实例的时候，会查找PersonServiceModule中是否有返回相应类型的方法，有的话就通过该方法获得实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(modules = PersonServiceModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonServiceComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找activity中被<span class="doctag">@Inject</span>注解的成员变量，并尝试获取相应的实例，把实例赋给activity的成员变量</span></span><br><span class="line"><span class="comment">     * 注意函数格式:返回值为空、带有一个参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dagger会尝试从Module中获取PersonService实例，如果Module中不能获取对应实例，则通过PersonService的构造方法new出一个实例</span></span><br><span class="line"><span class="comment">     * 注意函数格式：参数为空，返回值非空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PersonService <span class="title">getPersonService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口被Component注解修饰，它里面可以定义3种类型的方法：</p><ul><li>返回值为空，有一个参数：查找参数中被@Inject注解的成员变量，并尝试获取相应的实例（通过Module的provide方法或@Inject注解的构造方法new出新的实例），把实例赋给参数的成员变量</li><li>返回值非空，参数为空：获取相应实例并返回</li><li>返回值是Component，参数是Moduld，通过该方法可以创建SubComponent实例</li></ul><p>既然获取实例的时候，有可能用到Module，那么就必须为这个Component指定使用的Module是什么。具体做法就是在@Component注解中指定modules。<br>定义好Component之后，Dagger会自动帮我们生成实现类，这就是Dagger强大的地方！生成的类名格式是：Dagger+Component名。<br>Component提供了2种方法，一个是注入式方法，一个是获取实例方法。具体用什么方法，就看个人需求了。<strong>一个Component其实也对应了一个依赖图</strong>，因为Component使用哪个Module是确定不变的，依赖关系无非也就是跟Module和类的定义有关。一旦这些都确定下来了，在这个Component范围内，依赖关系也就被确定下来了。额外再说一点，在Dagger1中，Component的功能是由<code>ObjectGraph</code>实现的，Component是用来代替它的。</p><p>Component定义好之后，build一下工程，Dagger就会自动为我们生成实现类了，就可以使用自动生成的实现类来进行依赖注入了。到现在为止，我们已经通过Dagger完成了依赖注入。可能看起来比正常方法麻烦得多，但是Dagger框架可以让依赖的注入和配置独立于组件之外，它帮助你专注在那些重要的功能类上。通过声明依赖关系和指定规则构建整个应用程序。</p><p>熟悉完Dagger基本的使用之后，接下来我们来讲解一些稍微高级一点的用法：</p><h1 id="Dagger的进阶使用"><a href="#Dagger的进阶使用" class="headerlink" title="Dagger的进阶使用"></a>Dagger的进阶使用</h1><h2 id="Components之间的关系"><a href="#Components之间的关系" class="headerlink" title="Components之间的关系"></a>Components之间的关系</h2><p>在Dagger中，Component之间可以有两种关系:Subcomponents和Component dependencies。他们有什么作用呢？比如在我们应用中，经常会有一些依赖我们在各个界面都使用得到，比如操作数据库、比如网络请求。假设我们有个ServerApi的接口，在页面A、B、C都使用到了，那么我们要在页面A、B、C的Component里面都能获取到ServerApi的实例，但显然，获取ServerApi实例的方法都是一样的，我们不想写重复的代码。于是我们可定义一个ApplicationComponent，在里面返回ServerApi实例，通过Component之间的关系便可以共享ApplicationComponent提供的依赖图。</p><p>下面通过Android中的一个小栗子来说明Subcomponents和Component dependencies如何使用</p><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>先说明下各个模块之间的关系<br>首先，我们定义一个ApplicationComponent，它定义了一个方法，通过它来获得ServerApi实例。ApplicationComponent还关联了ApplicationModule，这个Module是ServerApi实例的提供者，注意，这个Moduld还可以返回Context实例<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-41-18.png" alt="2019-9-2-11-41-18.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServerApi <span class="title">getServerApi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mAppContext;</span><br><span class="line"></span><br><span class="line">    ApplicationModule(Context context) &#123;</span><br><span class="line">        mAppContext = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Context <span class="title">provideAppContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAppContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApi</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImpl(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationComponent mAppComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mAppComponent = DaggerApplicationComponent.builder().applicationModule(<span class="keyword">new</span> ApplicationModule(<span class="keyword">this</span>)).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationComponent <span class="title">getAppComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAppComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity使用MVP模式，在MainPresenter里面需要传入一个ServerApi对象<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-43-13.png" alt="2019-9-2-11-43-13.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，这里有个dependencies声明</span></span><br><span class="line"><span class="meta">@Component</span>(dependencies = ApplicationComponent.class, modules = MainPresenterModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainPresenterComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MainPresenter <span class="title">getMainPresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenterModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainView mMainView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenterModule</span><span class="params">(MainView mainView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainView = mainView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">MainView <span class="title">provideMainView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMainView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainView  mMainView;</span><br><span class="line">    <span class="keyword">private</span> ServerApi mServerApi;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenter</span><span class="params">(MainView mainView, ServerApi serverApi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainView = mainView;</span><br><span class="line">        <span class="keyword">this</span>.mServerApi = serverApi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先抛开dependencies，我们分析这个这个依赖树是怎么样的<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-43-43.png" alt="2019-9-2-11-43-43.png"><br>Component中getMainPresenter的目的很简单，就是返回MainPresenter，而MainPresenter又依赖MainView和ServerApi，MainView还好说，在MainPresenterModule中有provide方法，但是ServerApi呢？就像上面说的那样，如果我们在这个Moduld中也添加相应的provide方法，那真是太麻烦了（当然，这样做完全是可以实现的），所以我们依赖了ApplicationComponent，通过dependencies，在被依赖的Component暴露的对象，在子Component中是可见的。这个是什么意思呢？意思有两个：</p><ol><li>被依赖Component接口暴露的对象，可以添加到依赖者的依赖图中</li><li>Component接口没有暴露的对象，依赖者是不可见的</li></ol><p>对于第一点应该比较好理解，就像这个栗子，MainPresenterComponent生成MainPresenter需要ServerApi，而ApplicationComponent中有接口暴露了ServerApi，所以MainPresenterComponent可以获得ServerApi<br>对于第二点，假设MainPresenter还需要传入一个Context对象，我们注意到，ApplicationModule是可以提供Context的，那MainPresenterComponent能不能通过ApplicationComponent获取Context实例？答案是不行的，因为ApplicationComponent没有暴露这个对象。想要获取Context，除非ApplicationComponent中再添加一个getContext的方法。</p><p>他们之间的关系可以用下图描述：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-44-12.png" alt="2019-9-2-11-44-12.png"></p><h3 id="Subcomponents"><a href="#Subcomponents" class="headerlink" title="Subcomponents"></a>Subcomponents</h3><p>Subcomponents 实现方法一：</p><ul><li>先定义子 Component，使 用@Subcomponent 标注（不可同时再使用 @Component）</li><li>父 Component 中定义获得子 Component 的方法</li></ul><p>让我们对上面的栗子改造改造：<br>去除MainPresenterComponent的Component注解，改为Subcomponent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span>(modules = MainPresenterModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainPresenterComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MainPresenter <span class="title">getMainPresenter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ApplicationComponent中新增plus方法（名字可随意取），返回值为MainPresenterComponent，参数为MainPresenterModule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MainPresenterComponent <span class="title">plus</span><span class="params">(MainPresenterModule <span class="keyword">module</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就构建了一个ApplicationComponent的子图：MainPresenterComponent。子图和dependencies的区别就是，子图可以范围父图所有的依赖，也就是说，子图需要的依赖，不再需要在父Component中暴露任何对象，可以直接通过父图的Moduld提供！他们的关系变为了：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-44-34.png" alt="2019-9-2-11-44-34.png"></p><p>这里需要注意的是，以上代码直接在父 Component 返回子 Component 的形式，要求子 Component 依赖的 Module 必须包含一个无参构造函数，用以自动实例化。如果 Module 需要传递参数，则需要使用 <code>@Subcomponent.builder</code> 的方式，实现方法二实现步骤如下：</p><ul><li>在子 Component，定义一个接口或抽象类（通常定义为 Builder），使用 @Subcomponent.Builder 标注<ul><li>编写返回值为 Builder，方法的参数为需要传入参数的 Module</li><li>编写返回值为当前子 Component的 无参方法</li></ul></li><li>父 Component 中定义获得子 Component.Builder 的方法</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestModule</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">AuthManager <span class="title">provideAuthManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AuthManager.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subcomponent</span>(modules = &#123;TestModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">AuthManager <span class="title">getAuthManager</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Builder <span class="title">createBuilder</span><span class="params">(TestModule <span class="keyword">module</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">TestComponent <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    TestComponent.<span class="function">Builder <span class="title">testComponentBuilder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">TestComponent testComponent = mApplicationComponent.testComponentBuilder().createBuilder(<span class="keyword">new</span> TestModule(<span class="string">"test"</span>)).build();</span><br></pre></td></tr></table></figure><h2 id="Binds注解"><a href="#Binds注解" class="headerlink" title="Binds注解"></a>Binds注解</h2><p>在Dagger2中，一般都是使用@provide方法注入接口。在Android 中，一般我们会这样做，创建一个接口 Presenter 命名 为 HomePresenter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomePresenter</span> </span>&#123;</span><br><span class="line">   Observable&lt;List&lt;User&gt;&gt; loadUsers()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个这个接口的实例：HomePresenterImp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePresenterImp</span> <span class="keyword">implements</span> <span class="title">HomePresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomePresenterImp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;List&lt;User&gt;&gt; loadUsers()&#123;</span><br><span class="line">        <span class="comment">//Return user list observable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Module 中，提供实例化的 provide 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HomePresenter <span class="title">providesHomePresenter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HomePresenterImp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们需要添加一个依赖到 presenter 叫 UserService，那就意味着，我们也要在 module 中添加一个 provide 方法提供这个 UserService，然后在 HomePresenterImp 类中加入一个 UserService 参数的构造方法。<br>有没有觉得这种方法很麻烦呢？我们还可以用 @Binds 注解，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变为 abstract 方法， 同时 Module 也必须声明为 abstract， 传入的参数必须为返回参数的实现类</span></span><br><span class="line">    <span class="comment">// 当需要 HomePresenter 时，dagger 会自动实例化 HomePresenterImp 并返回</span></span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> HomePresenter <span class="title">bindHomePresenter</span><span class="params">(HomePresenterImp homePresenterImp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了方便，使用 @Binds 注解还可以让 dagger2 生成的代码效率更高。但是需要注意的是，由于 Module 变为抽象类，Module 不能再包含非 static 的带 @Provides 注解的方法。而且这时候，依赖此 Module 的 Component 也不需要传入此 Module 实例了（也实例化不了，因为它是抽象的）。相当于此 Module 仅仅作为描述依赖关系的一个类</p><h2 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h2><p>Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。@Singleton是被Dagger预先定义的作用域注解。</p><ul><li>没有指定作用域的@Provides方法将会在每次注入的时候都创建新的对象</li><li>一个没有scope的component不可以依赖一个有scope的组件component</li><li>子组件和父组件的scope不能相同</li><li>Module中provide方法的scope需要与Component的scope一致</li></ul><p>我们通常的ApplicationComponent都会使用Singleton注解，也就会是说我们如果自定义component必须有自己的scope。读者到这里，可能还不能理解Scopes的作用，我们先来看下默认提供的Singlton到底有什么作用，然后再讨论Scopes的意义：</p><h2 id="Singlton"><a href="#Singlton" class="headerlink" title="Singlton"></a>Singlton</h2><p>Singletons是java提供的一个scope，我们来看看Singletons能做什么事情。<br>为@Provides注释的方法或可注入的类添加添加注解@Singlton，构建的这个对象图表将使用唯一的对象实例，比如我们有个ServerApi<br>方法一：用@Singleton注解类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HansChen"</span>.equals(username) &amp;&amp; <span class="string">"123456"</span>.equals(password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：用@Singleton注解Module的provide方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们有个Component：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServerApi <span class="title">getServerApi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行依赖注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    ServerApi mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ApplicationComponent component = DaggerApplicationComponent.create();</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, component.getServerApi().toString());</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, component.getServerApi().toString());</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, component.getServerApi().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了以上两种方法的任意一种，我们都会发现，通过component.getServerApi()获得的实例都是同一个实例。不过要注意一点的是，如果类用@Singleton注解了，但Module中又存在一个provide方法是提供该类实例的，但provide方法没有用@Singleton注解，那么Component中获取该实例就不是单例的，因为会优先查找Module的方法。<br>这个单例是相对于同一个Component而言的，不同的Component获取到的实例将会是不一样的。</p><h2 id="自定义Scope"><a href="#自定义Scope" class="headerlink" title="自定义Scope"></a>自定义Scope</h2><p>既然一个没有scope的component不可以依赖一个有scope的组件component，那么我们必然需要自定义scope来去注解自己的Component了，定义方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FragmentScoped &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义出来的FragmentScoped在使用上和Singleton是一样的，那它和Singleton除了是不一样的注解之外，还有什么不一样呢？答案是没有！我们自定义的scope和Singleton并没有任何不一样，不会因为Singleton是java自带的注解就会有什么区别。</p><p>那么，这个scope的设定是为了什么呢？</p><h2 id="scope的作用"><a href="#scope的作用" class="headerlink" title="scope的作用"></a>scope的作用</h2><p>scope除了修饰provide方法可以让我们获得在同一个Component实例范围内的单例之外，主要的作用就是对Component和Moduld的分层管理以及依赖逻辑的可读性。<br>这里借用一个网络上的图片说明：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-44-58.png" alt="2019-9-2-11-44-58.png"></p><p>ApplicationComponent一般会用singleton注解，相对的，它的Module中provide方法也只能用singleton注解。UserComponent是用UserSCope能直接使用ApplicationModule吗？不能！因为他俩的scope不一致，这就是这个设定带来的好处，防止不同层级的组件混乱。另外，因为有了scope的存在，各种组件的作用和生命周期也变得可读起来了</p><h2 id="Lazy注入"><a href="#Lazy注入" class="headerlink" title="Lazy注入"></a>Lazy注入</h2><p>有时可能会需要延迟获取一个实例。对任何绑定的 T，可以构建一个 Lazy<t> 来延迟实例化直至第一次调用 Lazy<t> 的 get() 方法。注入之后，第一次get的时会实例化出 T，之后的调用都会获取相同的实例。</t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">MainView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒加载</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Lazy&lt;MainPresenter&gt; mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        MainPresenterComponent component = DaggerMainPresenterComponent.builder()</span><br><span class="line">                                                                       .mainPresenterModule(<span class="keyword">new</span> MainPresenterModule(<span class="keyword">this</span>))</span><br><span class="line">                                                                       .applicationComponent(((DemoApplication) getApplication()).getAppComponent())</span><br><span class="line">                                                                       .build();</span><br><span class="line">        component.inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 实例化MainPresenter</span></span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 跟上次获取的实例是同一个实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Provider注入"><a href="#Provider注入" class="headerlink" title="Provider注入"></a>Provider注入</h2><p>跟Lazy注入不一样的是，有时候我们希望每次调用get的时候，获取到的实例都是不一样的，这时候可以用Provider注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">MainView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Provider</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Provider&lt;MainPresenter&gt; mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        MainPresenterComponent component = DaggerMainPresenterComponent.builder()</span><br><span class="line">                                                                       .mainPresenterModule(<span class="keyword">new</span> MainPresenterModule(<span class="keyword">this</span>))</span><br><span class="line">                                                                       .applicationComponent(((DemoApplication) getApplication()).getAppComponent())</span><br><span class="line">                                                                       .build();</span><br><span class="line">        component.inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 实例化MainPresenter</span></span><br><span class="line">        Log.d(<span class="string">"Hans"</span>, mPresenter.get().toString()); <span class="comment">// 获取新的MainPresenter实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qualifiers注入"><a href="#Qualifiers注入" class="headerlink" title="Qualifiers注入"></a>Qualifiers注入</h2><p>到目前为止，我们的demo里，Moduld的provide返回的对象都是不一样的,但是下面这种情况就不好处理了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回ServerApi实例</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiA</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplA(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ServerApi实例</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiB</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplB(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provideServerApiA和provideServerApiB返回的都是ServerApi，Dagger是无法判断用哪个provide方法的。这时候就需要添加Qualifiers了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">"ServerApiImplA"</span>)</span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiA</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplA(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">"ServerApiImplB"</span>)</span><br><span class="line">    <span class="function">ServerApi <span class="title">provideServerApiB</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerApiImplB(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样一个限定，就能区分出2个方法的区别了，当然，在使用过程中，也同样要指明你用哪个name的实例,Dagger会根据你的name来选取对应的provide方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainView  mMainView;</span><br><span class="line">    <span class="keyword">private</span> ServerApi mServerApi;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenter</span><span class="params">(MainView mainView, @Named(<span class="string">"ServerApiImplA"</span>)</span> ServerApi serverApi) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainView = mainView;</span><br><span class="line">        <span class="keyword">this</span>.mServerApi = serverApi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了用Named注解，你也可以创建你自己的限定注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YourQualifier &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译时验证"><a href="#编译时验证" class="headerlink" title="编译时验证"></a>编译时验证</h2><p>Dagger 包含了一个注解处理器（annotation processor）来验证模块和注入。这个过程很严格而且会抛出错误，当有非法绑定或绑定不成功时。下面这个例子缺少了 Executor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span> <span class="function">Heater <span class="title">provideHeater</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpuHeater(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译时，javac 会拒绝绑定缺少的部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] COMPILATION ERROR :</span><br><span class="line">[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.</span><br></pre></td></tr></table></figure><p>可以通过给方法 Executor 添加@Provides注解来解决这个问题，或者标记这个模块是不完整的。不完整的模块允许缺少依赖关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span>(complete = <span class="keyword">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span> <span class="function">Heater <span class="title">provideHeater</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpuHeater(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>第一次接触用Dagger框架写的代码时候，如果不了解各种注解作用的时候，那真会有一脸懵逼的感觉，而且单看文章，其实还是很抽象，建议大家用Dagger写个小demo玩玩，很快就上手了，这里提供几个使用Dagger的栗子，希望可以帮助大家上手Dagger</p><ul><li><a href="https://github.com/google/dagger/tree/master/examples" target="_blank" rel="noopener">Dagger demo</a></li><li><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-dagger" target="_blank" rel="noopener">谷歌官方 MVP+Dagger2 Demo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在开发过程中，为了实现解耦，我们经常使用依赖注入，常见的依赖注入方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造方法注入&lt;/strong&gt;：在构造方法中把依赖作为参数传递进去&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setter方法注入&lt;/strong&gt;：添加setter方法，把依赖传递进去&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口注入&lt;/strong&gt;：把注入方法抽到一个接口中，然后实现该接口，把依赖传递进去&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面用一个小栗子来说明三种方式的用法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PersonService&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DependencyInjecter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; PersonDao personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造方法注入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PersonService&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PersonDao personDao)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.personDao = personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// setter方法注入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setPersonDao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PersonDao personDao)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.personDao = personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 接口注入：实现DependencyInjecter接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;injectPersonDao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PersonDao personDao)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.personDao = personDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ... ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.hanschen.site/categories/Java/"/>
    
    
      <category term="依赖注入" scheme="http://blog.hanschen.site/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Dagger" scheme="http://blog.hanschen.site/tags/Dagger/"/>
    
  </entry>
  
  <entry>
    <title>Robolectric使用教程</title>
    <link href="http://blog.hanschen.site/2016/12/10/robolectric/"/>
    <id>http://blog.hanschen.site/2016/12/10/robolectric/</id>
    <published>2016-12-09T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android的单元测试可以分为两部分：</p><ol><li>Local unit tests：运行于本地JVM</li><li>Instrumented test：运行于真机或者模拟器</li></ol><p>如果使用Local测试，需要保证测试过程中不会调用Android系统API，否则会抛出RuntimeException异常，因为Local测试是直接跑在本机JVM的，而之所以我们能使用Android系统API，是因为编译的时候，我们依赖了一个名为“android.jar”的jar包，但是jar包里所有方法都是直接抛出了一个RuntimeException，是没有任何任何实现的，这只是Android为了我们能通过编译提供的一个Stub！当APP运行在真实的Android系统的时候，由于类加载机制，会加载位于framework的具有真正实现的类。由于我们的Local是直接在PC上运行的，所以调用这些系统API便会出错。<br>那么问题来了，我们既要使用Local测试，但测试过程又难免遇到调用系统API那怎么办？其中一个方法就是mock objects，比如借助Mockito，另外一种方式就是使用<code>Robolectric</code>， Robolectric就是为解决这个问题而生的。它实现一套JVM能运行的Android代码，然后在unit test运行的时候去截取android相关的代码调用，然后转到他们的他们实现的Shadow代码去执行这个调用的过程</p><a id="more"></a><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><h2 id="为项目添加依赖"><a href="#为项目添加依赖" class="headerlink" title="为项目添加依赖"></a>为项目添加依赖</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile <span class="string">"org.robolectric:robolectric:3.1.4"</span></span><br></pre></td></tr></table></figure><p>Robolectric在第一次运行时，会下载一些sdk依赖包，每个sdk依赖包大概50M，下载速度比较慢，用户可以直接在网上下载相应依赖包，放置在本地maven仓库地址中，默认路径为：<code>C:\Users\username\.m2\repository\org\robolectric</code></p><h2 id="指定RobolectricTestRunner为运行器"><a href="#指定RobolectricTestRunner为运行器" class="headerlink" title="指定RobolectricTestRunner为运行器"></a>指定RobolectricTestRunner为运行器</h2><p>为测试用例添加注解,指定测试运行器为RobolectricTestRunner。注意，这里要通过Config指定<code>constants = BuildConfig.class</code>，Robolectric 会通过constants推导出输出路径，如果不进行配置，Robolectric可能不能找到你的manifest、resources和assets资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是Shadow类"><a href="#什么是Shadow类" class="headerlink" title="什么是Shadow类"></a>什么是Shadow类</h2><p>Shadow是Robolectric的立足之本，如其名，作为影子，一定是变幻莫测，时有时无，且依存于本尊。Robolectric定义了大量模拟Android系统类行为的Shadow类，当这些系统类被创建的时候，Robolectric会查找对应的Shadow类并创建一个Shadow类与原始类关联。每当系统类的方法被调用的时候，Robolectric会保证Shadow对应的方法会调用。这些Shadow对象，丰富了本尊的行为，能更方便的对Android相关的对象进行测试。<br>比如，我们可以借助ShadowActivity验证页面是否正确跳转了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证点击事件是否触发了页面跳转，验证目标页面是否预期页面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJump</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 默认会调用Activity的生命周期: onCreate-&gt;onStart-&gt;onResume</span></span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    <span class="comment">// 触发按钮点击</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_jump).performClick();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的Shadow类</span></span><br><span class="line">    ShadowActivity shadowActivity = Shadows.shadowOf(activity);</span><br><span class="line">    <span class="comment">// 借助Shadow类获取启动下一Activity的Intent</span></span><br><span class="line">    Intent nextIntent = shadowActivity.getNextStartedActivity();</span><br><span class="line">    <span class="comment">// 校验Intent的正确性</span></span><br><span class="line">    assertEquals(nextIntent.getComponent().getClassName(), SecondActivity.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Config配置"><a href="#Config配置" class="headerlink" title="@Config配置"></a>@Config配置</h2><p>可以通过<code>@Config</code>定制Robolectric的运行时的行为。这个注解可以用来注释类和方法，如果类和方法同时使用了@Config，那么方法的设置会覆盖类的设置。你可以创建一个基类，用@Config配置测试参数，这样，其他测试用例就可以共享这个配置了</p><h2 id="配置SDK版本"><a href="#配置SDK版本" class="headerlink" title="配置SDK版本"></a>配置SDK版本</h2><p>Robolectric会根据manifest文件配置的targetSdkVersion选择运行测试代码的SDK版本，如果你想指定sdk来运行测试用例，可以通过下面的方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Config</span>(sdk = Build.VERSION_CODES.JELLY_BEAN)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Config</span>(sdk = Build.VERSION_CODES.KITKAT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSandwich_shouldReturnHamSandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Application类"><a href="#配置Application类" class="headerlink" title="配置Application类"></a>配置Application类</h2><p>Robolectric会根据manifest文件配置的Application配置去实例化一个Application类，如果你想在测试用例中重新指定，可以通过下面的方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Config</span>(application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Config</span>(application = CustomApplicationOverride.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSandwich_shouldReturnHamSandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定Resource路径"><a href="#指定Resource路径" class="headerlink" title="指定Resource路径"></a>指定Resource路径</h2><p>Robolectric可以让你配置manifest、resource和assets路径，可以通过下面的方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Config</span>(manifest = <span class="string">"some/build/path/AndroidManifest.xml"</span>,</span><br><span class="line">        assetDir = <span class="string">"some/build/path/assetDir"</span>,</span><br><span class="line">        resourceDir = <span class="string">"some/build/path/resourceDir"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Config</span>(manifest = <span class="string">"other/build/path/AndroidManifest.xml"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSandwich_shouldReturnHamSandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用第三方Library-Resources"><a href="#使用第三方Library-Resources" class="headerlink" title="使用第三方Library Resources"></a>使用第三方Library Resources</h2><p>当Robolectric测试的时候，会尝试加载所有应用提供的资源，但如果你需要使用第三方库中提供的资源文件，你可能需要做一些特别的配置。不过如果你使用gradle来构建Android应用，这些配置就不需要做了，因为Gradle Plugin会在build的时候自动合并第三方库的资源，但如果你使用的是Maven，那么你需要配置libraries变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(libraries = &#123;</span><br><span class="line">    <span class="string">"build/unpacked-libraries/library1"</span>,</span><br><span class="line">    <span class="string">"build/unpacked-libraries/library2"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SandwichTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用限定的资源文件"><a href="#使用限定的资源文件" class="headerlink" title="使用限定的资源文件"></a>使用限定的资源文件</h2><p>Android会在运行时加载特定的资源文件，如根据设备屏幕加载不同分辨率的图片资源、根据系统语言加载不同的string.xml，在Robolectric测试当中，你也可以进行一个限定，让测试程序加载特定资源.多个限定条件可以用破折号拼接在在一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用qualifiers加载对应的资源文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Config</span>(qualifiers = <span class="string">"zh-rCN"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context context = RuntimeEnvironment.application;</span><br><span class="line">    assertThat(context.getString(R.string.app_name), is(<span class="string">"单元测试Demo"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Properties文件"><a href="#Properties文件" class="headerlink" title="Properties文件"></a>Properties文件</h2><p>如果你嫌通过注解配置上面的东西麻烦，你也可以把以上配置放在一个Properties文件之中，然后通过@Config指定配置文件，比如，首先创建一个配置文件robolectric.properties:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 放置Robolectric的配置选项:</span><br><span class="line">sdk=21</span><br><span class="line">manifest=some/build/path/AndroidManifest.xml</span><br><span class="line">assetDir=some/build/path/assetDir</span><br><span class="line">resourceDir=some/build/path/resourceDir</span><br></pre></td></tr></table></figure><p>然后把robolectric.properties文件放到src/test/resources目录下，运行的时候，会自动加载里面的配置</p><h2 id="系统属性配置"><a href="#系统属性配置" class="headerlink" title="系统属性配置"></a>系统属性配置</h2><ul><li>robolectric.offline：true代表关闭运行时获取jar包</li><li>robolectric.dependency.dir：当处于offline模式的时候，指定运行时的依赖目录</li><li>robolectric.dependency.repo.id：设置运行时获取依赖的Maven仓库ID，默认是sonatype</li><li>robolectric.dependency.repo.url：设置运行时依赖的Maven仓库地址，默认是<a href="https://oss.sonatype.org/content/groups/public/" target="_blank" rel="noopener">https://oss.sonatype.org/content/groups/public/</a></li><li>robolectric.logging.enabled：设置是否打开调试开关</li></ul><p>以上设置可以通过Gradle进行配置，如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    testOptions &#123;</span><br><span class="line">        unitTests.all &#123;</span><br><span class="line">            systemProperty <span class="string">'robolectric.dependency.repo.url'</span>, <span class="string">'https://local-mirror/repo'</span></span><br><span class="line">            systemProperty <span class="string">'robolectric.dependency.repo.id'</span>, <span class="string">'local'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驱动Activity生命周期"><a href="#驱动Activity生命周期" class="headerlink" title="驱动Activity生命周期"></a>驱动Activity生命周期</h2><p>利用<code>ActivityController</code>我们可以让Activity执行相应的生命周期方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLifecycle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Activity控制器</span></span><br><span class="line">    ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class);</span><br><span class="line">    MainActivity activity = controller.get();</span><br><span class="line">    assertNull(activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performCreate方法</span></span><br><span class="line">    controller.create();</span><br><span class="line">    assertEquals(<span class="string">"onCreate"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performStart方法</span></span><br><span class="line">    controller.start();</span><br><span class="line">    assertEquals(<span class="string">"onStart"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performResume方法</span></span><br><span class="line">    controller.resume();</span><br><span class="line">    assertEquals(<span class="string">"onResume"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performPause方法</span></span><br><span class="line">    controller.pause();</span><br><span class="line">    assertEquals(<span class="string">"onPause"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performStop方法</span></span><br><span class="line">    controller.stop();</span><br><span class="line">    assertEquals(<span class="string">"onStop"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performRestart方法</span></span><br><span class="line">    controller.restart();</span><br><span class="line">    <span class="comment">// 注意此处应该是onStart，因为performRestart不仅会调用restart，还会调用onStart</span></span><br><span class="line">    assertEquals(<span class="string">"onStart"</span>, activity.getLifecycleState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performDestroy方法</span></span><br><span class="line">    controller.destroy();</span><br><span class="line">    assertEquals(<span class="string">"onDestroy"</span>, activity.getLifecycleState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ActivityController，我们可以模拟各种生命周期的变化。但是要注意，我们虽然可以随意调用Activity的生命周期，但是Activity生命周期切换有自己的检测机制，我们要遵循Activity的生命周期规律。比如，如果当前Activity并非处于stop状态，测试代码去调用了controller.restart方法，此时Activity是不会回调onRestart和onStart的。</p><p>除了控制生命周期，还可以在启动Activity的时候传递Intent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动Activity的时候传递Intent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartActivityWithIntent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"test"</span>, <span class="string">"HelloWorld"</span>);</span><br><span class="line">    Activity activity = Robolectric.buildActivity(MainActivity.class).withIntent(intent).create().get();</span><br><span class="line">    assertEquals(<span class="string">"HelloWorld"</span>, activity.getIntent().getExtras().getString(<span class="string">"test"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onRestoreInstanceState回调中传递Bundle：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * savedInstanceState会在onRestoreInstanceState回调中传递给Activity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSavedInstanceState</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Bundle savedInstanceState = <span class="keyword">new</span> Bundle();</span><br><span class="line">    Robolectric.buildActivity(MainActivity.class).create().restoreInstanceState(savedInstanceState).get();</span><br><span class="line">    <span class="comment">// verify something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在真实环境下，视图是在onCreate之后的某一时刻在attach到Window上的，在此之前，View是处于不可操作状态的，你不能点击它。在Activity的onPostResume方法调用之后，View才会attach到Window之中。但是，在Robolectric之中，我们可以用控制器的<code>visible</code>方法使得View变为可见，变为可见之后，就可以模拟点击事件了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVisible</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class);</span><br><span class="line">    MainActivity activity = controller.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Activity的performCreate并且设置视图visible</span></span><br><span class="line">    controller.create().visible();</span><br><span class="line">    <span class="comment">// 触发点击</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_button1).performClick();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    assertEquals(shadowOf(activity).getNextStartedActivity().getComponent().getClassName(), SecondActivity.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="追加模块"><a href="#追加模块" class="headerlink" title="追加模块"></a>追加模块</h2><p>为了减少依赖包的大小，Robolectric的shadows类成了好几部分：</p><table><thead><tr><th>SDK Package</th><th>Robolectric Add-On Package</th></tr></thead><tbody><tr><td>com.android.support.support-v4</td><td>org.robolectric:shadows-support-v4</td></tr><tr><td>com.android.support.multidex</td><td>org.robolectric:shadows-multidex</td></tr><tr><td>com.google.android.gms:play-services</td><td>org.robolectric:shadows-play-services</td></tr><tr><td>com.google.android.maps:maps</td><td>org.robolectric:shadows-maps</td></tr><tr><td>org.apache.httpcomponents:httpclient</td><td>org.robolectric:shadows-httpclient</td></tr></tbody></table><p>用户可以根据自身需求添加以下依赖包，如</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    testCompile <span class="string">'org.robolectric:robolectric:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-support-v4:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-multidex:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-play-services:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-maps:3.1.4'</span></span><br><span class="line">    testCompile <span class="string">'org.robolectric:shadows-httpclient:3.1.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Shadow类"><a href="#自定义Shadow类" class="headerlink" title="自定义Shadow类"></a>自定义Shadow类</h2><ol><li>Shadow类需要一个public的无参构造方法以方便Robolectric框架可以实例化它，通过@Implements注解与原始类关联在一起</li><li>若原始类有<code>有参构造方法</code>，在Shadow类中定义public void类型的名为<code>__constructor__</code>的方法，且方法参数与原始类的构造方法参数一直</li><li>定义与原始类方法签名一致的方法，在里面重写实现，Shadow方法需用@Implementation进行注解</li></ol><p>下面我们来创建RobolectricBean的Shadow类<br>原始类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span>    color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RobolectricBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shadow类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建&#123;<span class="doctag">@link</span> RobolectricBean&#125;的影子类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Implements</span>(RobolectricBean.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowRobolectricBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@RealObject</span>注解可以访问原始对象，但注意，通过<span class="doctag">@RealObject</span>注解的变量调用方法，依然会调用Shadow类的方法，而不是原始类的方法</span></span><br><span class="line"><span class="comment">     * 只能用来访问原始类的field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RealObject</span></span><br><span class="line">    RobolectricBean realBean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要一个无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowRobolectricBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应原始类的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 对应原始类构造方法的传入参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">__constructor__</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        realBean.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原始对象的方法被调用的时候，Robolectric会根据方法签名查找对应的Shadow方法并调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, I ma shadow of RobolectricBean: "</span> + realBean.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> realBean.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        realBean.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shadow类中访问原始类的field"><a href="#Shadow类中访问原始类的field" class="headerlink" title="Shadow类中访问原始类的field"></a>Shadow类中访问原始类的field</h2><p>Shadow类中可以定义一个原始类的成员变量，并用@RealObject注解，这样，Shadow类就能访问原始类的field了，但是注意，通过@RealObject注解的变量调用方法，依然会调用Shadow类的方法，而不是原始类的方法，只能用它来访问原始类的field。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Implements</span>(Point.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RealObject</span> <span class="keyword">private</span> Point realPoint;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">__constructor__</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        realPoint.x = x;</span><br><span class="line">        realPoint.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在测试用例中让Shadow生效"><a href="#如何在测试用例中让Shadow生效" class="headerlink" title="如何在测试用例中让Shadow生效"></a>如何在测试用例中让Shadow生效</h2><p>在Config注解中添加<code>shadows</code>参数，指定对应的Shadow生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(shadows = ShadowRobolectricBean.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobolectricBeanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，自定义的Shadow类不能通过<code>Shadows.shadowOf()</code>获取，需要用<code>ShadowExtractor.extract()</code>来获取，获取之后进行类型转换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShadowRobolectricBean shadowBean = (ShadowRobolectricBean) ShadowExtractor.extract(bean);</span><br></pre></td></tr></table></figure><h1 id="常用测试场景"><a href="#常用测试场景" class="headerlink" title="常用测试场景"></a>常用测试场景</h1><h2 id="页面跳转验证"><a href="#页面跳转验证" class="headerlink" title="页面跳转验证"></a>页面跳转验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证点击事件是否触发了页面跳转，验证目标页面是否预期页面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJump</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 默认会调用Activity的生命周期: onCreate-&gt;onStart-&gt;onResume</span></span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    <span class="comment">// 触发按钮点击</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_jump).performClick();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的Shadow类</span></span><br><span class="line">    ShadowActivity shadowActivity = Shadows.shadowOf(activity);</span><br><span class="line">    <span class="comment">// 借助Shadow类获取启动下一Activity的Intent</span></span><br><span class="line">    Intent nextIntent = shadowActivity.getNextStartedActivity();</span><br><span class="line">    <span class="comment">// 校验Intent的正确性</span></span><br><span class="line">    assertEquals(nextIntent.getComponent().getClassName(), SecondActivity.class.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UI组件状态验证"><a href="#UI组件状态验证" class="headerlink" title="UI组件状态验证"></a>UI组件状态验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证UI组件状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckBoxState</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    CheckBox checkBox = (CheckBox) activity.findViewById(R.id.activity_main_check_box);</span><br><span class="line">    <span class="comment">// 验证CheckBox初始状态</span></span><br><span class="line">    assertFalse(checkBox.isChecked());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击按钮反转CheckBox状态</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_switch_check_box).performClick();</span><br><span class="line">    <span class="comment">// 验证状态是否正确</span></span><br><span class="line">    assertTrue(checkBox.isChecked());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击按钮反转CheckBox状态</span></span><br><span class="line">    activity.findViewById(R.id.activity_main_switch_check_box).performClick();</span><br><span class="line">    <span class="comment">// 验证状态是否正确</span></span><br><span class="line">    assertFalse(checkBox.isChecked());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Dialog"><a href="#验证Dialog" class="headerlink" title="验证Dialog"></a>验证Dialog</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证Dialog是否正确弹出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDialog</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    AlertDialog dialog = ShadowAlertDialog.getLatestAlertDialog();</span><br><span class="line">    <span class="comment">// 判断Dialog尚未弹出</span></span><br><span class="line">    assertNull(dialog);</span><br><span class="line"></span><br><span class="line">    activity.findViewById(R.id.activity_main_show_dialog).performClick();</span><br><span class="line">    dialog = ShadowAlertDialog.getLatestAlertDialog();</span><br><span class="line">    <span class="comment">// 判断Dialog已经弹出</span></span><br><span class="line">    assertNotNull(dialog);</span><br><span class="line">    <span class="comment">// 获取Shadow类进行验证</span></span><br><span class="line">    ShadowAlertDialog shadowDialog = shadowOf(dialog);</span><br><span class="line">    assertEquals(<span class="string">"AlertDialog"</span>, shadowDialog.getTitle());</span><br><span class="line">    assertEquals(<span class="string">"Oops, now you see me ~"</span>, shadowDialog.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Toast"><a href="#验证Toast" class="headerlink" title="验证Toast"></a>验证Toast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证Toast是否正确弹出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToast</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MainActivity activity = Robolectric.setupActivity(MainActivity.class);</span><br><span class="line">    Toast toast = ShadowToast.getLatestToast();</span><br><span class="line">    <span class="comment">// 判断Toast尚未弹出</span></span><br><span class="line">    assertNull(toast);</span><br><span class="line"></span><br><span class="line">    activity.findViewById(R.id.activity_main_show_toast).performClick();</span><br><span class="line">    toast = ShadowToast.getLatestToast();</span><br><span class="line">    <span class="comment">// 判断Toast已经弹出</span></span><br><span class="line">    assertNotNull(toast);</span><br><span class="line">    <span class="comment">// 获取Shadow类进行验证</span></span><br><span class="line">    ShadowToast shadowToast = shadowOf(toast);</span><br><span class="line">    assertEquals(Toast.LENGTH_SHORT, shadowToast.getDuration());</span><br><span class="line">    assertEquals(<span class="string">"oops"</span>, ShadowToast.getTextOfLatestToast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Fragment"><a href="#验证Fragment" class="headerlink" title="验证Fragment"></a>验证Fragment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragmentTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyFragment myFragment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        myFragment = <span class="keyword">new</span> MyFragment();</span><br><span class="line">        <span class="comment">// 把Fragment添加到Activity中</span></span><br><span class="line">        FragmentTestUtil.startFragment(myFragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFragment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertNotNull(myFragment.getView());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证BroadcastReceiver"><a href="#验证BroadcastReceiver" class="headerlink" title="验证BroadcastReceiver"></a>验证BroadcastReceiver</h2><p>首先看下广播接收器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广播的测试点可以包含两个方面</p><ol><li>验证应用程序是否注册了该广播</li><li>验证广播接收器的处理逻辑是否正确，关于逻辑是否正确，可以直接人为的触发onReceive()方法，让然后进行验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ShadowApplication shadowApplication = ShadowApplication.getInstance();</span><br><span class="line"></span><br><span class="line">        String action = <span class="string">"ut.cn.unittestdemo.receiver"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证是否注册了相应的Receiver</span></span><br><span class="line">        assertTrue(shadowApplication.hasReceiverForIntent(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restReceive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String action = <span class="string">"ut.cn.unittestdemo.receiver"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line">        intent.putExtra(<span class="string">"EXTRA_USERNAME"</span>, <span class="string">"HansChen"</span>);</span><br><span class="line"></span><br><span class="line">        MyReceiver myReceiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">        myReceiver.onReceive(RuntimeEnvironment.application, intent);</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证Service"><a href="#验证Service" class="headerlink" title="验证Service"></a>验证Service</h2><p>Service和Activity一样，都有生命周期，Robolectric也提供了Service的生命周期控制器，使用方式和Activity类似，这里就不做详细解释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricTestRunner.class)</span><br><span class="line"><span class="meta">@Config</span>(constants = BuildConfig.class, application = CustomApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceController&lt;TestService&gt; controller;</span><br><span class="line">    <span class="keyword">private</span> TestService                    testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        controller = Robolectric.buildService(TestService.class);</span><br><span class="line">        testService = controller.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制Service生命周期进行验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLifecycle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        controller.create();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.startCommand(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.bind();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.unbind();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line"></span><br><span class="line">        controller.destroy();</span><br><span class="line">        <span class="comment">// verify something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Android的单元测试可以分为两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Local unit tests：运行于本地JVM&lt;/li&gt;
&lt;li&gt;Instrumented test：运行于真机或者模拟器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果使用Local测试，需要保证测试过程中不会调用Android系统API，否则会抛出RuntimeException异常，因为Local测试是直接跑在本机JVM的，而之所以我们能使用Android系统API，是因为编译的时候，我们依赖了一个名为“android.jar”的jar包，但是jar包里所有方法都是直接抛出了一个RuntimeException，是没有任何任何实现的，这只是Android为了我们能通过编译提供的一个Stub！当APP运行在真实的Android系统的时候，由于类加载机制，会加载位于framework的具有真正实现的类。由于我们的Local是直接在PC上运行的，所以调用这些系统API便会出错。&lt;br&gt;那么问题来了，我们既要使用Local测试，但测试过程又难免遇到调用系统API那怎么办？其中一个方法就是mock objects，比如借助Mockito，另外一种方式就是使用&lt;code&gt;Robolectric&lt;/code&gt;， Robolectric就是为解决这个问题而生的。它实现一套JVM能运行的Android代码，然后在unit test运行的时候去截取android相关的代码调用，然后转到他们的他们实现的Shadow代码去执行这个调用的过程&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="http://blog.hanschen.site/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="单元测试" scheme="http://blog.hanschen.site/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Robolectric" scheme="http://blog.hanschen.site/tags/Robolectric/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板方法模式和策略模式</title>
    <link href="http://blog.hanschen.site/2016/12/01/design-patterns-template-and-strategy/"/>
    <id>http://blog.hanschen.site/2016/12/01/design-patterns-template-and-strategy/</id>
    <published>2016-11-30T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们知道，OOP三个基本特征是:封装、继承、多态。通过继承，我们可以基于差异编程，也就是说，对于一个满足我们大部分需求的类，可以创建它的一个子类并只改变我们不期望的那部分。但是在实际使用中，继承很容易被过度使用，并且过度使用的代价是比较高的，所以我们减少了继承的使用，使用组合或委托代替</p><blockquote><p>优先使用对象组合而不是类继承</p></blockquote><p>在本文中，我们会分别介绍<code>模板方法模式</code>和<code>策略模式</code>，这两个模式分别使用了继承和委托两种方式。这两种模式解决的问题是类似的，经常可以互换使用，它们都可以分离通用的算法和具体的上下文。比如我们有一个通用的算法，算法有不同的实现方式，为了遵循依赖倒置原则，我们希望算法不依赖于具体实现。</p><a id="more"></a><p>本文冒泡排序法来进行举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> operations = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                operations++;</span><br><span class="line">                <span class="keyword">if</span> (needSwap(array, j)) &#123;</span><br><span class="line">                    swap(array, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要交换数组中 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index] &gt; array[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换array数组中的 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们实现的冒泡排序算法，这个sort方法可以对int数组进行排序。但我们发现，这种写法的扩展性是不强的，如果我们要实现double数组排序呢？如果我们需要排序的是一个对象数组？难道需要各自定义一个方法吗？如果它们都使用冒泡排序算法，那么sort的算法逻辑肯定是相似的，有没有一种方法能让这个算法逻辑复用呢？下面用模板方法模式和策略模式对它进行改造</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>模板方法模式:定义一个算法的骨架，将骨架中的特定步骤延迟到子类中。模板方法模式使得子类可以不改变算法的结构即可重新定义该算法的某些特定步骤</p></blockquote><p>下图是用模板方法模式对冒泡排序重构后的结构图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-29-33.png" alt="2019-9-2-11-29-33.png"></p><p>首先，我们在BubbleSorter的sort方法中定义算法骨架，再定义一些延迟到子类中的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(T array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        setArray(array);</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> operations = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                operations++;</span><br><span class="line">                <span class="keyword">if</span> (needSwap(j)) &#123;</span><br><span class="line">                    swap(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(T array)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要交换数组中 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换array数组中的 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>BubbleSorter</code>类，我们就可以创建任意不同类型的对象排序的简单派生类，比如创建<code>IntBubbleSorter</code>去排序整型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class IntBubbleSorter extends BubbleSorter&lt;int[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如创建<code>DoubleBubbleSorter</code>去排序双精度型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleBubbleSorter extends BubbleSorter&lt;double[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">double</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至我们<strong>不仅限于对数组</strong>排序，还可以对List集合排序，比如创建<code>IntegerListBubbleSorter</code>对List集合进行冒泡排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerListBubbleSorter</span> <span class="keyword">extends</span> <span class="title">BubbleSorter</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list == <span class="keyword">null</span> ? <span class="number">0</span> : list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list != <span class="keyword">null</span> &amp;&amp; (list.get(index) &gt; list.get(index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = list.get(index);</span><br><span class="line">        list.set(index, list.get(index + <span class="number">1</span>));</span><br><span class="line">        list.set(index + <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义上述类之后，我们看下怎么使用上面的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//对整型数组排序</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> operations = <span class="keyword">new</span> IntBubbleSorter().sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">"[Template Method] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(intArray));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对double数组排序</span></span><br><span class="line">        <span class="keyword">double</span>[] doubleArray = &#123;<span class="number">9.9</span>, <span class="number">8.8</span>, <span class="number">7.7</span>, <span class="number">6.6</span>, <span class="number">5.5</span>, <span class="number">4.4</span>, <span class="number">3.3</span>, <span class="number">2.2</span>, <span class="number">1.1</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">        operations = <span class="keyword">new</span> DoubleBubbleSorter().sort(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"[Template Method] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(doubleArray));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对List集合排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        operations = <span class="keyword">new</span> IntegerListBubbleSorter().sort(list);</span><br><span class="line">        System.out.println(<span class="string">"[Template Method] operations:"</span> + operations + <span class="string">", list:"</span> + list.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法模式展示了经典重用的一种形式，通用算法被放在基类中，通过继承在不同的子类中实现该通用算法。我们通过定义通用类BubbleSorter，把冒泡排序的算法骨架放在基类，然后实现不同的子类分别对int数组、double数组、List集合进行排序。但这样是有代价的，因为继承是非常强的关系，派生类不可避免地与基类绑定在一起了。但如果我现在需要用快速排序而不是冒泡排序来进行排序，但快速排序却没有办法重用<code>setArray</code>、<code>getLength</code>、<code>needSwap</code>和<code>swap</code>方法了。不过，策略模式提供了另一种可选的方案</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换，下面用策略模式对冒泡排序进行重构</p><p>下图是用策略模式对冒泡排序重构后的结构图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-35-32.png" alt="2019-9-2-11-35-32.png"></p><p>首先定义一个BubbleSorter类，它持有一个抽象策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象策略接口，可以有不同的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SortHandler&lt;T&gt; sortHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BubbleSorter</span><span class="params">(SortHandler&lt;T&gt; sortHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortHandler = sortHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(T array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sortHandler.setArray(array);</span><br><span class="line">        <span class="keyword">int</span> length = sortHandler.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> operations = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                operations++;</span><br><span class="line">                <span class="keyword">if</span> (sortHandler.needSwap(j)) &#123;</span><br><span class="line">                    sortHandler.swap(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(T array)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否需要交换数组中 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换array数组中的 index 和 index+1 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建具体的策略类<code>IntSortHandler</code>对整型数组进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class IntSortHandler implements SortHandler&lt;int[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建具体的策略类<code>DoubleSortHandler</code>对双精度型数组进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleSortHandler implements SortHandler&lt;double[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">double</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array == <span class="keyword">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array != <span class="keyword">null</span> &amp;&amp; (array[index] &gt; array[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = array[index];</span><br><span class="line">        array[index] = array[index + <span class="number">1</span>];</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建具体的策略类<code>IntegerListSortHandler</code>对List集合进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerListSortHandler</span> <span class="keyword">implements</span> <span class="title">SortHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list == <span class="keyword">null</span> ? <span class="number">0</span> : list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needSwap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list != <span class="keyword">null</span> &amp;&amp; (list.get(index) &gt; list.get(index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = list.get(index);</span><br><span class="line">        list.set(index, list.get(index + <span class="number">1</span>));</span><br><span class="line">        list.set(index + <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义上述类之后，我们看下怎么使用策略模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对整型数组排序</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        BubbleSorter&lt;<span class="keyword">int</span>[]&gt; intBubbleSorter = <span class="keyword">new</span> BubbleSorter&lt;&gt;(<span class="keyword">new</span> IntSortHandler());</span><br><span class="line">        <span class="keyword">int</span> operations = intBubbleSorter.sort(intArray);</span><br><span class="line">        System.out.println(<span class="string">"[Strategy] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(intArray));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对double数组排序</span></span><br><span class="line">        <span class="keyword">double</span>[] doubleArray = &#123;<span class="number">9.9</span>, <span class="number">8.8</span>, <span class="number">7.7</span>, <span class="number">6.6</span>, <span class="number">5.5</span>, <span class="number">4.4</span>, <span class="number">3.3</span>, <span class="number">2.2</span>, <span class="number">1.1</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">        BubbleSorter&lt;<span class="keyword">double</span>[]&gt; doubleBubbleSorter = <span class="keyword">new</span> BubbleSorter&lt;&gt;(<span class="keyword">new</span> DoubleSortHandler());</span><br><span class="line">        operations = doubleBubbleSorter.sort(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"[Strategy] operations:"</span> + operations + <span class="string">", array:"</span> + Arrays.toString(doubleArray));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对List集合排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        BubbleSorter&lt;List&lt;Integer&gt;&gt; integerListBubbleSorter = <span class="keyword">new</span> BubbleSorter&lt;&gt;(<span class="keyword">new</span> IntegerListSortHandler());</span><br><span class="line">        operations = integerListBubbleSorter.sort(list);</span><br><span class="line">        System.out.println(<span class="string">"[Strategy] operations:"</span> + operations + <span class="string">", list:"</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略模式不是将通用方法放到基类中，而是把它放进<code>BubbleSorter</code>的sort方法中，把排序算法中必须调用的抽象方法定义在<code>SortHandler</code>接口中，从这个接口中派生出不同的子类。把派生出的子类传给BubbleSorter后，sort方法就可以把具体工作委托给接口去完成。注意：SortHandler对BubbleSorter是一无所知的，它不依赖于冒泡排序的具体实现，这个和模板方法模式是不同的。如果其他排序算法也需要用到SortHandler，完全也可以在相关的排序算法中使用SortHandler</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模板方法模式和策略模式都可以用来分离高层的算法和低层的具体实现细节，都允许高层的算法独立于它的具体实现细节重用。但策略模式还有一个额外的好处就是允许具体实现细节独立于高层的算法重用，但这也以一些额外的复杂性、内存以及运行事件开销作为代价</p><p><a href="https://github.com/shensky711/awesome-demo/tree/master/Patterns" target="_blank" rel="noopener">文中示例代码下载：https://github.com/shensky711/awesome-demo/tree/master/Patterns</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;我们知道，OOP三个基本特征是:封装、继承、多态。通过继承，我们可以基于差异编程，也就是说，对于一个满足我们大部分需求的类，可以创建它的一个子类并只改变我们不期望的那部分。但是在实际使用中，继承很容易被过度使用，并且过度使用的代价是比较高的，所以我们减少了继承的使用，使用组合或委托代替&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优先使用对象组合而不是类继承&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本文中，我们会分别介绍&lt;code&gt;模板方法模式&lt;/code&gt;和&lt;code&gt;策略模式&lt;/code&gt;，这两个模式分别使用了继承和委托两种方式。这两种模式解决的问题是类似的，经常可以互换使用，它们都可以分离通用的算法和具体的上下文。比如我们有一个通用的算法，算法有不同的实现方式，为了遵循依赖倒置原则，我们希望算法不依赖于具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板方法模式" scheme="http://blog.hanschen.site/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://blog.hanschen.site/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式（Factory）</title>
    <link href="http://blog.hanschen.site/2016/11/26/design-patterns-factory/"/>
    <id>http://blog.hanschen.site/2016/11/26/design-patterns-factory/</id>
    <published>2016-11-25T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>根据<code>依赖倒置原则</code>，我们知道，我们应优先依赖抽象类而不是具体类。在应用开发过程中，有很多实体类都是非常易变的，依赖它们会带来问题，所以我们更应该依赖于抽象接口，已使我们免受大多数变化的影响。<br><code>工厂模式（Factory）</code>允许我们只依赖于抽象接口就能创建出具体对象的实例，所以在开发中，如果具体类是高度易变的，那么该模式就非常有用。</p><p>接下来我们就通过代码举例说明什么是工厂模式</p><a id="more"></a><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>假设我们现在有个需求：把一段数据用Wi-Fi或者蓝牙发送出去。<br>需求很简单是吧？刷刷刷就写下了以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Wi-Fi"</span>.equals(mode)) &#123;</span><br><span class="line">        sendDataByWiFi(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sendDataByBluetooth(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDataByWiFi</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// send data via Wi-Fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDataByBluetooth</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// send data via Bluetooth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码扩展性并不高，违反了开放封闭原则。比如现在又有了个新的需求，需要用zigbee把数据发送出去，就得再新增一个sendDataByZigbee方法了，而且还得修改onClick里面的逻辑。那么比较好的方法是怎么样的呢？</p><p>定义一个数据发送器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据发送器Sender</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现WiFi数据发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sender的实现类，通过Wi-Fi发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiFiSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Send data by Wi-Fi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现蓝牙数据发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sender的实现类，通过蓝牙发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Send data by Bluetooth"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，原来发送数据的地方就改为了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Sender sender;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Wi-Fi"</span>.equals(mode)) &#123;</span><br><span class="line">        sender = <span class="keyword">new</span> WiFiSender();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sender = <span class="keyword">new</span> BluetoothSender();</span><br><span class="line">    &#125;</span><br><span class="line">    sender.sendData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有觉得代码优雅了一点？但是随着发送器Sender的实现类越来越多，每增加一个实现类，就需要在onClick里面实例化相应的实现类，能不能用一个单独的类来做这个创造实例的过程呢？这就是我们讲到的工厂。我们新增一个工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HansChen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">createSender</span><span class="params">(String mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Wi-Fi"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WiFiSender();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Bluetooth"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BluetoothSender();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal type: "</span> + mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，怎么实例化数据发送器我们也不用管了，最终代码变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Sender sender = SimpleFactory.createSender(mode);</span><br><span class="line">    sender.sendData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里我们就完成了简单工厂模式的应用了，下图就是简单工厂模式的结构图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-28-47.png" alt="2019-9-2-11-28-47.png"></p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>简单工厂模式的优点在于工厂类包含了必要的判断逻辑，根据传入的参数动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但是这里还是会有个问题，假设上面例子中新增了一个zigbee发送器，那么一定是需要修改简单工厂类的，也就是说，我们不但对扩展开放了，对修改也开放了，这是不好的。解决的方法是使用工厂方法模式，工厂方法模式是指<strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类</strong>。下面还是通过代码来说明：</p><p>在简单工厂模式的基础上，让我们对工厂类也升级一下，首先定义一个工厂类接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sender <span class="title">createSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为每一个发送器的实现类各创建一个具体的工厂方法去实现这个接口</p><p>定义WiFiSender的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiFiSenderFactory</span> <span class="keyword">implements</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WiFiSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义BluetoothSender的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothSenderFactory</span> <span class="keyword">implements</span> <span class="title">SenderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">createSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BluetoothSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使有新的Sender实现类加进来，我们只需要新增相应的工厂类就行了，不需要修改原有的工厂，下图就是工厂方法模式的结构图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-28-17.png" alt="2019-9-2-11-28-17.png"></p><p>客户端调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mode; <span class="comment">//Wi-Fi|Bluetooth</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = &#123;<span class="number">0x00</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    SenderFactory factory;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Wi-Fi"</span>.equals(mode)) &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> WiFiSenderFactory();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> BluetoothSenderFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    Sender sender = factory.createSender();</span><br><span class="line">    sender.sendData(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者可能已经发现了，工厂方法模式实现时，客户端需要决定实例化哪一个工厂类，相比于简单工厂模式，客户端多了一个选择判断的问题，也就是说，<strong>工厂方法模式把简单工厂模式的内部逻辑判断移到了客户端！</strong>你想要加功能，本来是修改简单工厂类的，现在改为修改客户端。但是这样带来的好处是整个工厂和产品体系都没有“修改”的变化，只有“扩展”的变化，完全符合了开放封闭原则。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单工厂模式和工厂方法模式都封装了对象的创建，它们使得高层策略模块在创建类的实例时无需依赖于这些类的具体实现。但是两种工厂模式之间又有差异：</p><ul><li>简单工厂模式：最大的优点在于工厂类包含了必要的判断逻辑，根据客户端的条件动态地实例化相关的类。但这也是它的缺点，当扩展功能的时候，需要修改工厂方法，违反了开放封闭原则</li><li>工厂方法模式：符合开放封闭原则，但这带来的代价是扩展的时候要增加相应的工厂类，增加了开发量，而且需要修改客户端代码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;根据&lt;code&gt;依赖倒置原则&lt;/code&gt;，我们知道，我们应优先依赖抽象类而不是具体类。在应用开发过程中，有很多实体类都是非常易变的，依赖它们会带来问题，所以我们更应该依赖于抽象接口，已使我们免受大多数变化的影响。&lt;br&gt;&lt;code&gt;工厂模式（Factory）&lt;/code&gt;允许我们只依赖于抽象接口就能创建出具体对象的实例，所以在开发中，如果具体类是高度易变的，那么该模式就非常有用。&lt;/p&gt;
&lt;p&gt;接下来我们就通过代码举例说明什么是工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blog.hanschen.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://blog.hanschen.site/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Factory" scheme="http://blog.hanschen.site/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>Fragment源码分析</title>
    <link href="http://blog.hanschen.site/2016/11/15/fragment/"/>
    <id>http://blog.hanschen.site/2016/11/15/fragment/</id>
    <published>2016-11-14T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>Fragment</code>表示 Activity 中的行为或用户界面部分。您可以将多个 Fragment 组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个 Fragment。您可以将 Fragment 视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除 Fragment。<br>Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有 Fragment 也会暂停；当 Activity 被销毁时，所有 Fragment 也会被销毁。 不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个 Fragment，如添加或移除它们。 当您执行此类 Fragment 事务时，您也可以将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生 Fragment 事务的记录。 返回栈让用户可以通过按返回按钮撤消 Fragment 事务（后退）。</p><p>当您将 Fragment 作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且 Fragment 会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明Fragment，将其作为 <code>&lt;fragment&gt;</code> 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，利用应用代码进行插入。不过，Fragment 并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的 Fragment 用作 Activity 的不可见工作线程。</p><p>本文将通过分析源码，对 Fragment 的创建、销毁以及生命周期做一个更深入的认识。</p><p>建议读者在看这篇文章的时候，先看下<a href="http://blog.csdn.net/shensky711/article/details/53132952" target="_blank" rel="noopener">Fragment事务管理源码分析</a>，对Fragment管理类先有一个比较清楚的认识。</p><a id="more"></a><h1 id="分析入口"><a href="#分析入口" class="headerlink" title="分析入口"></a>分析入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造并显示Fragment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containerViewId 容器控件id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clz             Fragment类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(@IdRes <span class="keyword">int</span> containerViewId, Class&lt;? extends Fragment&gt; clz)</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = getFragmentManager();</span><br><span class="line">    FragmentTransaction ft = fm.beginTransaction();<span class="comment">//开始事务管理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Fragment f = clz.newInstance();</span><br><span class="line">        ft.add(containerViewId, f, clz.getName());<span class="comment">//添加操作</span></span><br><span class="line">        ft.commit();<span class="comment">//提交事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是动态地往<code>containerViewId</code>里添加一个Fragment并让它显示出来，可以看到，这个涉及到Fragment的事务管理，详细可以参考<a href="http://blog.csdn.net/shensky711/article/details/53132952" target="_blank" rel="noopener">Fragment事务管理源码分析</a>，这里就不再阐述了。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="BackStackRecord-run"><a href="#BackStackRecord-run" class="headerlink" title="BackStackRecord#run"></a>BackStackRecord#run</h2><p>调用了commit之后，真正执行的地方是在BackStackRecord的run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mManager.mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        calculateFragments(firstOutFragments, lastInFragments);</span><br><span class="line">        beginTransition(firstOutFragments, lastInFragments, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表，根据cmd事务类型依次处理事务</span></span><br><span class="line">    Op op = mHead;</span><br><span class="line">    <span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">                <span class="comment">//添加一个新的Fragment</span></span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REPLACE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                <span class="keyword">int</span> containerId = f.mContainerId;</span><br><span class="line">                <span class="keyword">if</span> (mManager.mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = mManager.mAdded.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        Fragment old = mManager.mAdded.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (old.mContainerId == containerId) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (old == f) &#123;</span><br><span class="line">                                op.fragment = f = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (op.removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    op.removed = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">                                &#125;</span><br><span class="line">                                op.removed.add(old);</span><br><span class="line">                                old.mNextAnim = op.exitAnim;</span><br><span class="line">                                <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">                                    old.mBackStackNesting += <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mManager.removeFragment(old, mTransition, mTransitionStyle);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f.mNextAnim = op.enterAnim;</span><br><span class="line">                    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.removeFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.hideFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.showFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.detachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.attachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        op = op.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">            mTransitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们调用的是add操作，所以执行的代码片段是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">    Fragment f = op.fragment;</span><br><span class="line">    f.mNextAnim = op.enterAnim;</span><br><span class="line">    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>op.fragment：showFragment中创建的Fragment实例，并且现在Fragment的mTag、mFragmentId、mContainerId已被初始化过了</li><li>op.enterAnim:入场动画，可以先不管</li><li>mManager：FragmentManagerImpl实例</li></ul><h2 id="FragmentManagerImpl-addFragment"><a href="#FragmentManagerImpl-addFragment" class="headerlink" title="FragmentManagerImpl#addFragment"></a>FragmentManagerImpl#addFragment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment, <span class="keyword">boolean</span> moveToStateNow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已添加的Fragment列表</span></span><br><span class="line">    <span class="keyword">if</span> (mAdded == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdded = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Fragment的mIndex，并把Fragment添加到mActive列表</span></span><br><span class="line">    makeActive(fragment);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否被detach。默认为false</span></span><br><span class="line">    <span class="keyword">if</span> (!fragment.mDetached) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment already added: "</span> + fragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把Fragment添加到mAdded列表</span></span><br><span class="line">        mAdded.add(fragment);</span><br><span class="line">        <span class="comment">//设置Fragment标记位</span></span><br><span class="line">        fragment.mAdded = <span class="keyword">true</span>;</span><br><span class="line">        fragment.mRemoving = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断是否需要刷新菜单</span></span><br><span class="line">        <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</span><br><span class="line">            mNeedMenuInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这次分析中moveToStateNow为false，moveToState方法在本方法外层方法中调用</span></span><br><span class="line">        <span class="keyword">if</span> (moveToStateNow) &#123;</span><br><span class="line">            moveToState(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addFragment里面把Fragment加入mActive和mAdded列表，并且设置标记为<code>fragment.mAdded</code>为true，<code>fragment.mRemoving</code>为false。<br>执行完ADD操作后，执行moveToState，moveToState顾名思义，就是把Fragment变为某种状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mManager.mCurState的状态很重要，我们下面会分析它现在处于什么状态</span></span><br><span class="line">mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">        mTransitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加本次操作到回退栈中</span></span><br><span class="line"><span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">    mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment状态"><a href="#Fragment状态" class="headerlink" title="Fragment状态"></a>Fragment状态</h2><p>我们知道Fragment的生命周期是依赖于Activity的，比如Activity处于onResume,那么Fragment也会处于onResume状态，这里的参数mManager.mCurState对应的状态有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_STATE = -<span class="number">1</span>;   <span class="comment">// Invalid state used as a null value.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = <span class="number">0</span>;     <span class="comment">// Not yet created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// The activity has finished its creation.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOPPED = <span class="number">3</span>;          <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">4</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">5</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure><p>mCurState的初始状态是Fragment.INITIALIZING，那么在BackStackRecord中调用moveToState的时候，mCurState是什么值呢？它是会受Activity生命周期影响而变化的，我们来看下<code>FragmentActivity</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定FragmentManager</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分发Fragment的create事件</span></span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHost.mFragmentManager.dispatchCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mStateSaved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//注意这里设置了新的state</span></span><br><span class="line">    moveToState(Fragment.CREATED, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    moveToState(newState, <span class="number">0</span>, <span class="number">0</span>, always);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitStyle, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">//给mCurState赋值</span></span><br><span class="line">    mCurState = newState;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onCreate中把mCurState变为<code>Fragment.CREATED</code>状态了，Activity的其他生命周期方法回调的时候，也会改变这个状态，大致整理如下：</p><ul><li>onCreate：Fragment.CREATED</li><li>onStart：Fragment.ACTIVITY_CREATED–&gt;Fragment.STARTED (Fragment.ACTIVITY_CREATED只会在Activity创建之后触发一次，Fragment.STARTED每次onStart的时候都会触发)</li><li>onResume：Fragment.RESUMED</li><li>onPause：Fragment.STARTED</li><li>onStop：Fragment.STOPPED</li><li>onDestroy：Fragment.INITIALIZING</li></ul><p>下面是一张状态迁移图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-22-55.png" alt="2019-9-2-11-22-55.png"></p><p>所以随着Activity生命周期的推进，Activity内所有Fragment的生命周期也会跟着推进。<strong>从Activity创建到显示出来，最后会处于onResume状态，那么我们这次就直接分析当前Activity处于onResume调用之后的情形好了。所以假定现在mCurState为Fragment.RESUMED</strong>，</p><p>让我们继续跟踪FragmentManagerImpl</p><h2 id="FragmentManagerImpl-moveToState"><a href="#FragmentManagerImpl-moveToState" class="headerlink" title="FragmentManagerImpl#moveToState"></a>FragmentManagerImpl#moveToState</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitStyle, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHost == <span class="keyword">null</span> &amp;&amp; newState != Fragment.INITIALIZING) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No activity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!always &amp;&amp; mCurState == newState) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurState = newState;</span><br><span class="line">    <span class="keyword">if</span> (mActive != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> loadersRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//遍历所有Active状态的Fragment，改变所有Fragment的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">            Fragment f = mActive.get(i);</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//关键代码</span></span><br><span class="line">                moveToState(f, newState, transit, transitStyle, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (f.mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!loadersRunning) &#123;</span><br><span class="line">            startPendingDeferredFragments();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让Activity刷新Menu</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedMenuInvalidate &amp;&amp; mHost != <span class="keyword">null</span> &amp;&amp; mCurState == Fragment.RESUMED) &#123;</span><br><span class="line">            mHost.onInvalidateOptionsMenu();</span><br><span class="line">            mNeedMenuInvalidate = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置最新的mCurState状态，通过上面的分析，我们知道newState等于Fragment.RESUMED。遍历mActive列表中保存的Fragment，改变Fragment状态，这里又调用了一个<code>moveToState</code>方法，这个方法就是真正回调Fragment生命周期的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> keepActive)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fragments被detach或Fragment没有添加到mAdded列表的话，设置目标Fragment的新状态为CREATED状态，此次分析中不会进入这个分支</span></span><br><span class="line">    <span class="keyword">if</span> ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">        newState = Fragment.CREATED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此次分析中f.mRemoving为false</span></span><br><span class="line">    <span class="keyword">if</span> (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</span><br><span class="line">        <span class="comment">// While removing a fragment, we can't change it to a higher state.</span></span><br><span class="line">        newState = f.mState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否延时启动</span></span><br><span class="line">    <span class="keyword">if</span> (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        newState = Fragment.STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt; newState) &#123;</span><br><span class="line">        <span class="comment">//此次命中的分支</span></span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据Fragment当前的状态，选择case的分支。需要注意的是，这里的switch case是没有break语句的。这种设计可以让Fragment把自身的状态依次推进到目标状态</span></span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">                <span class="keyword">if</span> (f.mSavedFragmentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                f.mHost = mHost;</span><br><span class="line">                <span class="comment">//mParent是在FragmentActivity的onCreate方法中调用attachHost传进来的，传进来的是空值</span></span><br><span class="line">                f.mParentFragment = mParent;</span><br><span class="line">                f.mFragmentManager = mParent != <span class="keyword">null</span></span><br><span class="line">                        ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();</span><br><span class="line">                f.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//【Fragment生命周期】onAttach回调，里面会把mCalled设置为true</span></span><br><span class="line">                f.onAttach(mHost.getContext());</span><br><span class="line">                <span class="keyword">if</span> (!f.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + f</span><br><span class="line">                            + <span class="string">" did not call through to super.onAttach()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (f.mParentFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//让Activity可以监听到Fragment的attach</span></span><br><span class="line">                    mHost.onAttachFragment(f);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.mParentFragment.onAttachFragment(f);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//f.mRetaining默认为false</span></span><br><span class="line">                <span class="keyword">if</span> (!f.mRetaining) &#123;</span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onCreate</span></span><br><span class="line">                    f.performCreate(f.mSavedFragmentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.restoreChildFragmentState(f.mSavedFragmentState, <span class="keyword">true</span>);</span><br><span class="line">                    f.mState = Fragment.CREATED;</span><br><span class="line">                &#125;</span><br><span class="line">                f.mRetaining = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//Fragment是否定义在Layout文件的&lt;fragment&gt;标签中的，本次栗子为代码动态添加Fragment，所以为false</span></span><br><span class="line">                <span class="keyword">if</span> (f.mFromLayout) &#123;</span><br><span class="line">                    <span class="comment">// For fragments that are part of the content view</span></span><br><span class="line">                    <span class="comment">// layout, we need to instantiate the view immediately</span></span><br><span class="line">                    <span class="comment">// and the inflater will take care of adding it.</span></span><br><span class="line">                    f.mView = f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                            f.mSavedFragmentState), <span class="keyword">null</span>, f.mSavedFragmentState);</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        f.mView.setSaveFromParentEnabled(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">if</span> (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                        f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意，这里没有break</span></span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!f.mFromLayout) &#123;</span><br><span class="line">                        <span class="comment">//开始创建Fragment的view</span></span><br><span class="line">                        ViewGroup container = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (f.mContainerId != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (f.mContainerId == View.NO_ID) &#123;</span><br><span class="line">                                throwException(<span class="keyword">new</span> IllegalArgumentException(<span class="string">""</span>));</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//调用Activity的findViewById方法查找控件</span></span><br><span class="line">                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</span><br><span class="line">                            <span class="keyword">if</span> (container == <span class="keyword">null</span> &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">                                ......</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mContainer = container;</span><br><span class="line">                        <span class="comment">//关键代码，内部会调用【Fragment生命周期】onCreateView，并返回Fragment中new出的视图</span></span><br><span class="line">                        f.mView = f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                                f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">                        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            f.mView.setSaveFromParentEnabled(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//设置入场动画</span></span><br><span class="line">                                Animator anim = loadAnimator(f, transit, <span class="keyword">true</span>,</span><br><span class="line">                                        transitionStyle);</span><br><span class="line">                                <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    anim.setTarget(f.mView);</span><br><span class="line">                                    setHWLayerAnimListenerIfAlpha(f.mView, anim);</span><br><span class="line">                                    anim.start();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//把Fragment的view加入到父控件</span></span><br><span class="line">                                container.addView(f.mView);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//【Fragment生命周期】onViewCreated回调</span></span><br><span class="line">                            f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onActivityCreated</span></span><br><span class="line">                    f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mSavedFragmentState = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    f.mState = Fragment.STOPPED;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.STOPPED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto STARTED: "</span> + f);</span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onStart</span></span><br><span class="line">                    f.performStart();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                    <span class="comment">//关键代码，内部会调用【Fragment生命周期】onResume</span></span><br><span class="line">                    f.performResume();</span><br><span class="line">                    <span class="comment">// Get rid of this in case we saved it and never needed it.</span></span><br><span class="line">                    f.mSavedFragmentState = <span class="keyword">null</span>;</span><br><span class="line">                    f.mSavedViewState = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">        <span class="comment">//state降级处理</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (f.mState != newState) &#123;</span><br><span class="line">        f.mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑还是比较长，我把注释写在代码里了。可以看到，这个代码写得很巧妙，通过switch case控制，可以一层一层地把Fragment的生命周期推进下去，比如当前fragnemt的state是<code>Fragment.STARTED</code>，那么它就只会执行performResume，如果Fragment的状态是<code>Fragment.INITIALIZING</code>，那么就会从switch的最开始依次执行下来，把Fragment的生命周期onAttach–&gt;onResume依次调用。<br>简要说明下上面的代码：</p><ul><li>mHost是FragmentHostCallback抽象类的实例，它的实现类是Activity的HostCallbacks</li><li>mParent为null</li><li>mHost.getContext()获取的context就是宿主Activity实例</li><li>Fragment中创建的View会自动通过container.addView(f.mView)添加到父控件中</li></ul><p>很多Fragment的生命周期是通过Fragment的performXxx()方法去调用的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">performCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onActivityCreated(savedInstanceState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onStart();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    onResume();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment状态的降级操作"><a href="#Fragment状态的降级操作" class="headerlink" title="Fragment状态的降级操作"></a>Fragment状态的降级操作</h2><p>有些童鞋们可能会有疑问，上面只分析到了onAttach-&gt;onResume生命周期的回调，那onPause、onDestroy等方法又是什么时候执行的呢？我们再看下刚才的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f.mState &lt; newState) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">    <span class="comment">//state降级处理</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案就是在else if分支里面，比如当Acivity锁屏的时候，就Activity生命周期会自动回调onPause，从而触发dispatchPause，在里面调用moveToState(Fragment.STARTED, false);<br>由于Fragment当前的状态是RESUMED状态，大于newState，所以就会走else if的分支，触发相应的生命周期方法。else if分支的逻辑和state升级的差不多，这里就再进行分析了</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-26-16.png" alt="2019-9-2-11-26-16.png"><br>最后，放张官网上公布的Fragment生命周期图，通过代码分析，我们发现代码的中生命周期的调用顺序和图中确实是一致的</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大致地从源码的角度分析了Fragment创建、生命周期回调的过程，如果读者对Fragment的<code>remove</code>、<code>replace</code>、<code>hide</code>、<code>detach</code>、<code>attach</code>等操作有兴趣的话，可以自行分析，核心代码主要在BackStackRecord类的run方法以及FragmentManagerImpl的moveToState方法中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Fragment&lt;/code&gt;表示 Activity 中的行为或用户界面部分。您可以将多个 Fragment 组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个 Fragment。您可以将 Fragment 视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除 Fragment。&lt;br&gt;Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有 Fragment 也会暂停；当 Activity 被销毁时，所有 Fragment 也会被销毁。 不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个 Fragment，如添加或移除它们。 当您执行此类 Fragment 事务时，您也可以将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生 Fragment 事务的记录。 返回栈让用户可以通过按返回按钮撤消 Fragment 事务（后退）。&lt;/p&gt;
&lt;p&gt;当您将 Fragment 作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且 Fragment 会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明Fragment，将其作为 &lt;code&gt;&amp;lt;fragment&amp;gt;&lt;/code&gt; 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，利用应用代码进行插入。不过，Fragment 并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的 Fragment 用作 Activity 的不可见工作线程。&lt;/p&gt;
&lt;p&gt;本文将通过分析源码，对 Fragment 的创建、销毁以及生命周期做一个更深入的认识。&lt;/p&gt;
&lt;p&gt;建议读者在看这篇文章的时候，先看下&lt;a href=&quot;http://blog.csdn.net/shensky711/article/details/53132952&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fragment事务管理源码分析&lt;/a&gt;，对Fragment管理类先有一个比较清楚的认识。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Fragment" scheme="http://blog.hanschen.site/tags/Fragment/"/>
    
      <category term="源码分析" scheme="http://blog.hanschen.site/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Fragment事务管理源码分析</title>
    <link href="http://blog.hanschen.site/2016/11/11/fragment-transaction/"/>
    <id>http://blog.hanschen.site/2016/11/11/fragment-transaction/</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Fragment使用中，有时候需要对Fragment进行<code>add</code>、<code>remove</code>、<code>show</code>、<code>hide</code>、<code>replace</code>等操作来进行Fragment的显示隐藏等管理，这些管理是通过<code>FragmentTransaction</code>进行事务管理的。事务管理是对于一系列操作进行管理，一个事务包含一个或多个操作命令，是逻辑管理的工作单元。一个事务开始于第一次执行操作语句，结束于Commit。通俗地将，就是把多个操作缓存起来，等调用commit的时候，统一批处理。下面会对Fragmeng的事务管理做一个代码分析</p><a id="more"></a><h1 id="分析入口"><a href="#分析入口" class="headerlink" title="分析入口"></a>分析入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示Fragment，如果Fragment已添加过，则直接show，否则构造一个Fragment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> containerViewId 容器控件id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clz             Fragment类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(@IdRes <span class="keyword">int</span> containerViewId, Class&lt;? extends Fragment&gt; clz)</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = getFragmentManager();</span><br><span class="line">    FragmentTransaction ft = fm.beginTransaction();<span class="comment">//开始事务管理</span></span><br><span class="line">    Fragment f;</span><br><span class="line">    <span class="keyword">if</span> ((f = fm.findFragmentByTag(clz.getName())) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f = clz.newInstance();</span><br><span class="line">            ft.add(containerViewId, f, clz.getName());<span class="comment">//添加操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ft.show(f);<span class="comment">//添加操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    ft.commit();<span class="comment">//提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个简单的显示Fragment的栗子，简单判断一下Fragment是否已添加过，添加过就直接show，否则构造一个Fragment，最后提交事务。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="FragmentManager"><a href="#FragmentManager" class="headerlink" title="FragmentManager"></a>FragmentManager</h2><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-19-20.png" alt="2019-9-2-11-19-20.png"><br>上图是获取FragmentManager的大体过程</p><p>要管理Fragment事务，首先是需要拿到FragmentManager，在Activity中可以通过<code>getFragmentManager()</code>方法获取(使用兼容包的话，通过<code>FragmentActivity#getSupportFragmentManager()</code>)，在这里我们就不对兼容包进行分析了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the FragmentManager for interacting with fragments associated</span></span><br><span class="line"><span class="comment"> * with this activity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentManager <span class="title">getFragmentManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragments.getFragmentManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FragmentManager是一个抽象类，它是通过mFragments.getFragmentManager()来获取的，mFragments是FragmentController对象，它通过<code>FragmentController.createController(new HostCallbacks())</code>生成，这是一个静态工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FragmentController <span class="title">createController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FragmentController(callbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面直接new了一个FragmentController对象，注意FragmentController的构造方法需要传入一个<code>FragmentHostCallback</code></p><h2 id="FragmentController构造方法"><a href="#FragmentController构造方法" class="headerlink" title="FragmentController构造方法"></a>FragmentController构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FragmentHostCallback&lt;?&gt; mHost;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">FragmentController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</span><br><span class="line">    mHost = callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法很简单，传入了一个FragmentHostCallback实例</p><h2 id="FragmentController-getFragmentManager"><a href="#FragmentController-getFragmentManager" class="headerlink" title="FragmentController#getFragmentManager"></a>FragmentController#getFragmentManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentManager <span class="title">getFragmentManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mHost.getFragmentManagerImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用了mHost的getFragmentManagerImpl方法，希望童鞋们没有被绕晕，mHost是一个FragmentHostCallback实例，那我们回过头来看看它传进来的地方</p><h2 id="FragmentHostCallback"><a href="#FragmentHostCallback" class="headerlink" title="FragmentHostCallback"></a>FragmentHostCallback</h2><p>这个FragmentHostCallback是一个抽象类，我们可以看到，在Activity中是传入了 <code>Activity#HostCallbacks</code>内部类，这个就是FragmentHostCallback的实现类</p><h2 id="FragmentHostCallback-getFragmentManagerImpl"><a href="#FragmentHostCallback-getFragmentManagerImpl" class="headerlink" title="FragmentHostCallback#getFragmentManagerImpl"></a>FragmentHostCallback#getFragmentManagerImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FragmentManagerImpl mFragmentManager = <span class="keyword">new</span> FragmentManagerImpl();</span><br><span class="line"><span class="function">FragmentManagerImpl <span class="title">getFragmentManagerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragmentManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于找到FragmentManager的真身<code>FragmentManagerImpl</code>了</p><h2 id="FragmentManagerImpl-beginTransaction"><a href="#FragmentManagerImpl-beginTransaction" class="headerlink" title="FragmentManagerImpl#beginTransaction"></a>FragmentManagerImpl#beginTransaction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BackStackRecord(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，所谓的FragmentTransaction其实就是一个BackStackRecord。到现在，FragmentManager和FragmentTransaction我们都找到了。下图就是各个类之间的关系：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-20-42.png" alt="2019-9-2-11-20-42.png"></p><p>下面开始真正的事务管理分析，我们先选择一个事务add来进行分析</p><h2 id="FragmentTransaction-add"><a href="#FragmentTransaction-add" class="headerlink" title="FragmentTransaction#add"></a>FragmentTransaction#add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">    doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fragment的FragmentManagerImpl，mManager其实就是Activity#HostCallbacks中的成员变量</span></span><br><span class="line">    fragment.mFragmentManager = mManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fragment的tag</span></span><br><span class="line">    <span class="keyword">if</span> (tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mTag != <span class="keyword">null</span> &amp;&amp; !tag.equals(fragment.mTag)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mTag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containerViewId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (containerViewId == View.NO_ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mFragmentId != <span class="number">0</span> &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置fragment的mContainerId以及mFragmentId</span></span><br><span class="line">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增一个操作</span></span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到链表的最后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    op.enterAnim = mEnterAnim;</span><br><span class="line">    op.exitAnim = mExitAnim;</span><br><span class="line">    op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">    op.popExitAnim = mPopExitAnim;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add的操作步骤为：</p><ol><li>设置fragment的FragmentManagerImpl</li><li>设置fragment的tag</li><li>设置fragment的mContainerId以及mFragmentId</li><li>插入一个类型为OP_ADD的操作到链表最后</li></ol><p>这里用到了一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">    Op next;<span class="comment">//下一操作节点</span></span><br><span class="line">    Op prev;<span class="comment">//上一操作节点</span></span><br><span class="line">    <span class="keyword">int</span> cmd;<span class="comment">//操作类型，可选有：OP_NULL|OP_ADD|OP_REPLACE|OP_REMOVE|OP_HIDE|OP_SHOW|OP_DETACH|OP_ATTACH</span></span><br><span class="line">    Fragment fragment;<span class="comment">//操作的Fragment对象</span></span><br><span class="line">    <span class="keyword">int</span> enterAnim;<span class="comment">//入场动画</span></span><br><span class="line">    <span class="keyword">int</span> exitAnim;<span class="comment">//出场动画</span></span><br><span class="line">    <span class="keyword">int</span> popEnterAnim;<span class="comment">//弹入动画</span></span><br><span class="line">    <span class="keyword">int</span> popExitAnim;<span class="comment">//弹出动画</span></span><br><span class="line">    ArrayList&lt;Fragment&gt; removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个操作链表节点。所有add、remove、hide等事物最终会形成一个操作链</p><h2 id="FragmentTransaction-commit"><a href="#FragmentTransaction-commit" class="headerlink" title="FragmentTransaction#commit"></a>FragmentTransaction#commit</h2><p>等所有操作都插入后，最后我们需要调用FragmentTransaction的commit方法，操作才会真正地执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commitInternal(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//防止重复commit</span></span><br><span class="line">    <span class="keyword">if</span> (mCommitted) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DEBUG代码统统不管</span></span><br><span class="line">    <span class="keyword">if</span> (FragmentManagerImpl.DEBUG) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">"Commit: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        LogWriter logw = <span class="keyword">new</span> LogWriter(Log.VERBOSE, TAG);</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> FastPrintWriter(logw, <span class="keyword">false</span>, <span class="number">1024</span>);</span><br><span class="line">        dump(<span class="string">"  "</span>, <span class="keyword">null</span>, pw, <span class="keyword">null</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mCommitted = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有调用了addToBackStack方法之后，这个标记才会为true</span></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入事物队列</span></span><br><span class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);</span><br><span class="line">    <span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FragmentManagerImpl-enqueueAction"><a href="#FragmentManagerImpl-enqueueAction" class="headerlink" title="FragmentManagerImpl#enqueueAction"></a>FragmentManagerImpl#enqueueAction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds an action to the queue of pending actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action the action to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowStateLoss whether to allow loss of state information</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the activity has been destroyed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!allowStateLoss) &#123;</span><br><span class="line">        checkStateLoss();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDestroyed || mHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Activity has been destroyed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingActions.add(action);</span><br><span class="line">        <span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">            mHost.getHandler().post(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把操作添加到<code>mPendingActions</code>列表里去。并通过mHost.getHandler()获取Handler发送执行请求。从上面的分析知道，mHost就是Activity的HostCallbacks，构造方法中把Activity的mHandler传进去了，这里执行的<code>mHost.getHandler()</code>获取到的也就是Activity中的mHandler，这样做是因为需要在主线程中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br></pre></td></tr></table></figure><p>再看看mExecCommit中做了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Runnable mExecCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Only call from main thread!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execPendingActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExecutingActions) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive entry to executePendingTransactions"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再次检测是否主线程</span></span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() != mHost.getHandler().getLooper()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Must be called from main thread of process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numActions;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//参数检测</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span> || mPendingActions.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            numActions = mPendingActions.size();</span><br><span class="line">            <span class="keyword">if</span> (mTmpActions == <span class="keyword">null</span> || mTmpActions.length &lt; numActions) &#123;</span><br><span class="line">                mTmpActions = <span class="keyword">new</span> Runnable[numActions];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mPendingActions.toArray(mTmpActions);</span><br><span class="line">            mPendingActions.clear();</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mExecutingActions = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//遍历执行待处理的事务操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numActions; i++) &#123;</span><br><span class="line">            mTmpActions[i].run();</span><br><span class="line">            mTmpActions[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutingActions = <span class="keyword">false</span>;</span><br><span class="line">        didSomething = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doPendingDeferredStart();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入了事物之后，就是在主线程中把需要处理的事务统一处理，处理事务是通过执行<code>mTmpActions[i].run()</code>进行的，这个mTmpActions[i]就是前面我们通过enqueueAction方法插入的BackStackRecord，童鞋们可能没注意到，它可是一个Runnable，我们来看看它的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = FragmentManagerImpl.TAG;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兜兜转转，我们又回到了BackStackRecord</p><h2 id="BackStackRecord-run"><a href="#BackStackRecord-run" class="headerlink" title="BackStackRecord#run"></a>BackStackRecord#run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mManager.mCurState &gt;= Fragment.CREATED) &#123;</span><br><span class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        calculateFragments(firstOutFragments, lastInFragments);</span><br><span class="line">        beginTransition(firstOutFragments, lastInFragments, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表，根据cmd事务类型依次处理事务</span></span><br><span class="line">    Op op = mHead;</span><br><span class="line">    <span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REPLACE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                <span class="keyword">int</span> containerId = f.mContainerId;</span><br><span class="line">                <span class="keyword">if</span> (mManager.mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = mManager.mAdded.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        Fragment old = mManager.mAdded.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (old.mContainerId == containerId) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (old == f) &#123;</span><br><span class="line">                                op.fragment = f = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (op.removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    op.removed = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">                                &#125;</span><br><span class="line">                                op.removed.add(old);</span><br><span class="line">                                old.mNextAnim = op.exitAnim;</span><br><span class="line">                                <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">                                    old.mBackStackNesting += <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mManager.removeFragment(old, mTransition, mTransitionStyle);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f.mNextAnim = op.enterAnim;</span><br><span class="line">                    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.removeFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.hideFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.showFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.exitAnim;</span><br><span class="line">                mManager.detachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = op.enterAnim;</span><br><span class="line">                mManager.attachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        op = op.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">            mTransitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，提交的事务就被真正执行了，我们知道，即使commit了事务之后，也不是同步执行的，是通过Handler发送到主线程执行的。</p><p>所有事务的处理都是在run方法里面执行，但是我们留意到，想要搞清楚add、remove等事务背后真正做了什么，还需要深入了解FragmentManagerImpl。</p><p>本文主要讲解Fragment事务的流程，FragmentManagerImpl的分析准备放到下一篇分析文章<a href="http://blog.csdn.net/shensky711/article/details/53171248" target="_blank" rel="noopener">Fragment源码分析</a>中，相信通过分析之后，就可以对Fragment的生命周期也有一个很好的认识了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在Fragment使用中，有时候需要对Fragment进行&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;show&lt;/code&gt;、&lt;code&gt;hide&lt;/code&gt;、&lt;code&gt;replace&lt;/code&gt;等操作来进行Fragment的显示隐藏等管理，这些管理是通过&lt;code&gt;FragmentTransaction&lt;/code&gt;进行事务管理的。事务管理是对于一系列操作进行管理，一个事务包含一个或多个操作命令，是逻辑管理的工作单元。一个事务开始于第一次执行操作语句，结束于Commit。通俗地将，就是把多个操作缓存起来，等调用commit的时候，统一批处理。下面会对Fragmeng的事务管理做一个代码分析&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Fragment" scheme="http://blog.hanschen.site/tags/Fragment/"/>
    
      <category term="事务管理" scheme="http://blog.hanschen.site/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="transaction" scheme="http://blog.hanschen.site/tags/transaction/"/>
    
      <category term="源码分析" scheme="http://blog.hanschen.site/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>java动态代理</title>
    <link href="http://blog.hanschen.site/2016/10/20/java-proxy/"/>
    <id>http://blog.hanschen.site/2016/10/20/java-proxy/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>动态代理是java的一大特性，动态代理的优势就是实现无侵入式的代码扩展。它可以增强我们原有的方法，比如常用的日志监控,添加缓存等，也可以实现方法拦截，通过代理方法修改原方法的参数和返回值等。<br>要了解动态代理，我们需要先看看什么是静态代理</p><a id="more"></a><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>首先你有一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">doSomething</span><span class="params">(String input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口有一个原始的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiImpl</span> <span class="keyword">implements</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input + <span class="string">"原始方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了，有一个新的需求，我需要在所有调用<code>doSomething</code>的地方都添加一个log，那怎么办呢？我们当然可以在原有代码上直接加上log，但是ApiImpl里面的log真的是那段代码需要的吗？如果不修改原有代码，能不能实现？当然可以，如，我们添加一个代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiProxy</span> <span class="keyword">implements</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiProxy</span><span class="params">(Api base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBase.doSomething(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过ApiProxy我们就是实现静态代理，这里只是简单的添加了log，我们完全可以在ApiProxy的doSomething方法里面，篡改输入参数input以及返回值，从而做一些坏事~</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在上面静态代理例子中，我们已经实现了代理的功能，那为何还需要动态代理呢？设想一下以下两种情况</p><ul><li>如果Api接口类中有100个方法，需要为每个方法都添加log</li><li>项目中有100个类，需要为每个类的方法都添加log</li></ul><p>对于第一种情况，如果使用静态代理，那就只能这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiProxy</span> <span class="keyword">implements</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiProxy</span><span class="params">(Api base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBase.doSomething(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething1</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBase.doSomething1(input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为每个方法添加实现......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于第二种情况，就只能新建100个代理类了。这种处理方式肯定不是我们喜欢的，怎么优雅地去解决了？动态代理这时候终于可以上场了。</p><p>JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了，比如:</p><ol><li><p>实现InvocationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApiHandler</span><span class="params">(Api base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法会在proxy实例调用方法的时候回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"someone call me~"</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader loader = Api.class.getClassLoader();<span class="comment">//加载代理类的ClassLoader</span></span><br><span class="line">    Class[] interfaces = <span class="keyword">new</span> Class[]&#123;Api.class&#125;;<span class="comment">//需要代理的接口</span></span><br><span class="line">    Api proxy = (Api) Proxy.newProxyInstance(loader, interfaces, <span class="keyword">new</span> ApiHandler(<span class="keyword">new</span> ApiImpl()));<span class="comment">//创建代理对象</span></span><br><span class="line">    proxy.doSomething(<span class="string">"test"</span>);<span class="comment">//会调用ApiHandler的invoke方法</span></span><br><span class="line">    proxy.doSomething1(<span class="string">"test"</span>);<span class="comment">//会调用ApiHandler的invoke方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样，一个动态代理就完成了，但这里有个需要注意的，动态代理只能代理接口，也就是说interfaces数组里面，只能放接口Class</p><h1 id="代理Hook"><a href="#代理Hook" class="headerlink" title="代理Hook"></a>代理Hook</h1><p>代理有比原始对象更强大的能力，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。<br>首先我们得找到被Hook的对象，也就是Hook点；什么样的对象比较适合Hook呢？<strong>静态变量和单例</strong>；在一个进程之内，静态变量和单例变量是不容易发生变化的，所以容易定位，而普通的对象则要么无法标志，要么容易改变，我们根据这个原则找到所谓的Hook点。<br>一般Hook的步骤有：</p><ol><li>寻找Hook点，如静态变量或单例对象，尽量Hook pulic的对象和方法，非public不保证每个版本都一样，需要适配。</li><li>选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib</li><li>用代理对象替换原始对象，如果没有公开是geter/setter方法，可以使用反射</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;动态代理是java的一大特性，动态代理的优势就是实现无侵入式的代码扩展。它可以增强我们原有的方法，比如常用的日志监控,添加缓存等，也可以实现方法拦截，通过代理方法修改原方法的参数和返回值等。&lt;br&gt;要了解动态代理，我们需要先看看什么是静态代理&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blog.hanschen.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://blog.hanschen.site/tags/java/"/>
    
      <category term="proxy" scheme="http://blog.hanschen.site/tags/proxy/"/>
    
      <category term="动态代理" scheme="http://blog.hanschen.site/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android分包MultiDex源码分析</title>
    <link href="http://blog.hanschen.site/2016/10/18/multidex/"/>
    <id>http://blog.hanschen.site/2016/10/18/multidex/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android开发者应该都遇到了64K最大方法数限制的问题，针对这个问题，google也推出了multidex分包机制，在生成apk的时候，把整个应用拆成n个dex包（classes.dex、classes2.dex、classes3.dex），每个dex不超过64k个方法。使用multidex，在5.0以前的系统，应用安装时只安装main dex（包含了应用启动需要的必要class），在应用启动之后，需在Application的<code>attachBaseContext</code>中调用<code>MultiDex.install(base)</code>方法，在这时候才加载第二、第三…个dex文件，从而规避了64k问题。<br>当然，在<code>attachBaseContext</code>方法中直接install启动second dex会有一些问题，比如install方法是一个同步方法，当在主线程中加载的dex太大的时候，耗时会比较长，可能会触发ANR。不过这是另外一个问题了，解决方法可以参考：<a href="http://blog.csdn.net/shensky711/article/details/52329035" target="_blank" rel="noopener">Android最大方法数和解决方案</a> <a href="http://blog.csdn.net/shensky711/article/details/52329035。" target="_blank" rel="noopener">http://blog.csdn.net/shensky711/article/details/52329035。</a></p><p>本文主要分析的是<code>MultiDex.install()</code>到底做了什么，如何把secondary dexes中的类动态加载进来。</p><a id="more"></a><h1 id="MultiDex使用到的路径解析"><a href="#MultiDex使用到的路径解析" class="headerlink" title="MultiDex使用到的路径解析"></a>MultiDex使用到的路径解析</h1><ul><li>ApplicationInfo.sourceDir:apk的安装路径，如/data/app/com.hanschen.multidex-1.apk</li><li>Context.getFilesDir()：返回<code>/data/data/&lt;packagename&gt;/files</code>目录，一般通过openFileOutput方法输出文件到该目录</li><li>ApplicationInfo.dataDir: 返回<code>/data/data/&lt;packagename&gt;</code>目录</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="代码入口"><a href="#代码入口" class="headerlink" title="代码入口"></a>代码入口</h2><p>代码入口很简单，简单粗暴，就调用了一个静态方法<code>MultiDex.install(base);</code>，传入一个Context对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MultiDex-install分析"><a href="#MultiDex-install分析" class="headerlink" title="MultiDex.install分析"></a>MultiDex.install分析</h2><p>下面是主要的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"MultiDex"</span>, <span class="string">"install"</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_VM_MULTIDEX_CAPABLE) &#123;</span><br><span class="line">        <span class="comment">//VM版本大于2.1时，IS_VM_MULTIDEX_CAPABLE为true，这时候MultiDex.install什么也不用做，直接返回。因为大于2.1的VM会在安装应用的时候，就把多个dex合并到一块</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (VERSION.SDK_INT &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//Multi dex最小支持的SDK版本为4</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + VERSION.SDK_INT + <span class="string">" is unsupported. Min SDK version is "</span> + <span class="number">4</span> + <span class="string">"."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ApplicationInfo e = getApplicationInfo(context);</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set var2 = installedApk;</span><br><span class="line">            <span class="keyword">synchronized</span> (installedApk) &#123;</span><br><span class="line">                String apkPath = e.sourceDir;</span><br><span class="line">                <span class="comment">//检测应用是否已经执行过install()了，防止重复install</span></span><br><span class="line">                <span class="keyword">if</span> (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                installedApk.add(apkPath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取ClassLoader，后面会用它来加载second dex</span></span><br><span class="line">                DexClassLoader classLoader;</span><br><span class="line">                ClassLoader loader;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    loader = context.getClassLoader();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//清空目录：/data/data/&lt;packagename&gt;/files/secondary-dexes/，其实我没搞明白这个的作用，因为从后面的代码来看，这个目录是没有使用到的</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clearOldDexDir(context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                File dexDir = <span class="keyword">new</span> File(e.dataDir, <span class="string">"code_cache/secondary-dexes"</span>);</span><br><span class="line">                <span class="comment">//把dex文件缓存到/data/data/&lt;packagename&gt;/code_cache/secondary-dexes/目录，[后有详细分析]</span></span><br><span class="line">                List files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    <span class="comment">//进行安装，[后有详细分析]</span></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//文件无效，从apk文件中再次解压secondary dex文件后进行安装</span></span><br><span class="line">                    files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!checkValidZipFiles(files)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + var11.getMessage() + <span class="string">")."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的主要逻辑整理如下：</p><ol><li>VM版本检测，如果大于2.1就什么都不做(系统在安装应用的时候已经帮我们把dex合并了)，如果系统SDK版本小于4就抛出运行时异常</li><li>把apk中的secondary dexes解压到缓存目录，并把这些缓存读取出来。应用第二次启动的时候，会尝试从缓存目录中读取，除非读取出的文件校验失败，否则不再从apk中解压dexes</li><li>根据当前的SDK版本，执行不同的安装方法</li></ol><p>先来看看<code>MultiDexExtractor.load(context, e, dexDir, false)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压apk文件中的classes2.dex、classes3.dex等文件解压到dexDir目录中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir      解压目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceReload 是否需要强制从apk文件中解压，否的话会直接读取旧文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 解压后的文件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ApplicationInfo applicationInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                       File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line">    <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line">    List files;</span><br><span class="line">    <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从缓存目录中直接查找缓存文件，跳过解压</span></span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//把apk中的secondary dex文件解压到缓存目录，并把解压后的文件返回</span></span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        <span class="comment">//把解压信息保存到sharedPreferences中</span></span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断以下是否需要强制从apk文件中解压，再进行下CRC校验，如果不需要从apk重新解压，就直接从缓存目录中读取已解压的文件返回，否则解压apk中的classes文件到缓存目录，再把相应的文件返回。这个方法再往下的分析就不贴出来了，不复杂，大家可以自己去看看。读取后会把解压信息保存到sharedPreferences中，里面会保存时间戳、CRC校验和dex数量。</p><p>得到dex文件列表后，要做的就是把dex文件关联到应用，这样应用findclass的时候才能成功。这个主要是通过<code>installSecondaryDexes</code>方法来完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安装dex文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir 缓存目录，用以存放opt之后的dex文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> files  需要安装的dex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          List&lt;File&gt; files)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">                                          </span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//对不同版本的SDK做不同处理</span></span><br><span class="line">        <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            MultiDex.V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            MultiDex.V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MultiDex.V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于不同的SDK版本，分别采用了不同的处理方法，我们主要分析SDK&gt;=19的情况，其他情况大同小异，读者可以自己去分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">V19</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安装dex文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader                     类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalClassPathEntries 需要安装的dex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory         缓存目录，用以存放opt之后的dex文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchFieldException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                                File optimizedDirectory)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取ClassLoader对象中的pathList属性，其实是ClassLoader的父类BaseDexClassLoader中的成员</span></span><br><span class="line">        Field pathListField = MultiDex.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        <span class="comment">//通过属性获取该属性的值，该属性的类型是DexPathList</span></span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line"></span><br><span class="line">        ArrayList suppressedExceptions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//通过反射调用dexPathList的makeDexElements返回Element对象数组。方法里面会读取每一个输入文件，生成DexFile对象，并将其封装进Element对象</span></span><br><span class="line">        Object[] elements = makeDexElements(dexPathList, <span class="keyword">new</span> ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将elements数组跟dexPathList对象的dexElements数组合并，并把合并后的数组作为dexPathList新的值</span></span><br><span class="line">        MultiDex.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, elements);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理异常</span></span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator suppressedExceptionsField = suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (suppressedExceptionsField.hasNext()) &#123;</span><br><span class="line">                IOException dexElementsSuppressedExceptions = (IOException) suppressedExceptionsField.next();</span><br><span class="line">                Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Exception in makeDexElement"</span>, dexElementsSuppressedExceptions);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field suppressedExceptionsField1 = MultiDex.findField(loader, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions1 = (IOException[]) ((IOException[]) suppressedExceptionsField1.get(loader));</span><br><span class="line">            <span class="keyword">if</span> (dexElementsSuppressedExceptions1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions1 = (IOException[]) suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions</span><br><span class="line">                        .size()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                IOException[] combined = <span class="keyword">new</span> IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions1.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions1, <span class="number">0</span>, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions1.length);</span><br><span class="line">                dexElementsSuppressedExceptions1 = combined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            suppressedExceptionsField1.set(loader, dexElementsSuppressedExceptions1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(Object dexPathList,</span><br><span class="line">                                            ArrayList&lt;File&gt; files,</span><br><span class="line">                                            File optimizedDirectory,</span><br><span class="line">                                            ArrayList&lt;IOException&gt; suppressedExceptions) <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        Method makeDexElements = MultiDex.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, <span class="keyword">new</span> Class[]&#123;ArrayList.class, File.class, ArrayList.class&#125;);</span><br><span class="line">        <span class="keyword">return</span> (Object[]) ((Object[]) makeDexElements.invoke(dexPathList, <span class="keyword">new</span> Object[]&#123;files, optimizedDirectory, suppressedExceptions&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android中，有两个ClassLoader，分别是<code>DexPathList</code>和<code>PathClassLoader</code>，它们的父类都是<code>BaseDexClassLoader</code>，DexPathList和PathClassLoader的实现都是在BaseDexClassLoader之中，而BaseDexClassLoader的实现又基本是通过调用DexPathList的方法完成的。DexPathList里面封装了加载dex文件为DexFile对象（调用了native方法，有兴趣的童鞋可以继续跟踪下去）的方法。<br>上述代码中的逻辑如下：</p><ol><li>通过反射获取pathList对象</li><li>通过pathList把输入的dex文件输出为elements数组，elements数组中的元素封装了DexFile对象</li><li>把新输出的elements数组合并到原pathList的dexElements数组中</li><li>异常处理</li></ol><p>当把dex文件加载到pathList的dexElements数组之后，整个multidex.install基本上就完成了。<br>但可能还有些童鞋还会有些疑问，仅仅只是把Element数组合并到ClassLoader就可以了吗？还是没有找到加载类的地方啊？那我们再继续看看，当用到一个类的时候，会用ClassLoader去加载一个类，加载类会调用类加载器的findClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    <span class="comment">//调用pathList的findClass方法</span></span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是继续跟踪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历dexElements数组</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line"></span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//继续跟踪会发现调用的是一个native方法</span></span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在就清晰了，当加载一个类的时候，会遍历dexElements数组，通过native方法从Element元素中加载类名相应的类</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到最后，总结整个multidex.install流程，其实很简单，就做了一件事情，把apk中的secondary dex文件通过ClassLoader转换成Element数组，并把输出的数组合与ClassLoader的Element数组合并。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Android开发者应该都遇到了64K最大方法数限制的问题，针对这个问题，google也推出了multidex分包机制，在生成apk的时候，把整个应用拆成n个dex包（classes.dex、classes2.dex、classes3.dex），每个dex不超过64k个方法。使用multidex，在5.0以前的系统，应用安装时只安装main dex（包含了应用启动需要的必要class），在应用启动之后，需在Application的&lt;code&gt;attachBaseContext&lt;/code&gt;中调用&lt;code&gt;MultiDex.install(base)&lt;/code&gt;方法，在这时候才加载第二、第三…个dex文件，从而规避了64k问题。&lt;br&gt;当然，在&lt;code&gt;attachBaseContext&lt;/code&gt;方法中直接install启动second dex会有一些问题，比如install方法是一个同步方法，当在主线程中加载的dex太大的时候，耗时会比较长，可能会触发ANR。不过这是另外一个问题了，解决方法可以参考：&lt;a href=&quot;http://blog.csdn.net/shensky711/article/details/52329035&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android最大方法数和解决方案&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/shensky711/article/details/52329035。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/shensky711/article/details/52329035。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要分析的是&lt;code&gt;MultiDex.install()&lt;/code&gt;到底做了什么，如何把secondary dexes中的类动态加载进来。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="MultiDex" scheme="http://blog.hanschen.site/tags/MultiDex/"/>
    
      <category term="分包" scheme="http://blog.hanschen.site/tags/%E5%88%86%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JNI教程与技术手册</title>
    <link href="http://blog.hanschen.site/2016/10/13/java-native-interface-specification/"/>
    <id>http://blog.hanschen.site/2016/10/13/java-native-interface-specification/</id>
    <published>2016-10-12T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于JNI，有些童鞋在没有接触过的时候，可能会觉得比较复杂，但是其实当你真正去了解、去使用的时候，就会发现JNI的使用还是比较简单的，JNI本身提供了一系列的API让我们可以在native方法中操作java。JNI的使用无非也就是使用这些接口和java交互。这几天在学习JNI接口的时候，发现网上搜索的JNI的中文虽然不少，但是很多都是零零碎碎的小例子，有一些官方文档的翻译，但要么是不全面，要么是资料比较旧了，干脆自己根据<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/" target="_blank" rel="noopener">java native interface specification</a>整理了一份技术资料。当然，很多时候看中文资料是词不达意的，如果文中有疑问的地方欢迎指出，或者翻阅原文</p><p>首先，JNI是一个本地编程接口。它允许运行在Java虚拟机的Java代码与用其他语言（如C,C++和汇编）编写的库交互<br>JNI最大的好处是JNI不受Java虚拟机实现方式的限制，因此，Java虚拟机厂商添加JNI的支持并不会影响虚拟机其它功能模块。native代码只需要编写一遍，就可以在所有支持JNI的虚拟机上工作。</p><p>通过JNI，你可以在native代码中：</p><ul><li>创建、检查或者更新java对象</li><li>调用java方法</li><li>捕捉和抛出异常</li><li>加载class和获取class信息</li><li>运行时类型检查</li></ul><a id="more"></a><h1 id="JNI接口函数和指针"><a href="#JNI接口函数和指针" class="headerlink" title="JNI接口函数和指针"></a>JNI接口函数和指针</h1><p>本地代码通过JNI函数（接口指针，接口指针是指针的指针）来访问java VM。<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-13-8.png" alt="2019-9-2-11-13-8.png"></p><p>JNI接口指针只在当前线程有效，因此在native方法中<strong>不要跨线程传递接口指针参数</strong>。native方法接收JNI接口指针参数，VM确保在同一个线程中调用native方法的时候，传递同一个接口指针给接口指针给native方法。然而，native方法可能在Java中的不同线程中调用，所以native方法接收到的接口指针可能是不一样的。</p><h1 id="编译、加载和链接本地方法"><a href="#编译、加载和链接本地方法" class="headerlink" title="编译、加载和链接本地方法"></a>编译、加载和链接本地方法</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>Java VM是多线程的 ，所以native libraries应该用多线程编译器来进行编译和链接。例如使用Sun Studio compiler编译器的时候，要为c++代码添加<code>-mt</code>标记；使用 GNU gcc compiler的时候，需添加<code>-D_REENTRANT</code> 或<code>-D_POSIX_C_SOURCE</code></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>native库通过<code>System.loadLibrary</code>方法进行加载。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">native</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span></span>; </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span> &#123; </span><br><span class="line">         System.loadLibrary(<span class="string">"pkg_Cls"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统会对library名会进行转换，在不同平台上有不同的转换方式，例如，Solaris系统转换pkg_Cls为libpkg_Cls.so，而Win32系统转换pkg_Cls为pkg_Cls.dll</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>如果系统不支持动态链接，那么所有本地方法需要预链接到虚拟机，这种情况下，VM已经完成<code>System.loadLibrary</code>了。程序员也可以调用JNI函数RegisterNatives()来注册该类关联的本地方法</p><h1 id="Native-Method命名解析"><a href="#Native-Method命名解析" class="headerlink" title="Native Method命名解析"></a>Native Method命名解析</h1><p>一个本地方法名有以下几个组成部分：</p><ol><li>前缀<code>Java_</code></li><li>完整类名（类名中的<code>.</code>用<code>_</code>代替）</li><li>下划线<code>_</code></li><li>方法名（方法名中的特殊字符需要转义）</li><li>参数签名（非必须，有重载方法的时候才需要），如果有重载的本地方法，需要再添加两个下划线<code>__</code>，然后再添加方法签名（由java字段描述符描述，用<code>_</code>代替描述符中的包名分割<code>/</code>符，签名中的特殊字符需要转义）</li></ol><h2 id="Unicode-转义字符"><a href="#Unicode-转义字符" class="headerlink" title="Unicode 转义字符"></a>Unicode 转义字符</h2><table><thead><tr><th align="left">转义符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">_0XXXX</td><td align="left">一个Unicode字符XXXX。注意小写是用来表示非ascii Unicode字符, 如:_0abcd与_0ABCD不相同</td></tr><tr><td align="left">_1</td><td align="left">字符<code>_</code></td></tr><tr><td align="left">_2</td><td align="left">参数签名中的字符<code>;</code></td></tr><tr><td align="left">_3</td><td align="left">参数签名中的字符<code>[</code></td></tr></tbody></table><p><span id="java_signatures"></span></p><h2 id="java字段描述符"><a href="#java字段描述符" class="headerlink" title="java字段描述符"></a>java字段描述符</h2><table><thead><tr><th align="left">Java 类型</th><th align="left">符号</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">Z</td></tr><tr><td align="left">Byte</td><td align="left">B</td></tr><tr><td align="left">Char</td><td align="left">C</td></tr><tr><td align="left">Short</td><td align="left">S</td></tr><tr><td align="left">Int</td><td align="left">I</td></tr><tr><td align="left">Long</td><td align="left">J</td></tr><tr><td align="left">Float</td><td align="left">F</td></tr><tr><td align="left">Double</td><td align="left">D</td></tr><tr><td align="left">Void</td><td align="left">V</td></tr><tr><td align="left">数组</td><td align="left">[ , 如：<code>int[]</code>-&gt;  <code>[I</code>,  <code>int[][]</code>-&gt;  <code>[[I</code>, <code>Thread[]</code>-&gt;  <code>[Ljava/lang/Thread;</code></td></tr><tr><td align="left">objects</td><td align="left">以”L”开头，以”;”结尾，中间是用”/“ 隔开的包及类名。比如：<code>Ljava/lang/String;</code>如果是嵌套类，则用<code>$</code>来表示嵌套。例如 “<code>(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z</code>“</td></tr></tbody></table><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span> </span>&#123; </span><br><span class="line">    <span class="comment">//对应本地方法名：Java_pkg_Cls_f__ILjava_lang_String_2</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span></span>; </span><br><span class="line"></span><br><span class="line">     ... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Native方法参数"><a href="#Native方法参数" class="headerlink" title="Native方法参数"></a>Native方法参数</h1><ul><li>JNI接口指针是native方法的第一个参数，JNI接口指针的类型是<code>JNIEnv</code>。</li><li>第二个参数取决于native method是否静态方法，如果是非静态方法，那么第二个参数是对对象的引用，如果是静态方法，则第二个参数是对它的class类的引用</li><li>剩下的参数跟Java方法参数一一对应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">native</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span></span>; </span><br><span class="line"></span><br><span class="line">     ... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，c和c++在使用JNI接口的时候有点不一致，请仔细观察通过env调用接口的调用方式</span></span><br><span class="line"><span class="comment">//C版本</span></span><br><span class="line"><span class="function">jdouble <span class="title">Java_pkg_Cls_f__ILjava_lang_String_2</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     JNIEnv *env,        <span class="comment">/* interface pointer */</span></span></span></span><br><span class="line"><span class="function"><span class="params">     jobject obj,        <span class="comment">/* "this" pointer */</span></span></span></span><br><span class="line"><span class="function"><span class="params">     jint i,             <span class="comment">/* argument #1 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">     jstring s)</span>          <span class="comment">/* argument #2 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* Obtain a C-copy of the Java string */</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *str = (*env)-&gt;GetStringUTFChars(env, s, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* process the string */</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Now we are done with str */</span></span><br><span class="line">     (*env)-&gt;ReleaseStringUTFChars(env, s, str);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++版本</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="comment">/* specify the C calling convention */</span>  </span><br><span class="line">jdouble Java_pkg_Cls_f__ILjava_lang_String_2 ( </span><br><span class="line"></span><br><span class="line">     JNIEnv *env,        <span class="comment">/* interface pointer */</span> </span><br><span class="line"></span><br><span class="line">     jobject obj,        <span class="comment">/* "this" pointer */</span> </span><br><span class="line"></span><br><span class="line">     jint i,             <span class="comment">/* argument #1 */</span> </span><br><span class="line"></span><br><span class="line">     jstring s)          <span class="comment">/* argument #2 */</span> </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *str = env-&gt;GetStringUTFChars(s, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">     ... </span><br><span class="line"></span><br><span class="line">     env-&gt;ReleaseStringUTFChars(s, str); </span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java对象引用"><a href="#java对象引用" class="headerlink" title="java对象引用"></a>java对象引用</h1><ul><li>基本类型（如整型，字符等）在Java和native之间是采用值传递</li><li>Java对象采用的是引用传递</li></ul><p>虚拟机必须保持已传递给native的对象的引用，以使这些对象不被垃圾回收器回收。native code也必须有一种方法通知虚拟机它不再需要某个对象，并且垃圾收集器必须能够将其回收</p><h1 id="全局引用、局部引用和弱全局引用"><a href="#全局引用、局部引用和弱全局引用" class="headerlink" title="全局引用、局部引用和弱全局引用"></a>全局引用、局部引用和弱全局引用</h1><p>JNI中使用的引用可以划分为三类：<code>全局引用</code>、<code>局部引用</code>和<code>弱全局引用</code>。局部引用在方法调用的时候有效，在方法调用结束之后会自动释放。全局引用会一直可用，直到显式地对其进行释放。弱全局引用跟全局引用的区别是弱全局引用持有的java对象可以被VM进行回收，所以才使用弱全局引用前，我们需要对其进行检测，看它对应的对象是否被回收了。</p><p>对象是作为局部引用传递给native方法的，所有通过<code>JNIEnv</code>方法（也就是JNI提供的API）返回的java对象都是局部引用。JNI允许程序从局部引用创建一个全局引用。<code>JNIEnv</code>的方法既可以接收全局引用也可以接收局部引用。一个native方法既可以返回局部引用也可以返回全局引用。</p><p>大多数情况下，在方法调用结束之后，我们依赖VM去帮我们释放所有局部引用，但是以下几种情况下，我们应该显式地释放局部引用：</p><ul><li>方法中创建了一个比较大的java对象的，并持有其局部引用，使用完之后，如果接下来都不再需要使用了，如果仍然不对它进行释放的话，在方法结束之前，这个对象都不会进行释放，这样会对资源造成浪费</li><li>JNI会将创建的局部引用都存储在一个局部引用表中，如果这个表超过了最大容量限制，就会造成局部引用表溢出，使程序崩溃。比如在一个循环中创建局部引用，最好在每一轮循环中释放局部引用，否则随着循环次数增加，很可能就内存溢出了</li></ul><p>局部引用仅仅在其创建的线程内有效，<strong>native代码不能跨线程传递局部引用</strong>。</p><h1 id="访问字段和方法"><a href="#访问字段和方法" class="headerlink" title="访问字段和方法"></a>访问字段和方法</h1><p>JNI允许native代码访问对象的成员以及调用它的方法，通过两个步骤即可实现访问，比如，我们需要调用<code>cls</code>中的<code>f</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmethodID mid = env-&gt;GetMethodID(cls, <span class="string">"f"</span>, <span class="string">"(ILjava/lang/String;)D"</span>);<span class="comment">//mid可以重复使用</span></span><br><span class="line">jdouble result = env-&gt;CallDoubleMethod(obj, mid, <span class="number">10</span>, str);</span><br></pre></td></tr></table></figure><p>但是需要注意的是，字段ID或方法ID并不能防止VM卸载该类。当类被卸载后，方法ID和字段ID将变成不可用的。因此，我们需要确保：</p><ul><li>持有class的引用，让它不被卸载，或者</li><li>重新获取方法id或者字段id</li></ul><h1 id="程序错误检测"><a href="#程序错误检测" class="headerlink" title="程序错误检测"></a>程序错误检测</h1><p>JNI不对空指针或非法参数类型等错误进行检测，因为：</p><ul><li>检查所有可能的错误会降低方法执行的性能</li><li>在很多时候，没有足够的运行时信息去进行检测</li></ul><p>程序员不得传递一个非法指针或者错误的类型给JNI函数，否则可能会导致系统异常货虚拟机崩溃</p><h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><p>JNI允许本地方法抛出处理任何异常，也可以处理Java中抛出的异常，剩下没有处理的异常会继续给VM处理</p><h1 id="异常和错误码"><a href="#异常和错误码" class="headerlink" title="异常和错误码"></a>异常和错误码</h1><p>大多数情况下，JNI提供的方法通过返回错误码或者抛出java异常来处理错误，因此，程序中可以：</p><ul><li>检查JNI函数返回值</li><li>调用<code>ExceptionOccurred()</code>方法，获取方法中抛出的异常</li></ul><p><strong>有两种情况下，程序需要优先检测java异常而不是先检测返回码</strong></p><ul><li>通过JNI调用Java方法的时候，需要<code>ExceptionOccurred()</code>检测是否在Java方法中抛出了异常</li><li>一些访问数组的方法，它不返回错误码，但是会抛出<code>ArrayIndexOutOfBoundsException</code> 或者 <code>ArrayStoreException</code>异常</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>有两种方法可以在本地方法中处理异常</p><ul><li>检测到异常的时候立即返回，异常将会在调用该本地代码的地方抛出</li><li>在本地方法中调用<code>ExceptionClear()</code>清除异常，处理接下来的逻辑</li></ul><p>异常抛出的时，本地方法需清除异常后，才能继续调用其他JNI接口方法，有异常发生后，只有以下方法才能被安全调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExceptionOccurred()</span><br><span class="line">ExceptionDescribe()</span><br><span class="line">ExceptionClear()</span><br><span class="line">ExceptionCheck()</span><br><span class="line">ReleaseStringChars()</span><br><span class="line">ReleaseStringUTFChars()</span><br><span class="line">ReleaseStringCritical()</span><br><span class="line">Release&lt;Type&gt;ArrayElements()</span><br><span class="line">ReleasePrimitiveArrayCritical()</span><br><span class="line">DeleteLocalRef()</span><br><span class="line">DeleteGlobalRef()</span><br><span class="line">DeleteWeakGlobalRef()</span><br><span class="line">MonitorExit()</span><br><span class="line">PushLocalFrame()</span><br><span class="line">PopLocalFrame()</span><br></pre></td></tr></table></figure><h1 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h1><table><thead><tr><th align="left">Java 类型</th><th align="left">native类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">jboolean</td><td align="left">unsigned 8 bits</td></tr><tr><td align="left">byte</td><td align="left">jbyte</td><td align="left">signed 8 bits</td></tr><tr><td align="left">char</td><td align="left">jchar</td><td align="left">unsigned 16 bits</td></tr><tr><td align="left">short</td><td align="left">jshort</td><td align="left">signed 16 bits</td></tr><tr><td align="left">int</td><td align="left">jint</td><td align="left">signed 32 bits</td></tr><tr><td align="left">long</td><td align="left">jlong</td><td align="left">signed 64 bits</td></tr><tr><td align="left">float</td><td align="left">jfloat</td><td align="left">32 bits</td></tr><tr><td align="left">double</td><td align="left">jdouble</td><td align="left">64 bits</td></tr><tr><td align="left">void</td><td align="left">void</td><td align="left">N/A</td></tr></tbody></table><p>JNI中还定义了以下两个宏定义方便使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_FALSE  0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_TRUE   1</span></span><br></pre></td></tr></table></figure><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>JNI为不同的java对象提供了不同的引用类型，JNI引用类型如下：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-13-39.png" alt="2019-9-2-11-13-39.png"><br>在c里面，所有JNI引用类型其实都是<code>jobject</code></p><h1 id="字段和方法ID"><a href="#字段和方法ID" class="headerlink" title="字段和方法ID"></a>字段和方法ID</h1><p>在C中，字段和方法ID是一个指向结构体的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">jfieldID</span>;</span>                       <span class="comment">/* opaque structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">jfieldID</span>* <span class="title">jfieldID</span>;</span>     <span class="comment">/* field IDs */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">jmethodID</span>;</span>                      <span class="comment">/* opaque structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">jmethodID</span>* <span class="title">jmethodID</span>;</span>   <span class="comment">/* method IDs */</span></span><br></pre></td></tr></table></figure><h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><p>值类型<code>jvalue</code>是一个联合体结构，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> jvalue &#123;</span><br><span class="line">    jboolean    z;</span><br><span class="line">    jbyte       b;</span><br><span class="line">    jchar       c;</span><br><span class="line">    jshort      s;</span><br><span class="line">    jint        i;</span><br><span class="line">    jlong       j;</span><br><span class="line">    jfloat      f;</span><br><span class="line">    jdouble     d;</span><br><span class="line">    jobject     l;</span><br><span class="line">&#125; jvalue;</span><br></pre></td></tr></table></figure><h1 id="签名类型描述"><a href="#签名类型描述" class="headerlink" title="签名类型描述"></a>签名类型描述</h1><p>请参考：<a href="#java_signatures">java字段描述符</a><br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法签名为：(ILjava/lang/String;[I)J </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span> <span class="params">(<span class="keyword">int</span> n, String s, <span class="keyword">int</span>[] arr)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="UTF-8字符"><a href="#UTF-8字符" class="headerlink" title="UTF-8字符"></a>UTF-8字符</h1><p>JNI的 UTF-8与标准的 UTF-8格式有两个区别：</p><ul><li>空字符<code>(char)0</code>使用双字节格式编码，而不是单字节编码，所以Java虚拟机的UTF-8字符串不可能有嵌入的空值。</li><li>只使用单字节、双字节和三字节编码格式，不支持标准的四字节编码，用<code>two-times-three-byte</code>格式代替  </li></ul><h1 id="JNI接口函数"><a href="#JNI接口函数" class="headerlink" title="JNI接口函数"></a>JNI接口函数</h1><p>在下面的说明中，<code>必须</code>说明JNI函数必须接受一个非空对象，你必须保证传入的参数不为空，JNI函数不需要再对它进行空指针判断</p><h2 id="返回码说明"><a href="#返回码说明" class="headerlink" title="返回码说明"></a>返回码说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_OK          (0)         <span class="comment">/* no error */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_ERR         (-1)        <span class="comment">/* generic error */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_EDETACHED   (-2)        <span class="comment">/* thread detached from the VM */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_EVERSION    (-3)        <span class="comment">/* JNI version error */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_COMMIT      1           <span class="comment">/* copy content, do not free buffer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_ABORT       2           <span class="comment">/* free buffer w/o copying back */</span></span></span><br></pre></td></tr></table></figure><h2 id="接口详细"><a href="#接口详细" class="headerlink" title="接口详细"></a>接口详细</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回本地方法接口的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 高16位返回主版本号，低16位返回次版本号,如在JDK/JRE 1.6中，返回0x00010006。也有可能返回 JNI_EDETACHED 和 JNI_EVERSION 错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*GetVersion)(JNIEnv *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从二进制的.class的数据缓冲区中加载类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param name UTF8编码的需要加载的类的名字</span></span><br><span class="line"><span class="comment"> * @param loader 类加载器</span></span><br><span class="line"><span class="comment"> * @param buf 包含.class字节码的数组</span></span><br><span class="line"><span class="comment"> * @param bufLen 长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return class对象或NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws ClassFormatError 不是有效的class数据</span></span><br><span class="line"><span class="comment"> * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> * @throws SecurityException 如果该类是属于java包的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jclass (*DefineClass)(JNIEnv *, <span class="keyword">const</span> <span class="keyword">char</span> *, jobject, <span class="keyword">const</span> jbyte *, jsize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于加载本地定义的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param name 完整的包名("/"代替".") 或 数组类型字段描述("["开头，紧跟签名描述)，如"java/lang/String" for java.lang.String, "[Ljava/lang/Object;" for java.lang.Object[]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return class对象或NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws ClassFormatError 不是有效的class数据</span></span><br><span class="line"><span class="comment"> * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> * @throws NoClassDefFoundError 找不到name对应的class类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jclass (*FindClass)(JNIEnv *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从java.lang.reflect.Method 或 java.lang.reflect.Constructor 获取method ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param method java.lang.reflect.Method 或 java.lang.reflect.Constructor对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 方法ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jmethodID (*FromReflectedMethod)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从java.lang.reflect.Field获取field ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param field java.lang.reflect.Field对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return field ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jfieldID (*FromReflectedField)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从method ID获取 java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param cls 该方法的类对象</span></span><br><span class="line"><span class="comment"> * @param methodID 方法ID</span></span><br><span class="line"><span class="comment"> * @param isStatic 是否静态方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果clazz不是class对象或接口，则返回该class的超类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 返回输入类的父类 或 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jclass (*GetSuperclass)(JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * class1是否可以安全地转换为class2，以下三种情况会返回TRUE</span></span><br><span class="line"><span class="comment"> * 1. 当class1和class2是同一个java class的引用</span></span><br><span class="line"><span class="comment"> * 2. class1是class2的子类</span></span><br><span class="line"><span class="comment"> * 3. class2是class1的某个接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz1 class1</span></span><br><span class="line"><span class="comment"> * @param clazz2 class2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return JNI_TRUE or JNI_FALSE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 field ID 获取 java.lang.reflect.Field 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param cls 该方法的类对象</span></span><br><span class="line"><span class="comment"> * @param fieldID 字段ID</span></span><br><span class="line"><span class="comment"> * @param isStatic 是否静态变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java.lang.reflect.Field 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java.lang.Throwable 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*Throw)(JNIEnv *, jthrowable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据clazz和message构造一个异常对象，并将它抛出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz java.lang.Throwable的子类</span></span><br><span class="line"><span class="comment"> * @param message 错误信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*ThrowNew)(JNIEnv *, jclass, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否有异常抛出，在调用ExceptionClear()或java代码处理了exception之前，都可以用这个方法判断是否有异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 异常对象 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jthrowable (*ExceptionOccurred)(JNIEnv *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印异常信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*ExceptionDescribe)(JNIEnv *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除所有已抛出的异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*ExceptionClear)(JNIEnv *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛出致命错误并且不希望虚拟机进行恢复。无返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*FatalError)(JNIEnv *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的本地引用帧</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param capacity 容量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功，负数：失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*PushLocalFrame)(JNIEnv *, jint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弹出当前本地引用帧，释放所有本地引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param result</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*PopLocalFrame)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为传入的obj创建全局引用，obj可以是全局引用也可以是局部引用。全局引用需要调用DeleteGlobalRef来释放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj 全局或局部引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 全局引用 or NULL(内存不足)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*NewGlobalRef)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放全局引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param globalRef 全局引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*DeleteGlobalRef)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放局部引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param localRef 局部引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*DeleteLocalRef)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个引用是否同一java对象的引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param ref1 引用1</span></span><br><span class="line"><span class="comment"> * @param ref2 引用2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return JNI_TRUE:两个引用指向同一个java对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jboolean (*IsSameObject)(JNIEnv *, jobject, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为传入的ref创建局部引用，ref可以是全局引用也可以是局部引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param ref 全局或局部引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 局部引用 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*NewLocalRef)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保当前线程可以创建capacity个局部引用。在进入本地方法时，VM确保可以可以创建最少16个局部引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param capacity 局部引用个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功，负数：失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*EnsureLocalCapacity)(JNIEnv *, jint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的java对象（不会调用对象的构造方法）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz 非数组class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws InstantiationException clazz是一个接口或抽象类</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*AllocObject)(JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz 非数组class对象</span></span><br><span class="line"><span class="comment"> * @param ... 传递给构造方法的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java对象 or NULL(对象构造失败)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws InstantiationException clazz是一个接口或抽象类</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*NewObject)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz 非数组class对象</span></span><br><span class="line"><span class="comment"> * @param args va_list结构，里面有传递给构造方法的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java对象 or NULL(对象构造失败)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws InstantiationException clazz是一个接口或抽象类</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz 非数组class对象</span></span><br><span class="line"><span class="comment"> * @param args 参数数组，里面是传递给构造方法的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java对象 or NULL(对象构造失败)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws InstantiationException clazz是一个接口或抽象类</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回对象对应的class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj 非空java对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jclass (*GetObjectClass)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断obj是否clazz的实例对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回非静态方法的method ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param name 方法名</span></span><br><span class="line"><span class="comment"> * @param sig 方法签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 方法ID or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws NoSuchMethodError 找不到对应的方法</span></span><br><span class="line"><span class="comment"> * @throws ExceptionInInitializerError class初始化失败</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jmethodID (*GetMethodID)(JNIEnv *, jclass, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call&lt;type&gt;Method(JNIEnv *env, jobject obj, jmethodID methodID, ...);调用参数放到可变参数中</span></span><br><span class="line"><span class="comment"> * Call&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组</span></span><br><span class="line"><span class="comment"> * Call&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);调用参数放入va_list结构中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上三组调用接口都是根据 method ID调用java实例方法（非静态方法）的接口，其中method ID是通过GetMethodID()获取的</span></span><br><span class="line"><span class="comment"> * 当这些方法用于调用java对象的私有方法或构造函数时，method ID必须从obj的真实类获取，而不应从其某个父类获取</span></span><br><span class="line"><span class="comment"> * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象</span></span><br><span class="line"><span class="comment"> * @param methodID 方法ID</span></span><br><span class="line"><span class="comment"> * @param args 调用参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java方法返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws java方法中可能抛出的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*CallObjectMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jboolean (*CallBooleanMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jbyte (*CallByteMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jchar (*CallCharMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jshort (*CallShortMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jint (*CallIntMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jlong (*CallLongMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jfloat (*CallFloatMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line">jdouble (*CallDoubleMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line">jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line">jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line"><span class="keyword">void</span> (*CallVoidMethod)(JNIEnv *, jobject, jmethodID, ...);</span><br><span class="line"><span class="keyword">void</span> (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list);</span><br><span class="line"><span class="keyword">void</span> (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CallNonvirtual&lt;type&gt;Method(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中</span></span><br><span class="line"><span class="comment"> * CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组</span></span><br><span class="line"><span class="comment"> * CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上三组调用接口都是根据 method ID 和 class 调用java实例方法（非静态方法）的接口，其中method ID是基于clazz通过GetMethodID()获取的</span></span><br><span class="line"><span class="comment"> * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同</span></span><br><span class="line"><span class="comment"> * 注意，和Call&lt;type&gt;Method不同，如果子类重写了父类的方法，Call&lt;type&gt;Method调用的是子类的方法，如果想调用父类的方法，</span></span><br><span class="line"><span class="comment"> * 则需要用CallNonvirtual&lt;type&gt;Method，这个方法可以传入父类的class和父类的method id，从而达到调用父类方法的效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param obj java对象</span></span><br><span class="line"><span class="comment"> * @param methodID 方法ID</span></span><br><span class="line"><span class="comment"> * @param args 调用参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java方法返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws java方法中可能抛出的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*CallNonvirtualObjectMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jboolean (*CallNonvirtualBooleanMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jbyte (*CallNonvirtualByteMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jchar (*CallNonvirtualCharMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jshort (*CallNonvirtualShortMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jint (*CallNonvirtualIntMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jlong (*CallNonvirtualLongMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jfloat (*CallNonvirtualFloatMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line">jdouble (*CallNonvirtualDoubleMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line">jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line">jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line"><span class="keyword">void</span> (*CallNonvirtualVoidMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);</span><br><span class="line"><span class="keyword">void</span> (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);</span><br><span class="line"><span class="keyword">void</span> (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据class对象获取非静态成员变量的field ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param name 变量名</span></span><br><span class="line"><span class="comment"> * @param sig 变量签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return field ID or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws NoSuchFieldError 找不到对应的变量ID</span></span><br><span class="line"><span class="comment"> * @throws ExceptionInInitializerError class初始化失败</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jfieldID (*GetFieldID)(JNIEnv *, jclass, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据field id取出对象中相应的变量值，field Id通过GetFieldID()获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象</span></span><br><span class="line"><span class="comment"> * @param fieldID 有效的field id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 相应的变量值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jchar (*GetCharField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jshort (*GetShortField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jint (*GetIntField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jlong (*GetLongField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line">jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据field id为相应的变量设置新的值，field Id通过GetFieldID()获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象</span></span><br><span class="line"><span class="comment"> * @param fieldID 有效的field id</span></span><br><span class="line"><span class="comment"> * @param value 要设置的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject);</span><br><span class="line"><span class="keyword">void</span> (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean);</span><br><span class="line"><span class="keyword">void</span> (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte);</span><br><span class="line"><span class="keyword">void</span> (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar);</span><br><span class="line"><span class="keyword">void</span> (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort);</span><br><span class="line"><span class="keyword">void</span> (*SetIntField)(JNIEnv *, jobject, jfieldID, jint);</span><br><span class="line"><span class="keyword">void</span> (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong);</span><br><span class="line"><span class="keyword">void</span> (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat);</span><br><span class="line"><span class="keyword">void</span> (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回静态方法的method ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param name 方法名</span></span><br><span class="line"><span class="comment"> * @param sig 方法签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 方法ID or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws NoSuchMethodError 找不到对应的方法</span></span><br><span class="line"><span class="comment"> * @throws ExceptionInInitializerError class初始化失败</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CallStatic&lt;type&gt;Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中</span></span><br><span class="line"><span class="comment"> * CallStatic&lt;type&gt;MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组</span></span><br><span class="line"><span class="comment"> * CallStatic&lt;type&gt;MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上三组调用接口都是根据 method ID调用java静态方法的接口，其中method ID是通过GetStaticMethodID()获取的</span></span><br><span class="line"><span class="comment"> * method ID必须从clazz的真实类获取，而不应从其某个父类获取</span></span><br><span class="line"><span class="comment"> * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param methodID 方法ID</span></span><br><span class="line"><span class="comment"> * @param args 调用参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return java方法返回结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws java方法中可能抛出的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*CallStaticObjectMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jboolean (*CallStaticBooleanMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jbyte (*CallStaticByteMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jchar (*CallStaticCharMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jshort (*CallStaticShortMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jint (*CallStaticIntMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jlong (*CallStaticLongMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jfloat (*CallStaticFloatMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line">jdouble (*CallStaticDoubleMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line">jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line">jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line"><span class="keyword">void</span> (*CallStaticVoidMethod)(JNIEnv *, jclass, jmethodID, ...);</span><br><span class="line"><span class="keyword">void</span> (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list);</span><br><span class="line"><span class="keyword">void</span> (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据class对象获取静态成员变量的field ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param name 变量名</span></span><br><span class="line"><span class="comment"> * @param sig 变量签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return field ID or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws NoSuchFieldError 找不到对应的变量ID</span></span><br><span class="line"><span class="comment"> * @throws ExceptionInInitializerError class初始化失败</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据field id取出对象中相应的变量值，field Id通过GetStaticFieldID()获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param fieldID 有效的field id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 相应的静态变量值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line">jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据field id为相应的静态变量设置新的值，field Id通过GetStaticFieldID()获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param fieldID 有效的field id</span></span><br><span class="line"><span class="comment"> * @param value 要设置的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat);</span><br><span class="line"><span class="keyword">void</span> (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的java.lang.String对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param unicodeChars 指向Unicode字符串的指针</span></span><br><span class="line"><span class="comment"> * @param len Unicode字符串的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return String对象 or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jstring (*NewString)(JNIEnv *, <span class="keyword">const</span> jchar *, jsize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回java.lang.String的长度（Unicode字符数）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jsize (*GetStringLength)(JNIEnv *, jstring);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指向Unicode字符数组的指针</span></span><br><span class="line"><span class="comment"> * 该指针在调用ReleaseStringchars()前一直有效</span></span><br><span class="line"><span class="comment"> * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> * @param isCopy 指向boolean的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 指向字符串的指针 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知VM无需再访问chars</span></span><br><span class="line"><span class="comment"> * chars是一个指针，通过GetStringChars()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> * @param chars 指向字符串的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*ReleaseStringChars)(JNIEnv *, jstring, <span class="keyword">const</span> jchar *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据UTF-8编码的字符数组创建一个新的java.lang.String对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param bytes 指向UTF-8字符串的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return String对象 or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError 内存不足</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jstring (*NewStringUTF)(JNIEnv *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回字符串以UTF-8为编码的字节数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 字符串的UTF-8字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jsize (*GetStringUTFLength)(JNIEnv *, jstring);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指向UTF-8编码字符数组的指针</span></span><br><span class="line"><span class="comment"> * 该指针在调用ReleaseStringUTFChars()前一直有效</span></span><br><span class="line"><span class="comment"> * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> * @param isCopy 指向boolean的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 指向字符串的指针 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知VM无需再访问utf</span></span><br><span class="line"><span class="comment"> * utf是一个指针，通过GetStringUTFChars()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> * @param utf 指向字符串的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*ReleaseStringUTFChars)(JNIEnv *, jstring, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jsize (*GetArrayLength)(JNIEnv *, jarray);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建新的elementClass类型数组，所有元素初始值均设为initialElement</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param length 数组大小</span></span><br><span class="line"><span class="comment"> * @param elementClass 数组类型</span></span><br><span class="line"><span class="comment"> * @param initialElement 初始值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 数组对象 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取对象数组中指定index的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组</span></span><br><span class="line"><span class="comment"> * @param index 索引</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 索引对象的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置对象数组中指定index的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组</span></span><br><span class="line"><span class="comment"> * @param index 索引</span></span><br><span class="line"><span class="comment"> * @param value 新的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayType New&lt;PrimitiveType&gt;Array(JNIEnv *env, jsize length);</span></span><br><span class="line"><span class="comment"> * 创建基本类型数组对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param length 数组大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 数组对象 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize);</span><br><span class="line">jbyteArray (*NewByteArray)(JNIEnv *, jsize);</span><br><span class="line">jcharArray (*NewCharArray)(JNIEnv *, jsize);</span><br><span class="line">jshortArray (*NewShortArray)(JNIEnv *, jsize);</span><br><span class="line">jintArray (*NewIntArray)(JNIEnv *, jsize);</span><br><span class="line">jlongArray (*NewLongArray)(JNIEnv *, jsize);</span><br><span class="line">jfloatArray (*NewFloatArray)(JNIEnv *, jsize);</span><br><span class="line">jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NativeType *Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);</span></span><br><span class="line"><span class="comment"> * 返回基本类型数组中的数据，通过返回的指针可以访问这些数据，若虚拟机支持pinning，则指针指向原始数组，否则指向原始数组的拷贝</span></span><br><span class="line"><span class="comment"> * 返回的指针在Release&lt;PrimitiveType&gt;ArrayElements()调用前一直有效</span></span><br><span class="line"><span class="comment"> * 数组用使用结束后，调用Release&lt;PrimitiveType&gt;ArrayElements，并在调用参数中决定是否把修改提交给java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组</span></span><br><span class="line"><span class="comment"> * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 指向数组元素的指针 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *);</span><br><span class="line">jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *);</span><br><span class="line">jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *);</span><br><span class="line">jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *);</span><br><span class="line">jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *);</span><br><span class="line">jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *);</span><br><span class="line">jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *);</span><br><span class="line">jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release&lt;PrimitiveType&gt;ArrayElements</span></span><br><span class="line"><span class="comment"> * 通知VM不再需要访问这些数组，根据mode参数的不同，将决定是否把数组的修改复制到源数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组对象</span></span><br><span class="line"><span class="comment"> * @param elems 指向数组元素的指针</span></span><br><span class="line"><span class="comment"> * @param mode 释放模式，0：把数据复制回源数组并释放elems缓冲区，JNI_COMMIT：把数据复制回源数组但不释放elems缓冲区，JNI_ABORT：不把数据复制回源数组，释放elems缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);</span></span><br><span class="line"><span class="comment"> * 把基本类型数组拷贝到buf中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组</span></span><br><span class="line"><span class="comment"> * @param start 开始index</span></span><br><span class="line"><span class="comment"> * @param len 拷贝长度</span></span><br><span class="line"><span class="comment"> * @param buf 目标地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *);</span><br><span class="line"><span class="keyword">void</span> (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *);</span><br><span class="line"><span class="keyword">void</span> (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *);</span><br><span class="line"><span class="keyword">void</span> (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *);</span><br><span class="line"><span class="keyword">void</span> (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *);</span><br><span class="line"><span class="keyword">void</span> (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *);</span><br><span class="line"><span class="keyword">void</span> (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *);</span><br><span class="line"><span class="keyword">void</span> (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void Set&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, const NativeType *buf);</span></span><br><span class="line"><span class="comment"> * 把buf中的内容拷贝回数组中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组</span></span><br><span class="line"><span class="comment"> * @param start 开始index</span></span><br><span class="line"><span class="comment"> * @param len 拷贝长度</span></span><br><span class="line"><span class="comment"> * @param buf 源数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, <span class="keyword">const</span> jboolean *);</span><br><span class="line"><span class="keyword">void</span> (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, <span class="keyword">const</span> jbyte *);</span><br><span class="line"><span class="keyword">void</span> (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, <span class="keyword">const</span> jchar *);</span><br><span class="line"><span class="keyword">void</span> (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, <span class="keyword">const</span> jshort *);</span><br><span class="line"><span class="keyword">void</span> (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, <span class="keyword">const</span> jint *);</span><br><span class="line"><span class="keyword">void</span> (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, <span class="keyword">const</span> jlong *);</span><br><span class="line"><span class="keyword">void</span> (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, <span class="keyword">const</span> jfloat *);</span><br><span class="line"><span class="keyword">void</span> (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, <span class="keyword">const</span> jdouble *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为clazz类注册本地方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> * @param methods clazz类中的本地方法，指向方法数组</span></span><br><span class="line"><span class="comment"> * @param nMethods 本地方法个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws NoSuchMethodError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*RegisterNatives)(JNIEnv *, jclass, <span class="keyword">const</span> JNINativeMethod *, jint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消clazz类本地方法的注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param clazz class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*UnregisterNatives)(JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入与obj所引用的Java对象相关联的监控，obj 必须为非空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象 或 class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*MonitorEnter)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出与obj所引用的Java对象相关联的监控，obj 必须为非空</span></span><br><span class="line"><span class="comment"> * 当前线程必须是与obj所引用的Java对象相关联的监控程序的所有者</span></span><br><span class="line"><span class="comment"> * 监控程序次数的计数器减 1。如果计数器的值变为 0，则释放当前线程的监控程序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象 或 class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*MonitorExit)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程关联的Java VM接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param vm java VM接口指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0：成功， 负数：失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jint (*GetJavaVM)(JNIEnv *, JavaVM **);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从start index开始，拷贝len个Unicode字符到buf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param str string对象</span></span><br><span class="line"><span class="comment"> * @param start 开始index</span></span><br><span class="line"><span class="comment"> * @param len 拷贝长度</span></span><br><span class="line"><span class="comment"> * @param buf 目标地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从start index开始，取出len个Unicode字符转换为UTF-8编码后拷贝到buf</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param str string对象</span></span><br><span class="line"><span class="comment"> * @param start 开始index</span></span><br><span class="line"><span class="comment"> * @param len 拷贝长度</span></span><br><span class="line"><span class="comment"> * @param buf 目标地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与Get/Release&lt;primitivetype&gt;ArrayElements方法非常相似，在这个方法中VM尽量返回指向原始数组的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since JDK/JRE 1.2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param array java数组</span></span><br><span class="line"><span class="comment"> * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 指向数组元素的指针 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *);</span><br><span class="line"><span class="keyword">void</span> (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, <span class="keyword">void</span> *, jint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与Get/ReleaseStringChars方法非常相似，在这个方法中VM尽量返回指向原始字符串的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since JDK/JRE 1.2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param string String对象</span></span><br><span class="line"><span class="comment"> * @param isCopy 指向boolean的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 指向字符串的指针 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *);</span><br><span class="line"><span class="keyword">void</span> (*ReleaseStringCritical)(JNIEnv *, jstring, <span class="keyword">const</span> jchar *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为传入的obj创建弱全局引用</span></span><br><span class="line"><span class="comment"> * 弱全局引用不会阻止VM释放所引用的对象，程序中可以通过使用IsSameObject比较弱全局引用和NULL来确认所引用的对象是否被释放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj 全局或局部引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 弱全局引用 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jweak (*NewWeakGlobalRef)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除弱全局引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj 弱全局引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*DeleteWeakGlobalRef)(JNIEnv *, jweak);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否有未处理异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return JNI_TRUE表示有未处理异常，否则为JNI_FALSE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jboolean (*ExceptionCheck)(JNIEnv *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并返回java.nio.ByteBuffer对象，该对象引用以address为开始地址，大小为capacity的内存块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since JDK/JRE 1.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param address 开始地址</span></span><br><span class="line"><span class="comment"> * @param capacity 内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Jjava.nio.ByteBuffer or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobject (*NewDirectByteBuffer)(JNIEnv *, <span class="keyword">void</span> *, jlong);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据java.nio.ByteBuffer对象，获取相应的内存数据并返回开始地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since JDK/JRE 1.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param buf java.nio.ByteBuffer对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 数据的开始地址 or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> *(*GetDirectBufferAddress)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据java.nio.ByteBuffer对象，获取相应的内存数据的大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since JDK/JRE 1.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param buf java.nio.ByteBuffer对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 数据大小 or -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取java对象的引用类型，可能的返回值有：</span></span><br><span class="line"><span class="comment"> * JNIInvalidRefType</span></span><br><span class="line"><span class="comment"> * JNILocalRefType：局部引用</span></span><br><span class="line"><span class="comment"> * JNIGlobalRefType：全局引用</span></span><br><span class="line"><span class="comment"> * JNIWeakGlobalRefType ：全局弱若引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since JDK/JRE 1.6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param env JNI接口指针</span></span><br><span class="line"><span class="comment"> * @param obj java对象的引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 引用类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;对于JNI，有些童鞋在没有接触过的时候，可能会觉得比较复杂，但是其实当你真正去了解、去使用的时候，就会发现JNI的使用还是比较简单的，JNI本身提供了一系列的API让我们可以在native方法中操作java。JNI的使用无非也就是使用这些接口和java交互。这几天在学习JNI接口的时候，发现网上搜索的JNI的中文虽然不少，但是很多都是零零碎碎的小例子，有一些官方文档的翻译，但要么是不全面，要么是资料比较旧了，干脆自己根据&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/jni/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java native interface specification&lt;/a&gt;整理了一份技术资料。当然，很多时候看中文资料是词不达意的，如果文中有疑问的地方欢迎指出，或者翻阅原文&lt;/p&gt;
&lt;p&gt;首先，JNI是一个本地编程接口。它允许运行在Java虚拟机的Java代码与用其他语言（如C,C++和汇编）编写的库交互&lt;br&gt;JNI最大的好处是JNI不受Java虚拟机实现方式的限制，因此，Java虚拟机厂商添加JNI的支持并不会影响虚拟机其它功能模块。native代码只需要编写一遍，就可以在所有支持JNI的虚拟机上工作。&lt;/p&gt;
&lt;p&gt;通过JNI，你可以在native代码中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建、检查或者更新java对象&lt;/li&gt;
&lt;li&gt;调用java方法&lt;/li&gt;
&lt;li&gt;捕捉和抛出异常&lt;/li&gt;
&lt;li&gt;加载class和获取class信息&lt;/li&gt;
&lt;li&gt;运行时类型检查&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="jni" scheme="http://blog.hanschen.site/tags/jni/"/>
    
      <category term="java" scheme="http://blog.hanschen.site/tags/java/"/>
    
      <category term="java native interface specification" scheme="http://blog.hanschen.site/tags/java-native-interface-specification/"/>
    
      <category term="ndk" scheme="http://blog.hanschen.site/tags/ndk/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 2.2 NDK开发环境搭建</title>
    <link href="http://blog.hanschen.site/2016/10/09/Android-Studio-2.2-NDK/"/>
    <id>http://blog.hanschen.site/2016/10/09/Android-Studio-2.2-NDK/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.823Z</updated>
    
    <content type="html"><![CDATA[<p>Android应用程序使用NDK的意义在这里就不说了，本文主要讲解如何在Android Studio 2.2下如何一步步搭建NDK开发环境。</p><h1 id="下载NDK和工具"><a href="#下载NDK和工具" class="headerlink" title="下载NDK和工具"></a>下载NDK和工具</h1><p>Android Studio2.2开始推荐开发者使用CMake去构建本地代码，在构建之前，我们需先安装下面三个依赖：</p><ul><li><strong>NDK</strong>: a set of tools that allows you to use C and C++ code with Android.</li><li><strong>CMake</strong>: an external build tool that works alongside Gradle to build your native library. You do not need this component if you only plan to use ndk-build. </li><li><strong>LLDB</strong>: the debugger Android Studio uses to debug native code.</li></ul><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-11-0.png" alt="2019-9-2-11-11-0.png"></p><p>我们可以使用SDK Manager进行下载，菜单位置：Tools &gt; Android &gt; SDK Manager，勾选后安装即可</p><a id="more"></a><h1 id="创建或者导入native项目"><a href="#创建或者导入native项目" class="headerlink" title="创建或者导入native项目"></a>创建或者导入native项目</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-11-21.png" alt="2019-9-2-11-11-21.png"><br>在这里要注意勾选这个<code>Include C++ Support</code></p><p>接下来一路next最后finish，工程就创建好了。创建好之后系统默认生成了个demo。在Android Studio2.2下，目录结构发生了变化</p><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-11-36.png" alt="2019-9-2-11-11-36.png"><br><strong>所有c/c++文件都应放置在src/main/cpp/目录</strong>（以前是在jni目录）</p><h1 id="配置build-gradle"><a href="#配置build-gradle" class="headerlink" title="配置build.gradle"></a>配置build.gradle</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                <span class="comment">//设置编译工具链</span></span><br><span class="line">                arguments <span class="string">"-DANDROID_TOOLCHAIN=clang"</span></span><br><span class="line">                <span class="comment">//需编译生成的ABI类型</span></span><br><span class="line">                abiFilters <span class="string">'x86'</span>, <span class="string">'x86_64'</span>, <span class="string">'armeabi'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'arm64-v8a'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ndk &#123;</span><br><span class="line">            <span class="comment">//打包进APK的ABI类型</span></span><br><span class="line">            abiFilters <span class="string">"armeabi"</span>, <span class="string">"armeabi-v7a"</span>, <span class="string">"x86"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            <span class="comment">//配置CMakeLists.txt的路径</span></span><br><span class="line">            path <span class="string">'CMakeLists.txt'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-11-56.png" alt="2019-9-2-11-11-56.png"><br>配置之后，我们就会发现工程终于变成这种结构了，其中<code>cpp</code>里面的是源文件，<code>External Build Files</code>是CMakeLists文件。</p><p>当然，想要正常编译，我们还需要学习CMake文件，这里推荐一篇文章：<a href="http://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">CMake 入门实战</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android应用程序使用NDK的意义在这里就不说了，本文主要讲解如何在Android Studio 2.2下如何一步步搭建NDK开发环境。&lt;/p&gt;
&lt;h1 id=&quot;下载NDK和工具&quot;&gt;&lt;a href=&quot;#下载NDK和工具&quot; class=&quot;headerlink&quot; title=&quot;下载NDK和工具&quot;&gt;&lt;/a&gt;下载NDK和工具&lt;/h1&gt;&lt;p&gt;Android Studio2.2开始推荐开发者使用CMake去构建本地代码，在构建之前，我们需先安装下面三个依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NDK&lt;/strong&gt;: a set of tools that allows you to use C and C++ code with Android.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMake&lt;/strong&gt;: an external build tool that works alongside Gradle to build your native library. You do not need this component if you only plan to use ndk-build. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LLDB&lt;/strong&gt;: the debugger Android Studio uses to debug native code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-11-0.png&quot; alt=&quot;2019-9-2-11-11-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用SDK Manager进行下载，菜单位置：Tools &amp;gt; Android &amp;gt; SDK Manager，勾选后安装即可&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android Studio NDK" scheme="http://blog.hanschen.site/tags/Android-Studio-NDK/"/>
    
      <category term="NDK开发" scheme="http://blog.hanschen.site/tags/NDK%E5%BC%80%E5%8F%91/"/>
    
      <category term="JNI" scheme="http://blog.hanschen.site/tags/JNI/"/>
    
      <category term="NDK" scheme="http://blog.hanschen.site/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>ProGuard代码混淆详细攻略</title>
    <link href="http://blog.hanschen.site/2016/09/15/proguard/"/>
    <id>http://blog.hanschen.site/2016/09/15/proguard/</id>
    <published>2016-09-14T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ProGuard简介和工作流程"><a href="#ProGuard简介和工作流程" class="headerlink" title="ProGuard简介和工作流程"></a>ProGuard简介和工作流程</h1><p>ProGuard能够通过压缩、优化、混淆、预检等操作，检测并删除未使用的类,字段,方法和属性，分析和优化字节码，使用简短无意义的名称来重命名类，字段和方法。从而使代码更小、更高效、更难进行逆向工程。<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-59-30.png" alt="2019-9-2-10-59-30.png"></p><p>上图就是ProGuard的工作流程，分别会经过四个阶段：</p><ol><li><code>压缩（Shrink）</code>:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性</li><li><code>优化（Optimize）</code>:在优化处理这一步中，对字节码进行优化，并且移除无用指令</li><li><code>混淆（Obfuscate）</code>:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名</li><li><code>预检（Preveirfy）</code>:在预检这一步中，主要是在Java平台上对处理后的代码进行预检</li></ol><p>以上四个步骤都是<strong>可选</strong>的，我们可以通过配置脚本来决定其中的哪几个步骤。比如我们可以配置只压缩和混淆，不进行优化，不进行预检。<br>ProGuard的官网有使用指导：<a href="http://proguard.sourceforge.net/" target="_blank" rel="noopener">http://proguard.sourceforge.net/</a></p><p> </p><a id="more"></a><h1 id="PrgGuard环境配置和使用"><a href="#PrgGuard环境配置和使用" class="headerlink" title="PrgGuard环境配置和使用"></a>PrgGuard环境配置和使用</h1><h2 id="运行PrgGuard需要以下依赖："><a href="#运行PrgGuard需要以下依赖：" class="headerlink" title="运行PrgGuard需要以下依赖："></a>运行PrgGuard需要以下依赖：</h2><ul><li>proguard.jar或者proguardgui.jar。proguardgui提供了一个简单的配置界面（如下图），可以在上面进行配置，而progua.jar则是使用配置文件进行处理</li><li>Java运行环境</li></ul><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-0-18.png" alt="2019-9-2-11-0-18.png"></p><h2 id="如何运行ProGuard"><a href="#如何运行ProGuard" class="headerlink" title="如何运行ProGuard"></a>如何运行ProGuard</h2><p>ProGuard可以通过命令行调用，如：</p><ul><li>java -jar proguardgui.jar：启动图形化配置界面</li><li>java -jar proguard.jar @config.file –options …：通过配置文件进行ProGuard处理</li></ul><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-1-37.png" alt="2019-9-2-11-1-37.png"></p><p>执行成功后，用jd-gui打开处理后的jar文件：</p><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-1-52.png" alt="2019-9-2-11-1-52.png"></p><p>可以发现，类已经被混淆处理了。</p><h1 id="PrgGuard配置文件使用"><a href="#PrgGuard配置文件使用" class="headerlink" title="PrgGuard配置文件使用"></a>PrgGuard配置文件使用</h1><h2 id="Entry-points的概念"><a href="#Entry-points的概念" class="headerlink" title="Entry points的概念"></a>Entry points的概念</h2><p>这里，我们引入Entry points的概念。Entry points是在ProGuard过程中不会处理的类或者方法。<br>在Shrink的步骤中，ProGuard会递归遍历，搜索使用了哪些类和成员，对于没有使用的类和类成员，就会在压缩阶段丢弃。<br>接下来在Optimize阶段，那些非Entry points的类、方法都会被设置为private、static或者final，没有使用的参数会被移除，此外，有些方法会被标记为内联。<br>在Obfuscate的步骤中，ProGuard会对非Entry points的类和方法进行重命名。</p><h2 id="会用到的指令参数说明"><a href="#会用到的指令参数说明" class="headerlink" title="会用到的指令参数说明"></a>会用到的指令参数说明</h2><h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><ul><li><code>Includedescriptorclasses</code>：一般用于保证native方法名，确保方法的参数类型不会重命名，确保方法签名不会被改变，这样才能跟native libraries相匹配。</li><li><code>Allowshrinking</code>：允许压缩</li><li><code>Allowoptimization</code>：允许优化</li><li><code>Allowobfuscation</code>：允许混淆名称</li></ul><h3 id="Class-Specifications"><a href="#Class-Specifications" class="headerlink" title="Class Specifications"></a>Class Specifications</h3><p>Class Specifications是用来描述类和方法的模板，下面是这个模板的格式：</p><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-2-15.png" alt="2019-9-2-11-2-15.png"></p><p>其中，[]中的内容是可选，名称可以使用通配符，<init>匹配构造函数、<fields>匹配成员、<methods>匹配方法，详细请参考：<a href="http://proguard.sourceforge.net/manual/usage.html#keepoptionmodifiers" target="_blank" rel="noopener">http://proguard.sourceforge.net/manual/usage.html#keepoptionmodifiers</a></methods></fields></init></p><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="basedirectory-directoryname："><a href="#basedirectory-directoryname：" class="headerlink" title="-basedirectory directoryname："></a>-basedirectory directoryname：</h3><p>在配置文件中出现的相对路径均是相对于该路径，如图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-2-50.png" alt="2019-9-2-11-2-50.png"></p><h3 id="injars-class-path"><a href="#injars-class-path" class="headerlink" title="-injars class_path"></a>-injars class_path</h3><p>指定处理的jar包（或者aars, wars, ears, zips, apks, directories）等，这个jar包里面的类将会被ProGuard处理并写入到输出的jar包里去。一般非class文件会不做任何处理直接直接复制到输出文件中，injars可以多次使用，引入不同的需要处理的文件。<br>注意，该选项可以指定一个目录，那么该目录下所有文件都会被当作input file处理。</p><h3 id="outjars-class-path"><a href="#outjars-class-path" class="headerlink" title="-outjars class_path"></a>-outjars class_path</h3><p>设置处理完成后的输出文件路径</p><h3 id="libraryjars-class-path"><a href="#libraryjars-class-path" class="headerlink" title="-libraryjars class_path"></a>-libraryjars class_path</h3><p>指定要处理应用程序的jar(或者aars, wars, ears, zips, apks, directories)，这些文件不会包含到输出文件中。一般是指被处理文件所依赖的一些jar包，而那些jar包是不需要被处理以及写入到输出文件的。比如：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-6-36.png" alt="2019-9-2-11-6-36.png"></p><h3 id="skipnonpubliclibraryclasses"><a href="#skipnonpubliclibraryclasses" class="headerlink" title="-skipnonpubliclibraryclasses"></a>-skipnonpubliclibraryclasses</h3><p>忽略library里面非public修饰的类。从而加快ProGuard的处理速度和降低ProGuard的使用内存。一般而言，library里的非公开类是不能被程序使用的，忽略掉这些类可以加快混淆速度。但是请注意，<strong>有一种特殊情况：有些人编写的代码与类库中的类在同一个包下，而且对该包的非public类进行了使用，在这种情况下，就不能使用该选项了</strong>。</p><h3 id="–dontskipnonpubliclibraryclasses"><a href="#–dontskipnonpubliclibraryclasses" class="headerlink" title="–dontskipnonpubliclibraryclasses"></a>–dontskipnonpubliclibraryclasses</h3><p>不忽略library里面非public修饰的类</p><h3 id="dontskipnonpubliclibraryclassmembers"><a href="#dontskipnonpubliclibraryclassmembers" class="headerlink" title="-dontskipnonpubliclibraryclassmembers"></a>-dontskipnonpubliclibraryclassmembers</h3><p>指定不忽略非public类里面的成员和方法。ProGuard默认会忽略类库里非public类里的成员和方法，但是由于一些3.2.5里面的一些原因，应用程序里可能会用到这些，这时候就需要这个选项来指定不忽略它们。</p><h3 id="keepdirectories-directory-filter"><a href="#keepdirectories-directory-filter" class="headerlink" title="-keepdirectories [directory_filter]"></a>-keepdirectories [directory_filter]</h3><p>指定要保留在输出文件内的目录。默认情况下，目录会被移除。这会减少输出文件的大小，但如果你的代码引用到它们时可能会导致程序崩溃（如mypackage.MyCalss.class.getResource(“”)）。这时就需要指定-keepdirectories mypackage。-keepdirectories mydirectory匹配 mydirectory 目录；-keepdirectories mydirectory/<em>匹配 mydirectory 的直接子目录；-keepdirectorie mydirectory/*</em>匹配所有子目录，如果没有指定过滤器，所有目录会被保留。</p><h3 id="target-version"><a href="#target-version" class="headerlink" title="-target version"></a>-target version</h3><p>指定被处理class文件所使用的java版本，可选的有: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5 (or just 5), 1.6 (or just 6), 1.7 (or just 7), or 1.8 (or just 8).</p><h3 id="forceprocessing"><a href="#forceprocessing" class="headerlink" title="-forceprocessing"></a>-forceprocessing</h3><p>强制输出，即使输出文件已经是最新状态</p><h3 id="keep-modifier-…-class-specification"><a href="#keep-modifier-…-class-specification" class="headerlink" title="-keep [,modifier,…] class_specification"></a>-keep [,modifier,…] class_specification</h3><p>指定该类以及类的成员和方法为entry points，不被ProGuard混淆</p><h3 id="keepclassmembers-modifier-…-class-specification"><a href="#keepclassmembers-modifier-…-class-specification" class="headerlink" title="-keepclassmembers [,modifier,…] class_specification"></a>-keepclassmembers [,modifier,…] class_specification</h3><p>指定类的某些成员不被混淆，注意类名还是会被混淆，如：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-7-54.png" alt="2019-9-2-11-7-54.png"></p><h3 id="keepclasseswithmembers-modifier-…-class-specification"><a href="#keepclasseswithmembers-modifier-…-class-specification" class="headerlink" title="-keepclasseswithmembers [,modifier,…] class_specification"></a>-keepclasseswithmembers [,modifier,…] class_specification</h3><p>通过成员来指定哪些类不被混淆处理。比如可以用来保留包含main方法的类：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-8-32.png" alt="2019-9-2-11-8-32.png"></p><p>如果指定了多条规则，如下，那么必须同时包含sayHello和test两个方法的类才会被保留<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-8-47.png" alt="2019-9-2-11-8-47.png"></p><h3 id="keepnames-class-specification"><a href="#keepnames-class-specification" class="headerlink" title="-keepnames class_specification"></a>-keepnames class_specification</h3><p>-keepclassmembers,allowshrinking class_specification的别名，保留名称不被混淆，但可以被压缩</p><h3 id="keepclassmembernames-class-specification"><a href="#keepclassmembernames-class-specification" class="headerlink" title="-keepclassmembernames class_specification"></a>-keepclassmembernames class_specification</h3><p>-keepclasseswithmembers,allowshrinking class_specification的别名，保留名称不被混淆，但可以被压缩</p><h3 id="keepclasseswithmembernames-class-specification"><a href="#keepclasseswithmembernames-class-specification" class="headerlink" title="-keepclasseswithmembernames class_specification"></a>-keepclasseswithmembernames class_specification</h3><p>-keepclasseswithmembers,allowshrinking class_specification的别名</p><h3 id="printseeds-filename"><a href="#printseeds-filename" class="headerlink" title="-printseeds [filename]"></a>-printseeds [filename]</h3><p>把keep匹配的类和方法输出到文件中，可以用来验证自己设定的规则是否生效.</p><h3 id="dontshrink"><a href="#dontshrink" class="headerlink" title="-dontshrink"></a>-dontshrink</h3><p>指定不进行压缩.</p><h3 id="printusage-filename"><a href="#printusage-filename" class="headerlink" title="-printusage [filename]"></a>-printusage [filename]</h3><p>把没有使用的代码输出到文件中，方便查看哪些代码被压缩丢弃了。.</p><h3 id="dontoptimize"><a href="#dontoptimize" class="headerlink" title="-dontoptimize"></a>-dontoptimize</h3><p>指定不对输入代码进行优化处理。优化选项是默认打开的。</p><h3 id="optimizations"><a href="#optimizations" class="headerlink" title="-optimizations"></a>-optimizations</h3><p>指定混淆是采用的算法，后面的参数是一个过滤器，这个过滤器是谷歌推荐的算法，一般不做更改</p><h3 id="optimizationpasses-n"><a href="#optimizationpasses-n" class="headerlink" title="-optimizationpasses n"></a>-optimizationpasses n</h3><p>指定优化的级别，在0-7之间，默认为5.</p><h3 id="assumenosideeffects-class-specification"><a href="#assumenosideeffects-class-specification" class="headerlink" title="-assumenosideeffects class_specification"></a>-assumenosideeffects class_specification</h3><p>可以指定移除哪些方法没有副作用，如在android开发中，如想在release版本可以把所有log输出都移除，可以配置：</p><p> <img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-11-9-17.png" alt="2019-9-2-11-9-17.png"></p><p>那么所有log代码将会在优化阶段被去除。</p><h3 id="–dontobfuscate"><a href="#–dontobfuscate" class="headerlink" title="–dontobfuscate"></a>–dontobfuscate</h3><p>指定不进行混淆</p><h3 id="printmapping-filename"><a href="#printmapping-filename" class="headerlink" title="-printmapping [filename]"></a>-printmapping [filename]</h3><p>生成map文件，记录混淆前后的名称对应关系，注意，这个比较重要，因为混淆后运行的名称会变得不可读，只有依靠这个map文件来还原。</p><h3 id="applymapping-filename"><a href="#applymapping-filename" class="headerlink" title="-applymapping filename"></a>-applymapping filename</h3><p>主要是用来维持两次混淆公用一份mapping，确保相同的代码前后两次混淆后是一样的命名</p><h3 id="obfuscationdictionary-filename"><a href="#obfuscationdictionary-filename" class="headerlink" title="-obfuscationdictionary filename"></a>-obfuscationdictionary filename</h3><p>指定外部模糊字典</p><h3 id="classobfuscationdictionary-filename"><a href="#classobfuscationdictionary-filename" class="headerlink" title="-classobfuscationdictionary filename"></a>-classobfuscationdictionary filename</h3><p>指定class模糊字典.</p><h3 id="packageobfuscationdictionary-filename"><a href="#packageobfuscationdictionary-filename" class="headerlink" title="-packageobfuscationdictionary filename"></a>-packageobfuscationdictionary filename</h3><p>指定package模糊字典</p><h3 id="–useuniqueclassmembernames"><a href="#–useuniqueclassmembernames" class="headerlink" title="–useuniqueclassmembernames"></a>–useuniqueclassmembernames</h3><p>类和成员混淆的时候，使用唯一的名字</p><h3 id="dontusemixedcaseclassnames"><a href="#dontusemixedcaseclassnames" class="headerlink" title="-dontusemixedcaseclassnames"></a>-dontusemixedcaseclassnames</h3><p>不使用大小写混合类名，<strong>注意，windows用户必须为ProGuard指定该选项</strong>，因为windows对文件的大小写是不敏感的，也就是比如a.java和A.java会认为是同一个文件。如果不这样做并且你的项目中有超过26个类的话，那么ProGuard就会默认混用大小写文件名，导致class文件相互覆盖。</p><h3 id="keeppackagenames-package-filter"><a href="#keeppackagenames-package-filter" class="headerlink" title="-keeppackagenames [package_filter]"></a>-keeppackagenames [package_filter]</h3><p>保持packagename 不混淆</p><h3 id="flattenpackagehierarchy-package-name"><a href="#flattenpackagehierarchy-package-name" class="headerlink" title="-flattenpackagehierarchy [package_name]"></a>-flattenpackagehierarchy [package_name]</h3><p>指定重新打包,所有包重命名,这个选项会进一步模糊包名，将包里的类混淆成n个再重新打包到一个个的package中</p><h3 id="repackageclasses-package-name"><a href="#repackageclasses-package-name" class="headerlink" title="-repackageclasses [package_name]"></a>-repackageclasses [package_name]</h3><p>将包里的类混淆成n个再重新打包到一个统一的package中，会覆盖flattenpackagehierarchy选项</p><h3 id="keepattributes-attribute-filter"><a href="#keepattributes-attribute-filter" class="headerlink" title="-keepattributes [attribute_filter]"></a>-keepattributes [attribute_filter]</h3><p>混淆时可能被移除下面这些东西，如果想保留，需要用该选项，对于一般注解处理如 -keepattributes <em>Annotation</em>。</p><p>attribute_filter :</p><ul><li>Exceptions, </li><li>Signature, </li><li>Deprecated, </li><li>SourceFile, </li><li>SourceDir, </li><li>LineNumberTable,</li><li>LocalVariableTable, </li><li>LocalVariableTypeTable, </li><li>Synthetic,</li><li>#EnclosingMethod, </li><li>RuntimeVisibleAnnotations, </li><li>RuntimeInvisibleAnnotations, </li><li>RuntimeVisibleParameterAnnotations,</li><li>RuntimeInvisibleParameterAnnotations, </li><li>AnnotationDefault.</li></ul><h3 id="dontpreverify"><a href="#dontpreverify" class="headerlink" title="-dontpreverify"></a>-dontpreverify</h3><p>指定不执行预检</p><h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>把所有信息都输出，而不仅仅是输出出错信息</p><h3 id="dontnote-class-filter"><a href="#dontnote-class-filter" class="headerlink" title="-dontnote [class_filter]"></a>-dontnote [class_filter]</h3><p>不输出指定类的错误信息.</p><h3 id="dontwarn-class-filter"><a href="#dontwarn-class-filter" class="headerlink" title="-dontwarn [class_filter]"></a>-dontwarn [class_filter]</h3><p>不打印指定类的警告信息</p><h3 id="ignorewarnings"><a href="#ignorewarnings" class="headerlink" title="-ignorewarnings"></a>-ignorewarnings</h3><p>遇到警告的时候，忽略警告继续执行ProGuard，<strong>不建议添加此项</strong>。</p><h3 id="printconfiguration-filename"><a href="#printconfiguration-filename" class="headerlink" title="-printconfiguration [filename]"></a>-printconfiguration [filename]</h3><p>输出当前ProGuard所使用的配置</p><h3 id="dump-filename"><a href="#dump-filename" class="headerlink" title="-dump [filename]"></a>-dump [filename]</h3><p>指定输出所处理的类的结构</p><h1 id="反射的处理"><a href="#反射的处理" class="headerlink" title="反射的处理"></a>反射的处理</h1><p>在代码中，如果用到了反射，混淆会改变类和成员的名字，导致反射找不到相应的类或者方法，所以开发者在混淆的时候，必须把用到了反射的类保留，不进行混淆。一般而言，使用反射一般会有以下方式，可以搜索代码，找到相关的类，然后在混淆配置里面进行保留：</p><ul><li>Class.forName(“SomeClass”)</li><li>SomeClass.class</li><li>SomeClass.class.getField(“someField”)</li><li>SomeClass.class.getDeclaredField(“someField”)</li><li>SomeClass.class.getMethod(“someMethod”, new Class[] {})</li><li>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class })</li><li>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class })</li><li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {})</li><li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class })</li><li>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class })</li><li>AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”)</li><li>AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”)</li><li>AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># reflectClass类使用了反射，保留该类</span><br><span class="line">-keep class package.reflectClass &#123; *; &#125;</span><br></pre></td></tr></table></figure><h1 id="PrgGuard的基本使用demo"><a href="#PrgGuard的基本使用demo" class="headerlink" title="PrgGuard的基本使用demo"></a>PrgGuard的基本使用demo</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#代码混淆压缩比，在0~7之间，默认为5，一般不做修改</span><br><span class="line">-optimizationpasses 5</span><br><span class="line">#指定混淆是采用的算法，后面的参数是一个过滤器，这个过滤器是谷歌推荐的算法，一般不做更改</span><br><span class="line">-optimizations !code/simplification/cast,!field/*,!class/merging/*</span><br><span class="line"></span><br><span class="line">#混合时不使用大小写混合，混合后的类名为小写,windows下必须使用该选项</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"></span><br><span class="line">#指定不去忽略非公共库的类和成员</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line"></span><br><span class="line">#输出详细信息</span><br><span class="line">-verbose</span><br><span class="line">#输出类名-&gt;混淆后类名的映射关系</span><br><span class="line">-printmapping map.txt</span><br><span class="line"></span><br><span class="line">#不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。</span><br><span class="line">-dontpreverify</span><br><span class="line"></span><br><span class="line">#保留Annotation不混淆</span><br><span class="line">-keepattributes *Annotation*,InnerClasses</span><br><span class="line"></span><br><span class="line">#避免混淆泛型</span><br><span class="line">-keepattributes Signature</span><br><span class="line"></span><br><span class="line">#抛出异常时保留代码行号</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line"></span><br><span class="line">#保留本地native方法不被混淆</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留枚举类不被混淆</span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留Serializable序列化的类不被混淆</span><br><span class="line">-keepclassmembers class * implements java.io.Serializable &#123;</span><br><span class="line">    static final long serialVersionUID;</span><br><span class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream);</span><br><span class="line">    private void readObject(java.io.ObjectInputStream);</span><br><span class="line">    java.lang.Object writeReplace();</span><br><span class="line">    java.lang.Object readResolve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，由于Android平台在使用混淆的时候，还要特别注意要添加以下一些配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#保留我们使用的四大组件，自定义的Application等等这些类不被混淆</span><br><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Application</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.content.ContentProvider</span><br><span class="line">-keep public class * extends android.app.backup.BackupAgentHelper</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class * extends android.view.View</span><br><span class="line">-keep public class com.android.vending.licensing.ILicensingService</span><br><span class="line"></span><br><span class="line">#保留support下的所有类及其内部类</span><br><span class="line">-keep class android.support.** &#123;*;&#125;</span><br><span class="line"></span><br><span class="line">#保留R下面的资源</span><br><span class="line">-keep class **.R$* &#123;*;&#125;</span><br><span class="line"></span><br><span class="line">#保留在Activity中的方法参数是view的方法，</span><br><span class="line">-keepclassmembers class * extends android.app.Activity&#123;</span><br><span class="line">    public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留我们自定义控件（继承自View）不被混淆</span><br><span class="line">-keep public class * extends android.view.View&#123;</span><br><span class="line">    *** get*();</span><br><span class="line">    void set*(***);</span><br><span class="line">    public &lt;init&gt;(android.content.Context);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保留Parcelable序列化类不被混淆</span><br><span class="line">-keep class * implements android.os.Parcelable &#123;</span><br><span class="line">  public static final android.os.Parcelable$Creator *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#对于带有回调函数的onXXEvent的，不能被混淆</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    void *(**On*Event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#在我们的app中使用了webView需要进行特殊处理</span><br><span class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</span><br><span class="line">    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</span><br><span class="line">    public boolean *(android.webkit.WebView, java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</span><br><span class="line">    public void *(android.webkit.webView, jav.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 在app中与HTML5的JavaScript的交互进行特殊处理，如</span><br><span class="line"># package com.ljd.example;</span><br><span class="line">#</span><br><span class="line"># public class JSInterface &#123;</span><br><span class="line">#     @JavascriptInterface</span><br><span class="line">#     public void callAndroidMethod()&#123;</span><br><span class="line">#         // do something</span><br><span class="line">#     &#125;</span><br><span class="line"># &#125;</span><br><span class="line">#我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理</span><br><span class="line">-keepclassmembers class com.ljd.example.JSInterface &#123;</span><br><span class="line">    &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#内嵌类经常被混淆，结果在调用的时候就崩溃了，如果需要保留内嵌类，则用以下方法来保留内嵌类，如暴力MyClass里面的内嵌类，$就是用来分割内嵌类和母体的标志</span><br><span class="line">-keep class com.test.MyClass$* &#123;*;&#125;</span><br><span class="line">#-----------以下处理反射类---------------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ProGuard简介和工作流程&quot;&gt;&lt;a href=&quot;#ProGuard简介和工作流程&quot; class=&quot;headerlink&quot; title=&quot;ProGuard简介和工作流程&quot;&gt;&lt;/a&gt;ProGuard简介和工作流程&lt;/h1&gt;&lt;p&gt;ProGuard能够通过压缩、优化、混淆、预检等操作，检测并删除未使用的类,字段,方法和属性，分析和优化字节码，使用简短无意义的名称来重命名类，字段和方法。从而使代码更小、更高效、更难进行逆向工程。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-59-30.png&quot; alt=&quot;2019-9-2-10-59-30.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图就是ProGuard的工作流程，分别会经过四个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;压缩（Shrink）&lt;/code&gt;:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;优化（Optimize）&lt;/code&gt;:在优化处理这一步中，对字节码进行优化，并且移除无用指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;混淆（Obfuscate）&lt;/code&gt;:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;预检（Preveirfy）&lt;/code&gt;:在预检这一步中，主要是在Java平台上对处理后的代码进行预检&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上四个步骤都是&lt;strong&gt;可选&lt;/strong&gt;的，我们可以通过配置脚本来决定其中的哪几个步骤。比如我们可以配置只压缩和混淆，不进行优化，不进行预检。&lt;br&gt;ProGuard的官网有使用指导：&lt;a href=&quot;http://proguard.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://proguard.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="java代码混淆" scheme="http://blog.hanschen.site/tags/java%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
      <category term="PrgGuard" scheme="http://blog.hanschen.site/tags/PrgGuard/"/>
    
      <category term="Android混淆" scheme="http://blog.hanschen.site/tags/Android%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>Lua和C交互的简易教程</title>
    <link href="http://blog.hanschen.site/2016/09/07/lua-and-c/"/>
    <id>http://blog.hanschen.site/2016/09/07/lua-and-c/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua栈"><a href="#Lua栈" class="headerlink" title="Lua栈"></a>Lua栈</h1><p>要理解Lua和C++交互，首先要理解Lua堆栈。简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出</p><p>在Lua中，Lua堆栈就是一个struct，堆栈索引的方式可是是正数也可以是负数，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶,如图：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-56-15.png" alt="2019-9-2-10-56-15.png"></p><p>入栈的数据类型包括数值, 字符串, 指针, talbe, 闭包等, 下面是一个栈的例子:<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-56-27.png" alt="2019-9-2-10-56-27.png"></p><a id="more"></a><p>执行下面的代码就可以让你的lua栈上呈现图中的情况:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并压入一个闭包</span></span><br><span class="line">lua_pushcclosure(L, func, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建并压入一个表</span></span><br><span class="line">lua_createtable(L, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入一个数字</span></span><br><span class="line">lua_pushnumber(L, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入一个字符串</span></span><br><span class="line">lua_pushstring(L, <span class="string">"hello，lua"</span>);</span><br></pre></td></tr></table></figure><p>这里要说明的是, 你压入的类型有数值, 字符串, 表和闭包[在c中看来是不同类型的值], 但是最后都是统一用TValue这种数据结构来保存的,下面用图简单的说明一下这种数据结构:<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-56-39.png" alt="2019-9-2-10-56-39.png"></p><p>TValue结构对应于lua中的所有数据类型, 是一个{值, 类型} 结构,这就lua中动态类型的实现, 它把值和类型绑在一起, 用tt记录value的类型, value是一个联合结构, 由Value定义, 可以看到这个联合有四个域, 先说明简单的</p><ul><li>p – 可以存一个指针, 实际上是lua中的light userdata结构</li><li>n – 所有的数值存在这里, 不过是int , 还是float</li><li>b – Boolean值存在这里, 注意, lua_pushinteger不是存在这里, 而是存在n中, b只存布尔</li><li>gc – 其他诸如table, thread, closure,string需要内存管理垃圾回收的类型都存在这里,gc是一个指针, 它可以指向的类型由联合体GCObject定义, 从图中可以看出, 有string, userdata, closure, table, proto, upvalue, thread</li></ul><p>可以的得出如下结论:</p><ol><li>lua中, number, boolean, nil, light userdata四种类型的值是直接存在栈上元素里的, 和垃圾回收无关.</li><li>lua中, string, table, closure, userdata, thread存在栈上元素里的只是指针, 他们都会在生命周期结束后被垃圾回收.</li></ol><h1 id="堆栈的操作"><a href="#堆栈的操作" class="headerlink" title="堆栈的操作"></a>堆栈的操作</h1><p>因为Lua与C/C++是通过栈来通信，我们先来看一个最简单的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../lua/lauxlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建一个state</span></span><br><span class="line">    lua_State *L = luaL_newstate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.入栈操作</span></span><br><span class="line">    lua_pushstring(L, <span class="string">"I am so cool~"</span>);</span><br><span class="line">    lua_pushnumber(L, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.取值操作</span></span><br><span class="line">    <span class="keyword">if</span> (lua_isstring(L, <span class="number">1</span>)) &#123; <span class="comment">//这里的index也可以是-2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[line:%d] lua_tostring(L, 1):%s\n"</span>, __LINE__, lua_tostring(L, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lua_isnumber(L, <span class="number">2</span>)) &#123; <span class="comment">//这里的index也可以是-1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[line:%d] lua_tonumber(L, 2):%f\n"</span>, __LINE__, lua_tonumber(L, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.关闭state</span></span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他一些栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回栈顶索引（即栈长度）  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_gettop</span> <span class="params">(lua_State *L)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将栈顶设置为一个指定的位置，即修改栈中元素的数量。如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，则原栈高出的部分舍弃。所以可以用lua_settop(0)来清空栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_settop</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一个元素到栈顶，值与index位置的值相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushvalue</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除idx索引上的值，高于index的元素的索引将全部-1  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_remove</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈顶元素挪到index位置，原index位置的元素往栈顶移动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_insert</span><span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈顶元素挪到index位置，并删除原index位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_replace</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="C调用Lua"><a href="#C调用Lua" class="headerlink" title="C调用Lua"></a>C调用Lua</h1><p>现在有这样一个hello.lua 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"Hello, Lua !"</span></span><br><span class="line">table = &#123;name = <span class="string">"hans"</span>, id = <span class="number">123456</span>&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y)</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们写一个main.c来读取它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../lua/lauxlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">lua_State *<span class="title">load_lua</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    lua_State *L = luaL_newstate();</span><br><span class="line">    luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载脚本并运行</span></span><br><span class="line">    <span class="keyword">if</span> (luaL_loadfile(L, filename) || lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"load Lua script failed: %s\n"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* lua_filename = <span class="string">"E:\\work\\luaJni\\resource\\test.lua"</span>;</span><br><span class="line">    lua_State *L = load_lua(lua_filename);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == L) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取变量</span></span><br><span class="line">    lua_getglobal(L, <span class="string">"str"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[line:%d] luaV_tostring(L, -1):%s\n"</span>, __LINE__, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取table</span></span><br><span class="line">    lua_getglobal(L, <span class="string">"table"</span>);</span><br><span class="line">    lua_getfield(L, <span class="number">-1</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[line:%d] lua_tostring(L,-1);:%s\n"</span>, __LINE__, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用函数</span></span><br><span class="line">    lua_getglobal(L, <span class="string">"add"</span>); <span class="comment">//读取函数到栈顶</span></span><br><span class="line">    lua_pushnumber(L, <span class="number">10</span>); <span class="comment">//压入参数</span></span><br><span class="line">    lua_pushnumber(L, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lua_pcall failed: %s\n"</span>, lua_tostring(L, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = lua_tonumber(L, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[line:%d] result:%d\n"</span>, __LINE__, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//至此，栈中的情况是：</span></span><br><span class="line">    <span class="comment">//=================== 栈顶 ===================</span></span><br><span class="line">    <span class="comment">//  索引  类型      值</span></span><br><span class="line">    <span class="comment">//   4   int：      30</span></span><br><span class="line">    <span class="comment">//   3   string：   hans</span></span><br><span class="line">    <span class="comment">//   2   table:     table</span></span><br><span class="line">    <span class="comment">//   1   string:    Hello, Lua !</span></span><br><span class="line">    <span class="comment">//=================== 栈底 ===================</span></span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道怎么读取后，我们来看下如何修改上面代码中table的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将需要设置的值设置到栈中  </span></span><br><span class="line">lua_pushstring(L, <span class="string">"Hello，hahaha"</span>);  </span><br><span class="line"><span class="comment">//将这个值设置到table中（此时table在栈的位置为2）  </span></span><br><span class="line">lua_setfield(L, <span class="number">2</span>, <span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><p>我们还可以新建一个table：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的table，并压入栈  </span></span><br><span class="line">lua_newtable(L);  </span><br><span class="line"><span class="comment">//往table中设置值  </span></span><br><span class="line">lua_pushstring(L, <span class="string">"hello, new table !"</span>); <span class="comment">//将值压入栈  </span></span><br><span class="line">lua_setfield(L, <span class="number">-2</span>, <span class="string">"str"</span>); <span class="comment">//将值设置到table中，并将hello, new table !出栈</span></span><br></pre></td></tr></table></figure><p>需要注意的是：栈操作是基于栈顶的，就是说它只会去操作栈顶的值。<br>举个比较简单的例子，函数调用流程是先将函数入栈，参数入栈，然后用lua_pcall调用函数，此时栈顶为参数，栈底为函数，所以栈过程大致会是：参数出栈-&gt;保存参数-&gt;函数出栈-&gt;调用函数-&gt;返回结果入栈</p><p>类似的还有lua_setfield，设置一个表的值，肯定要先将值出栈，保存，再去找表的位置</p><h1 id="Lua调用C"><a href="#Lua调用C" class="headerlink" title="Lua调用C"></a>Lua调用C</h1><p>我们可以加入我们自己的函数。函数要遵循规范（可在lua.h中查看）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用Lua栈作为参数，所以它可以从栈里面读取任意数量和任意类型的参数。而这个函数的返回值则表示函数返回时有多少返回值被压入Lua栈</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*lua_CFunction)</span> <span class="params">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--lua_call_c.lua</span></span><br><span class="line">a, b = getTwoVar(<span class="string">'hello, this string is from lua world'</span>, <span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义在lua中可调用的函数，要遵循规范：返回值必须为int，需传入lua_State</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoVar</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dumpStack(L);</span><br><span class="line">    <span class="comment">//    =================== 栈顶 ===================</span></span><br><span class="line">    <span class="comment">//    index     type         value</span></span><br><span class="line">    <span class="comment">//    2         number       123.000000</span></span><br><span class="line">    <span class="comment">//    1         string       hello, this string is from lua world</span></span><br><span class="line">    <span class="comment">//    =================== 栈底 ===================</span></span><br><span class="line">    lua_pushnumber(L, <span class="number">10</span>);</span><br><span class="line">    lua_pushstring(L, <span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_call_c</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* lua_filename = <span class="string">"E:\\work\\luaJni\\resource\\lua_call_c.lua"</span>;</span><br><span class="line">    lua_State *L = load_lua(lua_filename, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == L) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_register(L, <span class="string">"getTwoVar"</span>, getTwoVar);</span><br><span class="line">    lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用dll动态链接的方式，把c实现的代码打包成dll<br>h文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span>  </span></span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LUA_EXPORTS  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_API __declspec(dllexport)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_API __declspec(dllimport)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">LUA_API <span class="keyword">int</span> <span class="title">luaopen_mLualib</span><span class="params">(lua_State *L)</span></span>;<span class="comment">//定义导出函数</span></span><br></pre></td></tr></table></figure><p>C文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mLualib.h"</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">averageFunc</span><span class="params">(lua_State *L)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = lua_gettop(L);  </span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 循环求参数之和 */</span>  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">        sum += lua_tonumber(L, i);  </span><br><span class="line">   </span><br><span class="line">    lua_pushnumber(L, sum / n);     <span class="comment">//压入平均值  </span></span><br><span class="line">    lua_pushnumber(L, sum);         <span class="comment">//压入和  </span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;                       <span class="comment">//返回两个结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sayHelloFunc</span><span class="params">(lua_State* L)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">myLib</span>[] =   </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    &#123;<span class="string">"average"</span>, averageFunc&#125;,  </span><br><span class="line">    &#123;<span class="string">"sayHello"</span>, sayHelloFunc&#125;,  </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;       <span class="comment">//数组中最后一对必须是&#123;NULL, NULL&#125;，用来表示结束      </span></span><br><span class="line">&#125;;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_mLualib</span><span class="params">(lua_State *L)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    luaL_register(L, <span class="string">"ss"</span>, myLib);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">// 把myLib表压入了栈中，所以就需要返回1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lua中我们这样子来调用（调用之前记得把dll文件复制到lua文件目录下）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"mylib"</span>  </span><br><span class="line"><span class="keyword">local</span> ave,sum = ss.average(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">-- 参数对应堆栈中的数据  </span></span><br><span class="line"><span class="built_in">print</span>(ave,sum)  <span class="comment">-- 3 15  </span></span><br><span class="line">ss.sayHello()   <span class="comment">-- hello world!</span></span><br></pre></td></tr></table></figure><p>至此都发生了什么呢？梳理一下：</p><ol><li>我们编写了averageFunc求平均值和sayHelloFunc函数</li><li>然后把函数封装myLib数组里面，类型必须是luaL_Reg</li><li>由luaopen_mLualib函数导出并在lua中注册这两个函数</li></ol><p>实际上当我们在Lua中：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"mLualib"</span></span><br></pre></td></tr></table></figure><p>这样子写的时候，Lua会这么干：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">"mLualib.dll"</span>    </span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">package</span>.<span class="built_in">loadlib</span>(<span class="built_in">path</span>,<span class="string">"luaopen_mLualib"</span>)   <span class="comment">-- 返回luaopen_mLualib函数 </span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure><p>所以当我们在编写一个这样的模块的时候，编写luaopen_xxx导出函数的时候，xxx最好是和项目名一样</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Lua和C++是通过一个虚拟栈来交互的。</li><li>C调用Lua实际上是：由C先把数据放入栈中，由Lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回C</li><li>Lua调C也一样：先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数</li></ul><p>本文不涉及lua语法学习，如果有需要，请移步：<a href="http://book.luaer.cn/" target="_blank" rel="noopener">http://book.luaer.cn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lua栈&quot;&gt;&lt;a href=&quot;#Lua栈&quot; class=&quot;headerlink&quot; title=&quot;Lua栈&quot;&gt;&lt;/a&gt;Lua栈&lt;/h1&gt;&lt;p&gt;要理解Lua和C++交互，首先要理解Lua堆栈。简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出&lt;/p&gt;
&lt;p&gt;在Lua中，Lua堆栈就是一个struct，堆栈索引的方式可是是正数也可以是负数，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶,如图：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-56-15.png&quot; alt=&quot;2019-9-2-10-56-15.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;入栈的数据类型包括数值, 字符串, 指针, talbe, 闭包等, 下面是一个栈的例子:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-56-27.png&quot; alt=&quot;2019-9-2-10-56-27.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://blog.hanschen.site/categories/Lua/"/>
    
    
      <category term="lua" scheme="http://blog.hanschen.site/tags/lua/"/>
    
      <category term="lua和c交互" scheme="http://blog.hanschen.site/tags/lua%E5%92%8Cc%E4%BA%A4%E4%BA%92/"/>
    
      <category term="lua和c" scheme="http://blog.hanschen.site/tags/lua%E5%92%8Cc/"/>
    
  </entry>
  
  <entry>
    <title>Lua快速入门</title>
    <link href="http://blog.hanschen.site/2016/08/30/lua-guide/"/>
    <id>http://blog.hanschen.site/2016/08/30/lua-guide/</id>
    <published>2016-08-29T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Lua"><a href="#什么是Lua" class="headerlink" title="什么是Lua"></a>什么是Lua</h1><p>Lua 是一门强大、快速、轻量的嵌入式脚本语言。它由巴西里约热内卢 Pontifical Catholic 大学的 PUC-Rio 团队 开发。 Lua 是一个 自由软件， 广泛应用于世界上无数产品和项目</p><p>应用场景：</p><ul><li>游戏开发 </li><li>独立应用脚本 </li><li>Web 应用脚本 </li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li></ul><a id="more"></a><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>单行注释:两个减号是单行注释</li><li>多行注释：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这是一个单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> --]]</span></span><br></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Lua表示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母、下划线、数字（0到9）。<strong>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的</strong>。Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 W3c 与 w3c 是两个不同的标示符</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>       <span class="keyword">break</span>     <span class="keyword">do</span>          <span class="keyword">else</span>      <span class="keyword">elseif</span>    <span class="keyword">end</span></span><br><span class="line"><span class="literal">false</span>     <span class="keyword">for</span>       <span class="function"><span class="keyword">function</span>    <span class="title">goto</span>      <span class="title">if</span>        <span class="title">in</span></span></span><br><span class="line"><span class="function"><span class="title">local</span>     <span class="title">nil</span>       <span class="title">not</span>         <span class="title">or</span>        <span class="title">repeat</span>    <span class="title">return</span></span></span><br><span class="line"><span class="function"><span class="title">then</span>      <span class="title">true</span>      <span class="title">until</span>       <span class="title">while</span></span></span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li>nil：只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）</li><li>boolean：包含两个值：false和true</li><li>number：有两种内部表现方式，整数和浮点数。标准Lua使用 64 位整数和双精度<br>（64位）浮点数</li><li>string：string表示一个不可变的字节序列，由一对双引号或单引号来表示</li><li>function：由C或Lua编写的函数</li><li>userdata：表示任意存储在变量中的C数据结构</li><li>thread：表示执行的独立线路，用于执行协同程序</li><li>table：Lua 中的表（table）其实是一个”关联数组”（associative arrays），这个数组不仅仅以数字做索引，<strong>除了nil和NaN之外的所有Lua值都可以做索引</strong>。 （Not a Number是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 0/0），也就是说，表内可以包含任何类型的值（ nil 除外）。任何键的值若为nil 就不会被记入表结构内部。table的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表</li></ul><blockquote><p>表、函数、线程、以及完全用户数据在 Lua 中被称为 对象： 变量并不真的持有 它们的值，而仅保存了对这些对象的引用。赋值、参数传递、函数返回，都是针对引用而不是针对值的操作</p></blockquote><p>我们可以使用<strong>type</strong>函数测试给定变量或者值的类型：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">"Hello world"</span>))      <span class="comment">--&gt; string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))             <span class="comment">--&gt; number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))              <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))               <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))               <span class="comment">--&gt; boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))            <span class="comment">--&gt; string</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Lua 变量有三种类型：<strong>全局变量、局部变量、表中的域</strong>。</p><p>除非用local显示声明为局部变量，否则Lua中的变量全是全局变量，哪怕是语句块或是函数里。<br>局部变量的作用域为从声明位置开始到所在语句块结束。<br>变量的默认值均为 nil。</p><p>应该<strong>尽可能的使用局部变量</strong>，有两个好处：</p><ul><li>避免命名冲突</li><li>访问局部变量的速度比全局变量更快</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件脚本</span></span><br><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br></pre></td></tr></table></figure><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>赋值是改变一个变量的值和改变表域的最基本的方法</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"hello"</span> .. <span class="string">"world"</span> <span class="comment">--字符串拼接</span></span><br><span class="line">t.n = t.n + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x       &lt;<span class="comment">--&gt;       a=10; b=2*x</span></span><br></pre></td></tr></table></figure><p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x                     <span class="comment">-- swap 'x' for 'y'</span></span><br><span class="line">a[i], a[j] = a[j], a[i]         <span class="comment">-- swap 'a[i]' for 'a[j]'</span></span><br></pre></td></tr></table></figure><p>当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略:</p><ul><li>变量个数 &gt; 值的个数: 按变量个数补足nil</li><li>变量个数 &lt; 值的个数: 多余的值会被忽略</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)             <span class="comment">--&gt; 0   1   nil</span></span><br><span class="line"> </span><br><span class="line">a, b = a+<span class="number">1</span>, b+<span class="number">1</span>, b+<span class="number">2</span>     <span class="comment">-- value of b+2 is ignored</span></span><br><span class="line"><span class="built_in">print</span>(a,b)               <span class="comment">--&gt; 1   2</span></span><br><span class="line"> </span><br><span class="line">a, b, c = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)             <span class="comment">--&gt; 0   nil   nil</span></span><br></pre></td></tr></table></figure><p>多值赋值经常用来交换变量，或将函数调用返回给变量:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = f()     <span class="comment">-- f()返回两个值，第一个赋给a，第二个赋给b</span></span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>基本语法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 举例</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">while</span>( a &lt; <span class="number">20</span> )</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为:"</span>, a)</span><br><span class="line">   a = a+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="数值for循环："><a href="#数值for循环：" class="headerlink" title="数值for循环："></a>数值for循环：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次"执行体"。exp3是可选的，如果不指定，默认为1</span></span><br><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">--举例</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, f(<span class="number">5</span>) <span class="keyword">do</span> <span class="comment">--f(x)只在循环开始前求值一次</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="泛型for循环"><a href="#泛型for循环" class="headerlink" title="泛型for循环"></a>泛型for循环</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> K, v <span class="keyword">in</span> <span class="built_in">pairs</span>/<span class="built_in">ipairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(v) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>根据官方手册的描述，pairs会遍历表中所有的key-value值，而ipairs会根据key的数值从1开始加1递增遍历对应的table[i]值，直到table[i]的值是nil的时候就退出。</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stars = &#123;[<span class="number">1</span>] = <span class="string">"Sun"</span>, [<span class="number">2</span>] = <span class="string">"Moon"</span>, [<span class="number">5</span>] = <span class="string">'Earth'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(stars) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1    Sun</span></span><br><span class="line"><span class="comment">2    Moon</span></span><br><span class="line"><span class="comment">5    Earth</span></span><br><span class="line"><span class="comment"> --]]</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(stars) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1    Sun</span></span><br><span class="line"><span class="comment">2    Moon</span></span><br><span class="line"><span class="comment">因为stars[3]是nil</span></span><br><span class="line"><span class="comment"> --]]</span></span><br></pre></td></tr></table></figure><h3 id="repeat…until-循环"><a href="#repeat…until-循环" class="headerlink" title="repeat…until 循环"></a>repeat…until 循环</h3><p>repeat…until 是条件后行,所以repeat…until 的循环体里面至少要运行一次<br>基本语法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">while</span>( condition )</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[ 变量定义 --]</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment">--[ 执行循环 --]</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a的值为:"</span>, a)</span><br><span class="line">   a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>( a &gt; <span class="number">15</span> )</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a的值为:<span class="number">10</span></span><br><span class="line">a的值为:<span class="number">11</span></span><br><span class="line">a的值为:<span class="number">12</span></span><br><span class="line">a的值为:<span class="number">13</span></span><br><span class="line">a的值为:<span class="number">14</span></span><br><span class="line">a的值为:<span class="number">15</span></span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>基本语法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">3</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 3 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。</p><p>Lua 函数主要有两种用途：</p><ul><li>完成指定的任务，这种情况下函数作为调用语句使用</li><li>计算并返回值，这种情况下函数作为赋值语句的表达式使用</li></ul><p>Lua 编程语言函数定义格式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">function_body</span><br><span class="line"><span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>optional_function_scope:该参数是可选的制定函数是全局函数还是局部函数，未设置该参数末尾为全局函数，如果你需要设置函数为局部函数需要使用关键字 local</li><li>function_name:函数名称</li><li>函数参数：多个参数以逗号隔开，函数也可以不带参数</li><li>函数返回值：Lua语言函数可以返回多个值，每个值以逗号隔开</li></ul><p>Lua中，函数是first class，我们可以将函数作为参数传递给函数，如下实例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myprint = <span class="function"><span class="keyword">function</span><span class="params">(param)</span></span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"这是打印函数 -   ##"</span>,param,<span class="string">"##"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2,functionPrint)</span></span></span><br><span class="line">   result = num1 + num2</span><br><span class="line">   <span class="comment">-- 调用传递的函数参数</span></span><br><span class="line">   functionPrint(result)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- myprint 函数作为参数传递</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,myprint)</span><br></pre></td></tr></table></figure><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Lua函数中，在return后列出要返回的值得列表即可返回多值，如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">value, key = maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(key) <span class="comment">--输出3</span></span><br><span class="line"><span class="built_in">print</span>(value) <span class="comment">--输出23</span></span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（…)表示函数有可变的参数</p><p>Lua将函数的<strong>参数放在一个叫arg的表中，#arg 表示传入参数的个数</strong>。<br>例如，我们计算几个数的平均值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"总共传入 "</span> .. #<span class="built_in">arg</span> .. <span class="string">" 个数"</span>)</span><br><span class="line">   <span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"平均值为: "</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="http://static.zybuluo.com/shensky711/w5nhny62w7k5efa38v4zvwbu/image_1arcmmj32ich15tbi15ht016ko9.png" alt="image_1arcmmj32ich15tbi15ht016ko9.png-28kB"></p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p><img src="http://static.zybuluo.com/shensky711/i2fa472zkti56hjbrld7jz4a/image_1arcmnu3be3q1nk71nfo1d1ls24m.png" alt="image_1arcmnu3be3q1nk71nfo1d1ls24m.png-39.8kB"></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><img src="http://static.zybuluo.com/shensky711/m1mbi522idtva70wqn7v40g1/image_1arcmp39u3e012rs8bu1vk3vfe13.png" alt="image_1arcmp39u3e012rs8bu1vk3vfe13.png-26.5kB"></p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p><img src="http://static.zybuluo.com/shensky711/g5c00bkwr1jptlj76knubq9v/image_1arcmpptot0s1a611bqd13s21b431g.png" alt="image_1arcmpptot0s1a611bqd13s21b431g.png-18.5kB"></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line"><span class="keyword">not</span>    - (unary)</span><br><span class="line">*      /</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br></pre></td></tr></table></figure><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>不同于其他语言的数组把 0 作为数组的初始索引，<strong>在 Lua 里表的默认初始索引一般以 1 开始</strong><br>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空的 table</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 直接初始表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化的时候设置key,注意，key不需要带引号，且初始化的时候不能以数字作为key</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;apple = <span class="string">"apple"</span>, pear = <span class="string">"pear"</span>, orange = <span class="string">"orange"</span>, grape = <span class="string">"grape"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--可以通过table[i]、table['key']、table.key的方式访问数据</span></span><br></pre></td></tr></table></figure><p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">"key"</span>] = <span class="string">"value"</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line">a[key] = a[key] + <span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" : "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Lua&quot;&gt;&lt;a href=&quot;#什么是Lua&quot; class=&quot;headerlink&quot; title=&quot;什么是Lua&quot;&gt;&lt;/a&gt;什么是Lua&lt;/h1&gt;&lt;p&gt;Lua 是一门强大、快速、轻量的嵌入式脚本语言。它由巴西里约热内卢 Pontifical Catholic 大学的 PUC-Rio 团队 开发。 Lua 是一个 自由软件， 广泛应用于世界上无数产品和项目&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏开发 &lt;/li&gt;
&lt;li&gt;独立应用脚本 &lt;/li&gt;
&lt;li&gt;Web 应用脚本 &lt;/li&gt;
&lt;li&gt;扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench&lt;/li&gt;
&lt;li&gt;安全系统，如入侵检测系统&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://blog.hanschen.site/categories/Lua/"/>
    
    
      <category term="lua" scheme="http://blog.hanschen.site/tags/lua/"/>
    
      <category term="lua语法介绍" scheme="http://blog.hanschen.site/tags/lua%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    
      <category term="lua入门" scheme="http://blog.hanschen.site/tags/lua%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android最大方法数和解决方案</title>
    <link href="http://blog.hanschen.site/2016/08/26/Android-64k-issue/"/>
    <id>http://blog.hanschen.site/2016/08/26/Android-64k-issue/</id>
    <published>2016-08-25T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是64K限制和LinearAlloc限制"><a href="#什么是64K限制和LinearAlloc限制" class="headerlink" title="什么是64K限制和LinearAlloc限制"></a>什么是64K限制和LinearAlloc限制</h1><h2 id="64K限制"><a href="#64K限制" class="headerlink" title="64K限制"></a>64K限制</h2><p>随着Android应用功能的增加，代码量不断地增大，当应用方法数量超过了65536的时候，编译的时候便会提示：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-54-5.png" alt="2019-9-2-10-54-5.png"></p><p>这个Android著名的Dex 64k method数量上限。那么，是什么原因导致方法数不能超过64K呢？网上搜集了一下资料，原因一般有：</p><ol><li><strong>DexOpt优化的限制</strong>：当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。但是在早期的Android系统中，DexOpt有一个问题，也就是这篇文章想要说明并解决的问题。DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对老系统做兼容</li><li><strong>dalvik bytecode的限制</strong>：因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能引用 65535 个方法，参考链接：<a href="http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160，http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="noopener">http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160，http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html</a></li></ol><p>鉴于以上原因，在打包Android应用的时候，会对方法数做一个检测，当方法数超过了DexFormat.MAX_MEMBER_IDX（定义为0Xffff, 注意，这个<strong>不是Dex文件格式的限制</strong>，Dex文件中存储方法ID用的并不是short类型，无论最新的DexFile.h新定义的u4是uint32_t，还是老版本DexFile引用的vm/Common.h里定义的u4是uint32或者unsigned int，都不是short类型，特此说明）便报错</p><a id="more"></a><h2 id="LinearAlloc限制"><a href="#LinearAlloc限制" class="headerlink" title="LinearAlloc限制"></a>LinearAlloc限制</h2><p>即使方法数没有超过65536，能正常编译打包成apk，在安装的时候，也有可能会提示INSTALL_FAILED_DEXOPT而导致安装失败，这个一般就是因为LinearAlloc的限制导致的。这个主要是因为Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃</p><h1 id="谷歌分包方案"><a href="#谷歌分包方案" class="headerlink" title="谷歌分包方案"></a>谷歌分包方案</h1><p>谷歌提供了一个multiDex的分包方案，当方法数超过65536的时候，生成多个dex文件，把应用启动时必须用到的类和该类的直接引用类放到main dex中，把其他类放到second dex中。当应用启动之后，动态加载second dex，从而避免64k问题。使用Android Studio很容易实现分包方案：<br><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-54-23.png" alt="2019-9-2-10-54-23.png"></p><ol><li>在build.gradle中添加：multiDexEnabled true</li><li>加入依赖‘compile ‘com.android.support:multidex:1.0.1’’</li><li>让应用的Application类直接使用或者继承MultiDexApplication</li><li>如果你想使用自定义的Application，又不想继承MultiDexApplication，那么可以在attachBaseContext方法里执行MultiDex.install(base)</li></ol><p>以上就是谷歌multiDex方案所需做的设置，通过配置multiDex，便可解决64k方法数限制</p><h1 id="谷歌multiDex存在的问题"><a href="#谷歌multiDex存在的问题" class="headerlink" title="谷歌multiDex存在的问题"></a>谷歌multiDex存在的问题</h1><p>虽然谷歌的分包方案很简单，但是效果并不是那么好，谷歌本身也枚举了分包方案的<strong>缺点</strong>：</p><ol><li>如果在主线程中执行MultiDex.install，加载second dex，因为加载从dex是同步的，会阻塞线程，second dex太大的话，有可能导致ANR</li><li>API Level 14之前，由于Dalvik LinearAlloc bug（问题22586，就是上文提到的LinearAlloc问题），很可能会出问题的</li><li>应用程序使用了multiedex配置的，会造成使用比较大的内存</li><li>对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法</li></ol><h1 id="如何解决谷歌分包方案的问题"><a href="#如何解决谷歌分包方案的问题" class="headerlink" title="如何解决谷歌分包方案的问题"></a>如何解决谷歌分包方案的问题</h1><p>针对上面的问题，参考网上的一些解决方案，如美团、facebook、微信等，初步使用的解决方法如下：</p><ol><li>第一次启动的时候，检测到未曾加载过second dex，那么启动欢迎页面（启动新的进程，原来进程进入阻塞等待，注意，此时不会发生ANR，因为已经不是前台进程了），在欢迎页面里面进行second dex的加载，加载完成后通知主线程继续</li><li>设定单个dex文件最大方法数为48000（经验值）而不是65536，避免内存问题</li><li>同上</li><li>控制程序逻辑，未曾加载完second dex之前，进入阻塞等待，直到加载完程序才往下走</li></ol><p>下面是流程图：</p><p><img src="https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-54-35.png" alt="2019-9-2-10-54-35.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是64K限制和LinearAlloc限制&quot;&gt;&lt;a href=&quot;#什么是64K限制和LinearAlloc限制&quot; class=&quot;headerlink&quot; title=&quot;什么是64K限制和LinearAlloc限制&quot;&gt;&lt;/a&gt;什么是64K限制和LinearAlloc限制&lt;/h1&gt;&lt;h2 id=&quot;64K限制&quot;&gt;&lt;a href=&quot;#64K限制&quot; class=&quot;headerlink&quot; title=&quot;64K限制&quot;&gt;&lt;/a&gt;64K限制&lt;/h2&gt;&lt;p&gt;随着Android应用功能的增加，代码量不断地增大，当应用方法数量超过了65536的时候，编译的时候便会提示：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shensky711/Pictures/master/2019-9-2-10-54-5.png&quot; alt=&quot;2019-9-2-10-54-5.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个Android著名的Dex 64k method数量上限。那么，是什么原因导致方法数不能超过64K呢？网上搜集了一下资料，原因一般有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;DexOpt优化的限制&lt;/strong&gt;：当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。但是在早期的Android系统中，DexOpt有一个问题，也就是这篇文章想要说明并解决的问题。DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对老系统做兼容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dalvik bytecode的限制&lt;/strong&gt;：因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能引用 65535 个方法，参考链接：&lt;a href=&quot;http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160，http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160，http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;鉴于以上原因，在打包Android应用的时候，会对方法数做一个检测，当方法数超过了DexFormat.MAX_MEMBER_IDX（定义为0Xffff, 注意，这个&lt;strong&gt;不是Dex文件格式的限制&lt;/strong&gt;，Dex文件中存储方法ID用的并不是short类型，无论最新的DexFile.h新定义的u4是uint32_t，还是老版本DexFile引用的vm/Common.h里定义的u4是uint32或者unsigned int，都不是short类型，特此说明）便报错&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.hanschen.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.hanschen.site/tags/Android/"/>
    
      <category term="multidex" scheme="http://blog.hanschen.site/tags/multidex/"/>
    
      <category term="最大方法数" scheme="http://blog.hanschen.site/tags/%E6%9C%80%E5%A4%A7%E6%96%B9%E6%B3%95%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Makefile使用指南</title>
    <link href="http://blog.hanschen.site/2016/08/17/makefile/"/>
    <id>http://blog.hanschen.site/2016/08/17/makefile/</id>
    <published>2016-08-16T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h1><p>Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，文件之间有哪些依赖等。Makefile有自己的书写格式、关键字、函数。像C 语言有自己的格式、关键字和函数一样。而且在Makefile中可以使用系统shell所提供的任何命令来完成想要的工作。<br>Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率</p><h1 id="makefile的文件名"><a href="#makefile的文件名" class="headerlink" title="makefile的文件名"></a>makefile的文件名</h1><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p><p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -f Make.Linux</span><br><span class="line">make --file Make.AIX</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h1><h2 id="显示规则"><a href="#显示规则" class="headerlink" title="显示规则"></a>显示规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br></pre></td></tr></table></figure><ul><li>target：要生成的目标，也可以是一个标签</li><li>prerequisites：目标所依赖的列表</li><li>command：任意shell指令，一般用于生成target。<strong>必须以[Tab键]开头</strong>，也可以和prerequisites在一行，用分号做为分隔</li></ul><p>这是一个文件的依赖关系，也就是说，target依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行(command一定要以Tab键开始，否则编译器无法识别command）。这就是Makefile的规则，也是Makefile中最核心的内容。</p><p>举个栗子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test : test1.o test2.o</span><br><span class="line">cc -o test test1.o test2.o</span><br><span class="line"></span><br><span class="line">test1.o : test1.c test1.h</span><br><span class="line">cc -c test1.c</span><br><span class="line"></span><br><span class="line">test2.o : test2.c test2.h</span><br><span class="line">cc -c test2.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">rm test test1.o test2.o</span><br></pre></td></tr></table></figure><p>在这里，test是最终的目标，生成test，依赖于test1.o和test2.o也就是说，有以下情况发生时，会执行cc -o test test1.o test2.o指令，以重新生成target</p><ul><li>test不存在</li><li>test存在，但test1.o的修改时间比test新</li><li>test存在，但test2.o的修改时间比test新</li></ul><p>把所有依赖关系都在makefile里列举出来之后，执行make命令的时候，就会根据依赖关系自动编译链接了  </p><p>但是这里的clean又是干什么的呢？它并没有其他依赖，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字，比如<code>make clean</code>。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><h2 id="隐晦规则"><a href="#隐晦规则" class="headerlink" title="隐晦规则"></a>隐晦规则</h2><p>每个.o文件的依赖文件默认会有同名的.c文件，比如有一个target是test.o，那么test.c默认就是test.O的依赖文件，这个是makefile的隐晦规则，是make会自动推导出来的</p><h1 id="make是怎么工作的？"><a href="#make是怎么工作的？" class="headerlink" title="make是怎么工作的？"></a>make是怎么工作的？</h1><p>在默认的方式下，也就是我们只输入make命令。那么：</p><ol><li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件</li><li>如果找到，它会找文件中的<strong>第一个</strong>目标文件（target），在上面的例子中，他会找到“test”这个文件，并把这个文件作为最终的目标文件</li><li>如果test文件不存在，或是test所依赖的后面的 .o 文件的文件修改时间要比test这个文件新，那么，他就会执行后面所定义的命令来生成test这个文件</li><li>如果test所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件</li></ol><p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件</p><h1 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h1><h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，比如我们可以定义一个objects变量，并通过$(objects)的方式来使用这个变量。变量类似与C语言的宏定义，在执行的时候，变量的值会被扩展到被使用的地方</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = test1.o test2.o</span><br><span class="line">test : <span class="variable">$(objects)</span></span><br><span class="line">cc -o test <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line">test : test1.o test2.o</span><br><span class="line">cc -o test test1.o test2.o</span><br></pre></td></tr></table></figure><p>第一种写法和第二种写法的作用完全是一样的</p><h2 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p><p>先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(foo)</span> <span class="comment">#我们执行“make all”将会打出变量$(foo)的值是“Huh?”</span></span><br></pre></td></tr></table></figure><p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，不好的地方，那就是递归定义：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = <span class="variable">$(A)</span></span><br><span class="line"><span class="comment">#这会让make陷入无限的变量展开过程中去,当然，我们的make是有能力检测这样的定义，并会报错</span></span><br></pre></td></tr></table></figure><p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br><span class="line"></span><br><span class="line"><span class="comment">#这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量,上下两种方式是等价的</span></span><br><span class="line"></span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure><h2 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h2><p>我们可以使用“+=”操作符给变量追加值，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure><p>于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p><p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure><p>但如果是这种情况： </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable = value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure><p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p><h2 id="变量的高级用法"><a href="#变量的高级用法" class="headerlink" title="变量的高级用法"></a>变量的高级用法</h2><h3 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h3><p>我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符还是看一个示例吧：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br><span class="line"><span class="comment"># 把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，最终bar的值是a.c b.c c.c</span></span><br></pre></td></tr></table></figure><p>另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br><span class="line"><span class="comment"># 这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”</span></span><br></pre></td></tr></table></figure><h3 id="把变量的值再当成变量"><a href="#把变量的值再当成变量" class="headerlink" title="把变量的值再当成变量"></a>把变量的值再当成变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line"><span class="comment"># 在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”</span></span><br></pre></td></tr></table></figure><h1 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h1><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令。</p><p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂</p><h1 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h1><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁，一般风格是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm test <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h1 id="makefile注释"><a href="#makefile注释" class="headerlink" title="makefile注释"></a>makefile注释</h1><p>Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是在makefile中的注释1</span></span><br><span class="line"><span class="comment"># 这是在makefile中的注释2</span></span><br></pre></td></tr></table></figure><h1 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h1><p>在Makefile使用include关键字可以把别的Makefile包含进来，make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;</span><br><span class="line"><span class="comment"># 在include前面可以有一些空字符，但是绝不能是[Tab]键开始</span></span><br><span class="line"><span class="comment"># filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> &lt;filename&gt;</span><br><span class="line"><span class="comment"># 无论include过程中出现什么错误，都不要报错继续执行。上面那条指令若是找不到include的目标文件，会报错</span></span><br></pre></td></tr></table></figure><h1 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h1><p>最早先的一个例子中，我们提到过一个“clean”的目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure><p>伪目标不会自动被执行，只能显式地调用执行。但是上面伪目标的写法有一个缺陷，若是当前目录下存在有一个文件名为”clean”，那么根据我们的规则，command将不会被执行，因为目标已经存在了，为了解决这个问题，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure><p>通过.PHONY，无论是否存在“clean”文件，我们的command都将会被执行了</p><h1 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h1><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p><p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Makefile&quot;&gt;&lt;a href=&quot;#什么是Makefile&quot; class=&quot;headerlink&quot; title=&quot;什么是Makefile&quot;&gt;&lt;/a&gt;什么是Makefile&lt;/h1&gt;&lt;p&gt;Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，文件之间有哪些依赖等。Makefile有自己的书写格式、关键字、函数。像C 语言有自己的格式、关键字和函数一样。而且在Makefile中可以使用系统shell所提供的任何命令来完成想要的工作。&lt;br&gt;Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率&lt;/p&gt;
&lt;h1 id=&quot;makefile的文件名&quot;&gt;&lt;a href=&quot;#makefile的文件名&quot; class=&quot;headerlink&quot; title=&quot;makefile的文件名&quot;&gt;&lt;/a&gt;makefile的文件名&lt;/h1&gt;&lt;p&gt;默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。&lt;/p&gt;
&lt;p&gt;当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;make -f Make.Linux&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make --file Make.AIX&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://blog.hanschen.site/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="c" scheme="http://blog.hanschen.site/tags/c/"/>
    
      <category term="makefile教程" scheme="http://blog.hanschen.site/tags/makefile%E6%95%99%E7%A8%8B/"/>
    
      <category term="makefile" scheme="http://blog.hanschen.site/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>利用keytool、openssl生成证书文件</title>
    <link href="http://blog.hanschen.site/2016/08/16/keytool-openssl-ca/"/>
    <id>http://blog.hanschen.site/2016/08/16/keytool-openssl-ca/</id>
    <published>2016-08-15T16:00:00.000Z</published>
    <updated>2019-09-02T06:30:29.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用openssl指令逐步生成各个文件"><a href="#用openssl指令逐步生成各个文件" class="headerlink" title="用openssl指令逐步生成各个文件"></a>用openssl指令逐步生成各个文件</h1><ol><li><p>生成服务器密钥：openssl genrsa -out server_private.key 2048</p></li><li><p>从密钥生成公钥（非必须）：openssl rsa -in server_private.key -pubout &gt; server_public.key</p></li><li><p>生成证书请求文件，这里会让你输入一堆信息，比如组织名称、个人信息等：openssl req -new -key server_private.key -out server_req.csr</p></li><li><p>初始化CA环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir demoCA</span><br><span class="line">cd demoCA</span><br><span class="line">mkdir certs crl newcerts</span><br><span class="line">touch index.txt serial</span><br><span class="line">echo 00 &gt; serial</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li><li><p>生成ca密钥：openssl genrsa -out ca.key 2048</p></li><li><p>生成ca证书：openssl req -new -x509 -key ca.key -out ca.crt</p></li><li><p>用ca对服务器证书请求文件进行签名:openssl ca -in server_req.csr -out server.crt -cert ca.crt -keyfile ca.key -config /usr/ssl/openssl.cnf</p></li><li><p>可以把服务端的私钥和已签名的证书合并到一个pkcs12格式的文件：openssl pkcs12 -export -out server.pfx -inkey server_private.key -in server.crt  </p></li><li><p>也可以把pkcs12格式转化为java常用的jks格式：keytool -importkeystore -v -srckeystore server.pfx -srcstoretype pkcs12 -srcstorepass 123456 -destkeystore server.jks -deststoretype jks -deststorepass 123456</p></li></ol><a id="more"></a><h1 id="用keytool生成"><a href="#用keytool生成" class="headerlink" title="用keytool生成"></a>用keytool生成</h1><p>keytool主要可以帮我们：</p><ol><li>创建一个新的JKS(Java Key Store)文件（里面包含了一个新生成的服务器密钥）</li><li>导出一个CSR(Certificate Signung Request)证书申请文件</li><li>导入一个签名后的证书文件到jks文件中</li></ol><p>以下是操作步骤：</p><ol><li>生成新的jks文件：keytool -genkeypair -alias server -keyalg RSA -keystore server.jks</li><li>到出证书请求文件：keytool -certreq -alias server -file server.csr -keystore server.jks</li><li>用ca对请求文件进行签名（ca的生成请参考上面）：openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -config demoCA/config/openssl.cnf</li><li>导入已签名的证书到jks：keytool -importcert -alias server -file server.crt -keystore server.jks</li></ol><p>这样，我们就得到了一个包含了服务器密钥以及已签名证书的jks文件了</p><h1 id="最终生成的文件"><a href="#最终生成的文件" class="headerlink" title="最终生成的文件"></a>最终生成的文件</h1><p>最终服务端需要用到的文件有：</p><ol><li>服务器私钥</li><li>经过CA签名的证书（包含服务器公钥、基本信息）</li></ol><p>客户端需要用到的文件有：</p><ol><li>CA的证书（包含了CA的公钥，用以对服务器的证书解密，校验证书真伪）</li></ol><blockquote><p>有些服务器配置可以使用私钥+证书合并在一起的文件，如jks或者pkcs12文件，这类文件一般叫key.keystore。客户端使用的ca证书一般称为：truststore</p></blockquote><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>openssl对证书签名的时候有可能报国家、组织、地区需一致的错误，是因为在openssl.cfg中的policy_match里面的前三个都选了match，可以修改optional，修改后就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用openssl指令逐步生成各个文件&quot;&gt;&lt;a href=&quot;#用openssl指令逐步生成各个文件&quot; class=&quot;headerlink&quot; title=&quot;用openssl指令逐步生成各个文件&quot;&gt;&lt;/a&gt;用openssl指令逐步生成各个文件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成服务器密钥：openssl genrsa -out server_private.key 2048&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从密钥生成公钥（非必须）：openssl rsa -in server_private.key -pubout &amp;gt; server_public.key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成证书请求文件，这里会让你输入一堆信息，比如组织名称、个人信息等：openssl req -new -key server_private.key -out server_req.csr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化CA环境&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir demoCA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd demoCA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir certs crl newcerts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;touch index.txt serial&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo 00 &amp;gt; serial&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ..&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成ca密钥：openssl genrsa -out ca.key 2048&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成ca证书：openssl req -new -x509 -key ca.key -out ca.crt&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用ca对服务器证书请求文件进行签名:openssl ca -in server_req.csr -out server.crt -cert ca.crt -keyfile ca.key -config /usr/ssl/openssl.cnf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以把服务端的私钥和已签名的证书合并到一个pkcs12格式的文件：openssl pkcs12 -export -out server.pfx -inkey server_private.key -in server.crt  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以把pkcs12格式转化为java常用的jks格式：keytool -importkeystore -v -srckeystore server.pfx -srcstoretype pkcs12 -srcstorepass 123456 -destkeystore server.jks -deststoretype jks -deststorepass 123456&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://blog.hanschen.site/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="非对称加密" scheme="http://blog.hanschen.site/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="keytool,rsa" scheme="http://blog.hanschen.site/tags/keytool-rsa/"/>
    
      <category term="证书生成" scheme="http://blog.hanschen.site/tags/%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
</feed>
