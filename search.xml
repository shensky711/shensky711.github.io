<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Ninja 提升模块编译速度]]></title>
    <url>%2F2019%2F11%2F20%2Fninja_compile%2F</url>
    <content type="text"><![CDATA[1. 简介从 Android 7 开始，Android 源码编译时默认使用 Ninja，编译时，会先把 makefile 和 bp 转换成 ninja 再进行编译。这个转换过程非常慢（需要遍历处理所有关联的 makefile、bp 文件），即使只是通过 mm 或 mmm 编译某个模块，也会有很多因素触发 ninja 文件的重新生成，而这对基于源码开发的模块很不友好，编译好慢！ 2. 初识 ninjaAOSP 在源码中已经内置了一个 ninja 执行文件，路径为：./prebuilts/build-tools/linux-x86/bin/ninja 我们先看看它的 help： 123456789101112131415161718192021➜ ~ ./prebuilts/build-tools/linux-x86/bin/ninja -husage: ninja [options] [targets...]if targets are unspecified, builds the 'default' target (see manual).options: --version print ninja version ("1.9.0") -v, --verbose show all command lines while building -C DIR change to DIR before doing anything else -f FILE specify input build file [default=build.ninja] -j N run N jobs in parallel (0 means infinity) [default=10 on this system] -k N keep going until N jobs fail (0 means infinity) [default=1] -l N do not start new jobs if the load average is greater than N -n dry run (don't run commands but act like they succeeded) -d MODE enable debugging (use '-d list' to list modes) -t TOOL run a subtool (use '-t list' to list subtools) terminates toplevel options; further flags are passed to the tool -w FLAG adjust warnings (use '-w list' to list warnings) 简单使用的话，我们关注它的两个参数就行了 -f：这个参数指定的就是输入文件，也就是 makefile 和 bp 转换后的 ninja 文件，一般位于 ./out 目录，后面会说 targets：目标，这个和 makefile 是类似的，就是我们最终需要的产物，例如：Launcher3QuickStep、SystemUI。那么这些 targets 名是哪里定义的呢？要知道对应模块的对应的 target 名，只需要： 若模块使用的是 Android.mk：查找 LOCAL_PACKAGE_NAME 或 LOCAL_MODULE 等对应的值 若模块使用的是 Android.bp：查找 module 中 name 对应的值 举个栗子： 1234567➜ android-10.0.0_r11 ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-aosp_walleye.ninja Launcher3QuickStep[3/13] Target Java: out/target/common/obj/JAVA_LIBRARIES/Launcher3QuickStepLib_intermediates/classes-full-debug.jar注: 某些输入文件使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。[13/13] Install: out/target/product/walleye/system/product/priv-app/Launcher3QuickStep/Launcher3QuickStep.apk 就这样，不需要通过 mm 或者 mmm 命令，目标产物同样生成了。我们看看耗时： 1234567891011➜ android-10.0.0_r11 time ./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-aosp_walleye.ninja Launcher3QuickStep[3/13] Target Java: out/target/common/obj/JAVA_LIBRARIES/Launcher3QuickStepLib_intermediates/classes-full-debug.jar注: 某些输入文件使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。[13/13] Install: out/target/product/walleye/system/product/priv-app/Launcher3QuickStep/Launcher3QuickStep.apkreal 0m18.994suser 1m20.548ssys 0m2.872s 可以看到，整个编译在 18s 完成了，相比动辄七八分钟的 mmm，效率提升还是很可观的。 3. 注意事项虽然 ninja 很方便，但要用它来编译单个模块，还是有一些限制和注意事项的： 使用前需把对应模块编译一遍，用于生产 ninja 文件（全编或 mmm 都可以） 全编后，生成的 ninja 文件为：./out/combined-[TARGET-PRODUCT].ninja mmm 编译后，生成的 ninja 文件为：./out/combined-[TARGET-PRODUCT]-_[path_to_your_module_makefile].ninja，比如：./out/combined-aosp_walleye-_packages_apps_Launcher3_Android.mk.ninja 如果修改了 Android.mk 或 Android.bp，需使用传统的 make 命令进行编译以重新生成包含新依赖规则的 ninja 文件 可以把 ninja 放到 PATH 环境变量中，这样就不用每次都敲 ./prebuilts/build-tools/linux-x86/bin/ninja 这个路径了 4. 最后为 Launcher 和 SystemUI 准备一份开箱即用的指令，尽情玩耍吧~ Launcher： 1./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-qssi-_packages_apps_Launcher3_Android.mk.ninja Launcher3QuickStep SystemUI： 1./prebuilts/build-tools/linux-x86/bin/ninja -f out/combined-qssi-_frameworks_base_packages_SystemUI_Android.mk.ninja SystemUI]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Q 黑暗模式（Dark Mode）源码解析]]></title>
    <url>%2F2019%2F10%2F22%2Fandroid_q_dark_mode%2F</url>
    <content type="text"><![CDATA[1. 简介随着 Android Q 发布，「黑暗模式」或者说是「夜间模式」终于在此版本中得到了支持，官方介绍见：https://developer.android.com/guide/topics/ui/look-and-feel/darktheme，再看看效果图： 其实这个功能魅族在两年前就已支持，不得不说 Android 有点落后了，今天我们就来看看原生是怎么实现全局夜间模的吧 2. 打开与关闭从文档上我们可以可知，打开夜间模式有三个方法： 设置 -&gt; 显示 -&gt; 深色主题背景 下拉通知栏中开启 Pixel 手机开启省点模式时会自动激活夜间模式 3. 如何适配打开后，我们会发现，除原生几个应用生效外，其他应用依然没有变成深色主题，那么应用该如何适配呢？官方提供了下面两种方法： 3.1. 让应用主题继承 DayNight 主题1&lt;style name="AppTheme" parent="Theme.AppCompat.DayNight"&gt; 或者继承自 1&lt;style name="AppTheme" parent="Theme.MaterialComponents.DayNight"&gt; 继承后，如果当前开启了夜间模式，系统会自动从 night-qualified 中加载资源，所以应用的颜色、图标等资源应尽量避免硬编码，而是推荐使用新增 attributes 指向不同的资源，如 12?android:attr/textColorPrimary?attr/colorControlNormal 另外，如果应用希望主动切换夜间/日间模式，可以通过 AppCompatDelegate.setDefaultNightMode() 接口主动切换 3.2. 通过 forceDarkAllowed 启用如果应用不想自己去适配各种颜色，图标等，可以通过在主题中添加 android:forceDarkAllowed=&quot;true&quot; 标记，这样系统在夜间模式时，会强制改变应用颜色，自动进行适配（这个功能也是本文主要探讨的）。不过如果你的应用本身使用的就是 DayNight 或 Dark Theme，forceDarkAllowed 是不会生效的。 另外，如果你不希望某个 view 被强制夜间模式处理，则可以给 view 添加 android:forceDarkAllowed=&quot;false&quot; 或者 view.setForceDarkAllowed(false)，设置之后，即使打开了夜间模式且主题添加了 forceDarkAllowed，该 view 也不会变深色。比较重要的一点是，这个接口只能关闭夜间模式，不能开启夜间模式，也就是说，如果主题中没有显示声明 forceDarkAllowed，view.setForceDarkAllowed(true) 是没办法让 view 单独变深色的。如果 view 关闭了夜间模式，那么它的子 view 也会强制关闭夜间模式 总结如下： 主题若添加 forceDarkAllowed=false，无论 view 是否开启 forceDarkAllowed 都不会打开夜间模式 主题若添加 forceDarkAllowed=true，view 可以通过 forceDarkAllowed 关闭夜间模式，一旦关闭，子 view 的夜间模式也会被关闭 如果父 view 或主题设置了 forceDarkAllowed=false，子 view 无法通过 forceDarkAllowed=true 单独打开夜间模式为 若使用的是 DayNight 或 Dark Theme 主题，则所有 forceDarkAllowed 都不生效 4. 实现原理通过继承主题适配夜间模式的原理本质是根据 ui mode 加载 night-qualified 下是资源，这个并非 Android Q 新增的东西，我们这里不再描述。现在主要来看看 forceDarkAllowed 是如何让系统变深色的。 既然一切的源头都是 android:forceDarkAllowed 这个属性，那我们就从它入手吧，首先我们要知道，上面我们说的 android:forceDarkAllowed 其实是分为两个用处，它们分别的定义如下： frameworks/base/core/res/res/values/attrs.xml 1234567891011121314151617181920&lt;declare-styleable name="View"&gt; &lt;!-- &lt;p&gt;Whether or not the force dark feature is allowed to be applied to this View. &lt;p&gt;Setting this to false will disable the auto-dark feature on this View draws including any descendants. &lt;p&gt;Setting this to true will allow this view to be automatically made dark, however a value of 'true' will not override any 'false' value in its parent chain nor will it prevent any 'false' in any of its children. --&gt; &lt;attr name="forceDarkAllowed" format="boolean" /&gt;&lt;/declare-styleable&gt; &lt;declare-styleable name="Theme"&gt; &lt;!-- &lt;p&gt;Whether or not the force dark feature is allowed to be applied to this theme. &lt;p&gt;Setting this to false will disable the auto-dark feature on everything this theme is applied to along with anything drawn by any children of views using this theme. &lt;p&gt;Setting this to true will allow this view to be automatically made dark, however a value of 'true' will not override any 'false' value in its parent chain nor will it prevent any 'false' in any of its children. --&gt; &lt;attr name="forceDarkAllowed" format="boolean" /&gt; &lt;/declare-styleable&gt; 一个是 View 级别的，一个是 Theme 级别的。 4.1. Theme 级别 forceDarkAllowed从上面的总结来看，Theme 级别的开关优先级是最高的，控制粒度也最大，我们看看源码里面使用它的地方 123456789101112131415161718192021222324252627282930313233343536// frameworks/base/core/java/android/view/ViewRootImpl.javaprivate void updateForceDarkMode() &#123; // 渲染线程为空，直接返回 if (mAttachInfo.mThreadedRenderer == null) return; // 系统是否打开了黑暗模式 boolean useAutoDark = getNightMode() == Configuration.UI_MODE_NIGHT_YES; if (useAutoDark) &#123; // forceDarkAllowed 默认值，开发者模式是否打开了强制 smart dark 选项 boolean forceDarkAllowedDefault = SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false); TypedArray a = mContext.obtainStyledAttributes(R.styleable.Theme); // useAutoDark = 使用浅色主题 &amp;&amp; 主题中声明的 forceDarkAllowed 值 useAutoDark = a.getBoolean(R.styleable.Theme_isLightTheme, true) &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault); a.recycle(); &#125; // 关键代码，设置是否强制夜间模式 if (mAttachInfo.mThreadedRenderer.setForceDark(useAutoDark)) &#123; // TODO: Don't require regenerating all display lists to apply this setting invalidateWorld(mView); &#125;&#125;// frameworks/base/graphics/java/android/graphics/HardwareRenderer.javapublic boolean setForceDark(boolean enable) &#123; if (mForceDark != enable) &#123; mForceDark = enable; // native 代码，mNativeProxy 其实是 RenderThread 代理类的指针 nSetForceDark(mNativeProxy, enable); return true; &#125; return false;&#125; 这段代码还是比较简单，判断系统： 是否打开了夜间模式 是否使用浅色主题 Theme_forceDarkAllowed 是否为 true 三者同时为 true 时才会设置夜间模式，而 updateForceDarkMode 调用的时机分别是在 ViewRootImpl#setView 和 ViewRootImpl#updateConfiguration，也就是初始化和夜间模式切换的时候都会调用，确保夜间模式能及时启用和关闭。继续跟踪 HardwareRenderer#setForceDark 发现，这是一个 native 方法，所以接下来让我们进入 native 世界，nSetForceDark 对应的实现位于 12345678910111213141516171819202122232425262728293031323334// frameworks/base/core/jni/android_view_ThreadedRenderer.cppstatic void android_view_ThreadedRenderer_setForceDark(JNIEnv* env, jobject clazz, jlong proxyPtr, jboolean enable) &#123; RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr); proxy-&gt;setForceDark(enable);&#125;// frameworks/base/libs/hwui/renderthread/RenderProxy.cppvoid RenderProxy::setForceDark(bool enable) &#123; mRenderThread.queue().post([this, enable]() &#123; mContext-&gt;setForceDark(enable); &#125;);&#125;// frameworks/base/libs/hwui/renderthread/CanvasContext.hclass CanvasContext : public IFrameCallback &#123;public: ... void setForceDark(bool enable) &#123; mUseForceDark = enable; &#125; bool useForceDark() &#123; return mUseForceDark; &#125; ...private: ... // 默认关闭强制夜间模式 bool mUseForceDark = false; ...&#125;; 最终就是设置了一个 CanvasContext 的变量值而已，什么都还没有做，那么这个变量值的作用是什么，什么时候生效呢？我们进一步查看使用的地方： 1234567891011// frameworks/base/libs/hwui/TreeInfo.cppTreeInfo::TreeInfo(TraversalMode mode, renderthread::CanvasContext&amp; canvasContext) : mode(mode) , prepareTextures(mode == MODE_FULL) , canvasContext(canvasContext) , damageGenerationId(canvasContext.getFrameNumber()) // 初始化 TreeInfo 的 disableForceDark 变量，注意变量值意义的变化，0 代表打开夜间模式，&gt;0 代表关闭夜间模式 , disableForceDark(canvasContext.useForceDark() ? 0 : 1) , screenSize(canvasContext.getNextFrameSize()) &#123;&#125;&#125; 进一步看看 disableForceDark 使用的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// frameworks/base/libs/hwui/RenderNode.cpp/** * 这个可以说是核心方法了，handleForceDark 方法调用栈如下： * - RenderNode#prepareTreeImpl * - RenderNode#pushStagingDisplayListChanges * - RenderNode#syncDisplayList * - RenderNode#handleForceDark * * 而 RenderNode#prepareTree 是绘制的必经之路，每一个节点都会走一遍这个流程 */void RenderNode::handleForceDark(android::uirenderer::TreeInfo *info) &#123; // 若没打开强制夜间模式，直接退出 if (CC_LIKELY(!info || info-&gt;disableForceDark)) &#123; return; &#125; // 根据是否有文字、是否有子节点、子节点数量等情况，得出当前 Node 属于 Foreground 还是 Background auto usage = usageHint(); const auto&amp; children = mDisplayList-&gt;mChildNodes; if (mDisplayList-&gt;hasText()) &#123; usage = UsageHint::Foreground; &#125; if (usage == UsageHint::Unknown) &#123; if (children.size() &gt; 1) &#123; usage = UsageHint::Background; &#125; else if (children.size() == 1 &amp;&amp; children.front().getRenderNode()-&gt;usageHint() != UsageHint::Background) &#123; usage = UsageHint::Background; &#125; &#125; if (children.size() &gt; 1) &#123; // Crude overlap check SkRect drawn = SkRect::MakeEmpty(); for (auto iter = children.rbegin(); iter != children.rend(); ++iter) &#123; const auto&amp; child = iter-&gt;getRenderNode(); // We use stagingProperties here because we haven't yet sync'd the children SkRect bounds = SkRect::MakeXYWH(child-&gt;stagingProperties().getX(), child-&gt;stagingProperties().getY(), child-&gt;stagingProperties().getWidth(), child-&gt;stagingProperties().getHeight()); if (bounds.contains(drawn)) &#123; // This contains everything drawn after it, so make it a background child-&gt;setUsageHint(UsageHint::Background); &#125; drawn.join(bounds); &#125; &#125; // 根据 UsageHint 设置变色策略：Dark（压暗）、Light（提亮） mDisplayList-&gt;mDisplayList.applyColorTransform( usage == UsageHint::Background ? ColorTransform::Dark : ColorTransform::Light);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// frameworks/base/libs/hwui/RecordingCanvas.cppvoid DisplayListData::applyColorTransform(ColorTransform transform) &#123; // transform: Dark 或 Light // color_transform_fns 是一个对应所有绘制指令的函数指针数组，主要是对 op 的 paint 变色或对 bitmap 添加 colorfilter this-&gt;map(color_transform_fns, transform);&#125;template &lt;typename Fn, typename... Args&gt;inline void DisplayListData::map(const Fn fns[], Args... args) const &#123; auto end = fBytes.get() + fUsed; // 遍历当前的绘制的 op for (const uint8_t* ptr = fBytes.get(); ptr &lt; end;) &#123; auto op = (const Op*)ptr; auto type = op-&gt;type; auto skip = op-&gt;skip; // 根据 type 找到对应的 fn，根据调用关系，我们知道 fns 数组对应 color_transform_fns，这个数组其实是一个函数指针数组，下面看看定义 if (auto fn = fns[type]) &#123; // We replace no-op functions with nullptrs // 执行 fn(op, args...); // to avoid the overhead of a pointless call. &#125; ptr += skip; &#125;&#125;#define X(T) colorTransformForOp&lt;T&gt;(),static const color_transform_fn color_transform_fns[] = &#123; X(Flush) X(Save) X(Restore) X(SaveLayer) X(SaveBehind) X(Concat) X(SetMatrix) X(Translate) X(ClipPath) X(ClipRect) X(ClipRRect) X(ClipRegion) X(DrawPaint) X(DrawBehind) X(DrawPath) X(DrawRect) X(DrawRegion) X(DrawOval) X(DrawArc) X(DrawRRect) X(DrawDRRect) X(DrawAnnotation) X(DrawDrawable) X(DrawPicture) X(DrawImage) X(DrawImageNine) X(DrawImageRect) X(DrawImageLattice) X(DrawTextBlob) X(DrawPatch) X(DrawPoints) X(DrawVertices) X(DrawAtlas) X(DrawShadowRec) X(DrawVectorDrawable)&#125;;#undef X color_transform_fn 宏定义展开 123456789101112131415161718192021222324252627282930313233template &lt;class T&gt;constexpr color_transform_fn colorTransformForOp() &#123; if // op 变量中是否同时包含 paint 及 palette 属性，若同时包含，则是绘制 Image 或者 VectorDrawable 的指令 // 参考：frameworks/base/libs/hwui/RecordingCanvas.cpp 中各 Op 的定义 constexpr(has_paint&lt;T&gt; &amp;&amp; has_palette&lt;T&gt;) &#123; return [](const void* opRaw, ColorTransform transform) &#123; const T* op = reinterpret_cast&lt;const T*&gt;(opRaw); // 关键变色方法，根据 palette 叠加 colorfilter transformPaint(transform, const_cast&lt;SkPaint*&gt;(&amp;(op-&gt;paint)), op-&gt;palette); &#125;; &#125; else if // op 变量中是否包含 paint 属性，普通绘制指令 constexpr(has_paint&lt;T&gt;) &#123; return [](const void* opRaw, ColorTransform transform) &#123; const T* op = reinterpret_cast&lt;const T*&gt;(opRaw); // 关键变色方法，对 paint 颜色进行变换 transformPaint(transform, const_cast&lt;SkPaint*&gt;(&amp;(op-&gt;paint))); &#125;; &#125; else &#123; // op 变量不包含 paint 属性，返回空 return nullptr; &#125;&#125;static const color_transform_fn color_transform_fns[] = &#123; // 根据 Flush、Save、DrawImage等不同绘制 op，返回不同的函数指针 colorTransformForOp&lt;Flush&gt; ...&#125;; 让我们再一次看看 map 方法 1234567891011121314template &lt;typename Fn, typename... Args&gt;inline void DisplayListData::map(const Fn fns[], Args... args) const &#123; auto end = fBytes.get() + fUsed; for (const uint8_t* ptr = fBytes.get(); ptr &lt; end;) &#123; auto op = (const Op*)ptr; auto type = op-&gt;type; auto skip = op-&gt;skip; if (auto fn = fns[type]) &#123; // We replace no-op functions with nullptrs // 对 op 的 paint 进行颜色变换或叠加 colorfilter fn(op, args...); // to avoid the overhead of a pointless call. &#125; ptr += skip; &#125;&#125; 贴了一大段代码，虽然代码中已经包含了注释，但还是可能比较晕，我们先来整理下： CanvasContext.mUseForceDark 只会影响 TreeInfo.disableForceDark 的初始化 TreeInfo.disableForceDark 若大于 0，RenderNode 在执行 handleForceDark 就会直接退出 handleForceDark 方法里会根据 UsageHint 类型，对所有 op 中的 paint 颜色进行变换，如果是绘制图片，则叠加一个反转的 colorfilter。变换策略有：Dark、Light 接下来让我们来看 paint 和 colorfilter 的变色实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849bool transformPaint(ColorTransform transform, SkPaint* paint) &#123; applyColorTransform(transform, *paint); return true;&#125;static void applyColorTransform(ColorTransform transform, SkPaint&amp; paint) &#123; if (transform == ColorTransform::None) return; // 对画笔颜色进行颜色变换 SkColor newColor = transformColor(transform, paint.getColor()); paint.setColor(newColor); if (paint.getShader()) &#123; SkShader::GradientInfo info; std::array&lt;SkColor, 10&gt; _colorStorage; std::array&lt;SkScalar, _colorStorage.size()&gt; _offsetStorage; info.fColorCount = _colorStorage.size(); info.fColors = _colorStorage.data(); info.fColorOffsets = _offsetStorage.data(); SkShader::GradientType type = paint.getShader()-&gt;asAGradient(&amp;info); if (info.fColorCount &lt;= 10) &#123; switch (type) &#123; case SkShader::kLinear_GradientType: for (int i = 0; i &lt; info.fColorCount; i++) &#123; // 对 shader 中的颜色进行颜色变换 info.fColors[i] = transformColor(transform, info.fColors[i]); &#125; paint.setShader(SkGradientShader::MakeLinear(info.fPoint, info.fColors, info.fColorOffsets, info.fColorCount, info.fTileMode, info.fGradientFlags, nullptr)); break; default:break; &#125; &#125; &#125; if (paint.getColorFilter()) &#123; SkBlendMode mode; SkColor color; // TODO: LRU this or something to avoid spamming new color mode filters if (paint.getColorFilter()-&gt;asColorMode(&amp;color, &amp;mode)) &#123; // 对 colorfilter 中的颜色进行颜色变换 color = transformColor(transform, color); paint.setColorFilter(SkColorFilter::MakeModeFilter(color, mode)); &#125; &#125;&#125; 逻辑很简单，就是对颜色进行变换，进一步看看变色逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142// 提亮颜色static SkColor makeLight(SkColor color) &#123; // 转换成 Lab 模式 Lab lab = sRGBToLab(color); // 对明度进行反转，明度越高，反转后越低 float invertedL = std::min(110 - lab.L, 100.0f); if (invertedL &gt; lab.L) &#123; // 反转后的明度高于原明度，则使用反转后的明度 lab.L = invertedL; return LabToSRGB(lab, SkColorGetA(color)); &#125; else &#123; return color; &#125;&#125;// 压暗颜色static SkColor makeDark(SkColor color) &#123; // 转换成 Lab 模式 Lab lab = sRGBToLab(color); // 对明度进行反转，明度越高，反转后越低 float invertedL = std::min(110 - lab.L, 100.0f); if (invertedL &lt; lab.L) &#123; // 反转后的明度低于原明度，则使用反转后的明度 lab.L = invertedL; // 使用 rgb 格式返回 return LabToSRGB(lab, SkColorGetA(color)); &#125; else &#123; // 直接返回原颜色 return color; &#125;&#125;static SkColor transformColor(ColorTransform transform, SkColor color) &#123; switch (transform) &#123; case ColorTransform::Light: return makeLight(color); case ColorTransform::Dark: return makeDark(color); default: return color; &#125;&#125; 到此，对 paint 的变换结束，看来无非就是反转明度。 再来看看对图片的变换： 1234567891011121314151617181920bool transformPaint(ColorTransform transform, SkPaint* paint, BitmapPalette palette) &#123; // 根据 palette 和 colorfilter 判断图片是亮还是暗的 palette = filterPalette(paint, palette); bool shouldInvert = false; if (palette == BitmapPalette::Light &amp;&amp; transform == ColorTransform::Dark) &#123; // 图片本身是亮的，但是要求变暗，反转 shouldInvert = true; &#125; if (palette == BitmapPalette::Dark &amp;&amp; transform == ColorTransform::Light) &#123; // 图片本身是暗的，但是要求变亮，反转 shouldInvert = true; &#125; if (shouldInvert) &#123; SkHighContrastConfig config; config.fInvertStyle = SkHighContrastConfig::InvertStyle::kInvertLightness; // 叠加一个亮度反转的 colorfilter paint-&gt;setColorFilter(SkHighContrastFilter::Make(config)-&gt;makeComposed(paint-&gt;refColorFilter())); &#125; return shouldInvert;&#125; 终于，bitmap 的变换也分析完了，呼~ 4.2. View 级别 forceDarkAllowed但是，还没完呢~还记得我们最开始说的，除了 Theme 级别，还有一个 View 级别的 forceDarkAllowed，通过 View 级别 forceDarkAllowed 可以关掉它及它的子 view 的夜间模式开关。依然从 java 层看下去哈 123456789101112131415161718192021222324252627// rameworks/base/core/java/android/view/View.javapublic class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource &#123; public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; final TypedArray a = context.obtainStyledAttributes( attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes); final int N = a.getIndexCount(); for (int i = 0; i &lt; N; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case R.styleable.View_forceDarkAllowed: // 注意，这个默认是 true 的 mRenderNode.setForceDarkAllowed(a.getBoolean(attr, true)); break; &#125; &#125; &#125;&#125;// frameworks/base/graphics/java/android/graphics/RenderNode.javapublic final class RenderNode &#123; public boolean setForceDarkAllowed(boolean allow) &#123; // 又是 native 方法 return nSetAllowForceDark(mNativeRenderNode, allow); &#125;&#125; 1234567891011121314151617// frameworks/base/core/jni/android_view_RenderNode.cppstatic jboolean android_view_RenderNode_setAllowForceDark(jlong renderNodePtr, jboolean allow) &#123; return SET_AND_DIRTY(setAllowForceDark, allow, RenderNode::GENERIC);&#125;// frameworks/base/libs/hwui/RenderProperties.hclass ANDROID_API RenderProperties &#123;public: bool setAllowForceDark(bool allow) &#123; // 设置到 mPrimitiveFields.mAllowForceDark 变量中 return RP_SET(mPrimitiveFields.mAllowForceDark, allow); &#125; bool getAllowForceDark() const &#123; return mPrimitiveFields.mAllowForceDark; &#125;&#125; 和 Theme 级别的一样，仅仅只是设置到变量中而已，关键是要看哪里使用这个变量，经过查找，我们发现，它的使用同样在 RenderNode 的 prepareTreeImpl 中： 12345678910111213141516171819202122232425262728293031323334353637383940void RenderNode::prepareTreeImpl(TreeObserver&amp; observer, TreeInfo&amp; info, bool functorsNeedLayer) &#123; ... // 1. 如果 view 关闭了夜间模式，会在这里让 info.disableForceDark 加 1 // 2. info.disableForceDark 正是 handleForceDark 中关键变量，还记得吗？ // 3. nfo.disableForceDark 大于 0 会让此 RenderNode 跳过夜间模式处理 // 4. 如果 info.disableForceDark 本身已经大于 0 了，view.setForceDarkAllowed(true) 也毫无意义 if (!mProperties.getAllowForceDark()) &#123; info.disableForceDark++; &#125; prepareLayer(info, animatorDirtyMask); if (info.mode == TreeInfo::MODE_FULL) &#123; // 这里面会调用 handleForceDark 方法处理夜间模式 pushStagingDisplayListChanges(observer, info); &#125; if (mDisplayList) &#123; info.out.hasFunctors |= mDisplayList-&gt;hasFunctor(); // 递归调用子 Node 的 prepareTreeImpl 方法 bool isDirty = mDisplayList-&gt;prepareListAndChildren( observer, info, childFunctorsNeedLayer, [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info, bool functorsNeedLayer) &#123; child-&gt;prepareTreeImpl(observer, info, functorsNeedLayer); &#125;); if (isDirty) &#123; damageSelf(info); &#125; &#125; ... // 重要，把 info.disableForceDark 恢复回原来的值，不让它影响 Tree 中同级的其他 RenderNode // 但是本 RenderNode 的子节点还是会受影响的，这就是为什么父 view 关闭了夜间模式，子 view 也会受影响的原因 // 因为还原 info.disableForceDark 操作是在遍历子节点之后执行的 if (!mProperties.getAllowForceDark()) &#123; info.disableForceDark--; &#125; ...&#125; 5. 总结本文到目前为止，总算把 Android Q 夜间模式实现原理梳理了一遍，总的来说实现不算复杂，说白了就是把 paint 中的颜色转换一下或者叠加一个 colorfilter，虽然中间还有关联知识没有细说，如 RenderThread、DisplayList、RenderNode 等图形相关的概念，限于文章大小，请读者自行了解 另外，由于水平有限，难免文中有错漏之处，若哪里写的不对，请大家及时指出，蟹蟹啦~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何顺滑地查看 Android Native 代码]]></title>
    <url>%2F2019%2F10%2F11%2Faosp-native-ide%2F</url>
    <content type="text"><![CDATA[1. 简介使用 Android Studio 查看 Android Framework 代码体验非常好，无论是索引还是界面都让人很满意，但是当你跟踪代码，发现进入 native 逻辑时，就会发现 Android Studio 对 native 代码的支持非常不好，不能索引不支持符号搜索不能跳转等，这些让人非常抓狂。那么如何能在 IDE 愉快地查看 native 代码呢？在 Windows 上，Source Insight 的表现也很好，但苦于只有 Windows 平台支持且界面不好，经过一番折腾，还真是找到了方法，下面我们将一步一步打造丝滑的 native 代码阅读环境。 先看一下效果： 2. CMake能让 IDE 正确地建立索引，我们需要让 IDE 能正确地知道源文件、头文件、宏定义等各种数据，庆幸的是，我们发现 AOSP 在编译过程中，可以帮我们生成这些数据，详见：http://androidxref.com/9.0.0_r3/xref/build/soong/docs/clion.md 通过文档我们可知，只需要按照以下步骤完成一次编译，即可自动生成各模块对应的 CMake 文件。至于 Cmake 文件是什么，这里就不做赘述了，大家可以自行了解。 打开以下两个开关，CMakeLists.txt 就会根据编译环境自动生成 12export SOONG_GEN_CMAKEFILES=1export SOONG_GEN_CMAKEFILES_DEBUG=1 启动编译 1make -j16 或者只编译你需要的模块 1make frameworks/native/service/libs/ui 生成的文件存放在 out 目录，比如刚刚编译的 libui 模块对应的路径为： 1out/development/ide/clion/frameworks/native/libs/ui/libui-arm64-android/CMakeLists.txt 合并多个模块 生成了 CMake 后，我们发现，CMake 文件是按模块生成的。这样的话，会导致 IDE 只能单独导入一个模块，而我们平时不可能只看一个模块的代码，如果把多个模块都 include 进来呢？我们可以在 out/development/ide/clion 路径新建一个 CMakeLists.txt 文件，并添加一下内容： 1234567# 指定 CMake 最低版本cmake_minimum_required(VERSION 3.6)# 指定工程名，随意project(aosp)# 把你需要的模块通过 add_subdirectory 添加进来，注意子目录必须也包含 CMakeLists.txt 文件add_subdirectory(frameworks/native)#add_subdirectory(frameworks/base/core/jni/libandroid_runtime-arm64-android) 这样，我们就把多个模块合并在一起了，用 IDE 去打开这个总的 CMake 文件即可 3. 导入 IDE只要生成 CMake 文件后，剩下的事情就好办了，现在能识别 CMake 工程的 IDE 非常多，大家可以根据个人喜好选择，如： CLion Eclipse Visual Studio … 这里以 CLion 为例讲一下如何导入 打开 CLion 选择「New CMake Project from Sources」 指定包含 CMakeLists.txt 的目录，如我们在上一个步骤中说的 out/development/ide/clion（这个目录的 CMakeLists.txt 包含了多个模块，还记得吗？） 选择「Open Existing Project」 Enjoy your journey … 当然，CLion 也有一个缺点，收费！！如何能免费使用就看大家各显神通了 4. 遇到的一些问题 生成的 CMakeLists.txt 里指定路径可能会使用绝对路径，如： set(ANDROID_ROOT /Volumes/AndroidSource/M1882_QOF7_base)，这里大家要注意，如果把 CMakeLists.txt 拷贝到别的工程使用，记得修正一下路径 Mac 用户留意，如果你的 CMakeLists.txt 是从 linux 平台生成拷贝过来的，生成的 CMakeLists.txt 里指定的 c++ 编译器 set(CMAKE_CXX_COMPILER &quot;${ANDROID_ROOT}/prebuilts/clang/host/linux-x86/clang-3977809/bin/clang++&quot;) 这里指定的是 linux-x86 的编译器，记得替换成 darwin-x86，如果对应目录下没有 clang++，那就从 AOSP 源码拷一个吧 如果 CMake 中列出的源文件在工程中找不到，会导致 CLion 停止索引，如果出现不一致的时候，移除 CMake 中源文件的声明即可 如果使用遇到其他问题，欢迎联系告知，谢谢 5. 总结所谓工欲善其事，必先利其器。通过这种方法建立的索引包含了 AOSP 所有模块，最重要是它还会根据编译环境，把相关 FLAGS 和宏都设置好。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOSP 编译和烧写]]></title>
    <url>%2F2019%2F09%2F12%2Faosp_compile_and_flash%2F</url>
    <content type="text"><![CDATA[1. 简介很多 Android 开发者都会希望编译 Android 源码并刷进自己的手机里面，但网上教程很多都仅仅是告诉你 lunch、make 等等，但你手里有一台设备时却发现，你编译出的镜像由于驱动关系是不能直接烧进手机的。这里整理了一下步骤，帮助大家可以按照流程编译并烧写镜像。 本篇文章以 Pixel 2 &amp;&amp; Android 10 为例 2. 环境准备这块没啥说，官方教程就够了，参考：https://source.android.com/setup/build/initializing 就行了 3. 源码下载 根据 https://developers.google.com/android/drivers 选择一个设备对应 Android 版本号和驱动，比如我们选择：Android 10.0.0 (QP1A.190711.020)，下载驱动，记住 Build 号 在 https://source.android.com/setup/start/build-numbers 查找 QP1A.190711.020 对应的分支：android-10.0.0_r2，记住分支名 下载 AOSP 源码注意在下载 aosp 前要安装 repo 工具，参考：https://source.android.com/setup/build/downloading 12345mkdir Pixel2cd Pixel2repo init -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r2 --depth=1repo sync -j8repo start android-10.0.0_r2 --all 把步骤1中选中的两个驱动下载到 aosp 源码根目录并解压 分别执行解压后的文件，注意，执行后要同意 License，确保正确解压到 aosp 根目录的 vendor 目录 12./extract-qcom-walleye.sh./extract-google_devices-walleye.sh 4. 源码编译 在 aosp 源码根目录执行：source build/envsetup.sh（注意，执行前终端请选bash，不要使用zsh等，在终端键入bash回车即可） 在 aosp 源码根目录执行：lunch 选择对应的版本，比如 Pixel2 就选择：aosp_walleye-userdebug 执行：make -j8 5. 镜像烧写 编译完后，执行：export ANDROID_PRODUCT_OUT=/home/chenhang/source/Pixel2/out/target/product/walleye 执行：fastboot flashall -w 烧写完成后，执行：fastboot reboot 6. Gapps 安装编译出来的 aosp 默认没有 google 全家桶，可以通过以下方式进行安装 在 https://opengapps.org/ 根据系统版本、芯片类型选择需要的 Gapps 全家桶，可以选 stock 版本 下载后把全家桶 push 到手机 sdcard（不用解压） 在 https://twrp.me/devices/ 搜索你的设备，如： https://twrp.me/google/googlepixel2.html 下载 twrp.img 后根据截图中的命令，把 twrp 加载到手机， 选择 install 刷入 twrp.zip (这是一个 recovery 版本)，重启后，通过 adb reboot recovery 进入 twrp 的recovery 系统 在手机上选择 install， 选择步骤2中 push 到手机 sdcard 的全家桶，安装结束后选择擦除 dalvik cache 和 cache，重启即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffers 手册]]></title>
    <url>%2F2017%2F04%2F08%2Fprotobuf3%2F</url>
    <content type="text"><![CDATA[简介Protocol Buffers 是 google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。 至于protobuf是什么、使用场景、有什么好处，本文不做说明，这里将会为大家介绍怎么用 protobuf 来定义我们的交互协议，包括 .proto 的语法以及如何根据proto文件生成相应的代码。本文基于proto3，读者也可以点击了解proto2 proto3语法定义一个 Message首先我们来定义一个 Search 请求，在这个请求里面，我们需要给服务端发送三个信息： query：查询条件 page_number：你想要哪一页数据 result_per_page：每一页有多少条数据 于是我们可以这样定义： 123456789// 指定使用proto3，如果不指定的话，编译器会使用proto2去编译syntax = &quot;proto3&quot;; //[proto2|proto3]message SearchRequests &#123; // 定义SearchRequests的成员变量，需要指定：变量类型、变量名、变量Tag string query = 1; int32 page_number = 2; int32 result_per_page = 3;&#125; 定义多个 message 类型一个 proto 文件可以定义多个 message ，比如我们可以在刚才那个 proto 文件中把服务端返回的消息结构也一起定义： 123456789message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 result_per_page = 3;&#125;message SearchResponse &#123; repeated string result = 1;&#125; message 可以嵌套定义，比如 message 可以定义在另一个 message 内部 12345678message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; repeated string snippets = 3; &#125; repeated Result results = 1;&#125; 定义在 message 内部的 message 可以这样使用： 123message SomeOtherMessage &#123; SearchResponse.Result result = 1;&#125; 定义变量类型在刚才的例子之中，我们使用了2个标准值类型： string 和 int32，除了这些标准类型之外，变量的类型还可以是复杂类型，比如自定义的枚举和自定义的 message 这里我们把标准类型列举一下protobuf内置的标准类型以及跟各平台对应的关系： .proto 说明 C++ Java Python Go Ruby C# PHP double double double float float64 Float double float float float float float float32 Float float float int32 使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint32 int32 int int int32 Fixnum or Bignum (as required) int integer int64 使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint64 int64 long int/long int64 Bignum long integer/string uint32 使用变长编码 uint32 int int/long uint32 Fixnum or Bignum (as required) uint integer uint64 使用变长编码 uint64 long int/long uint64 Bignum ulong integer/string sint32 使用变长编码，带符号的int类型，对负数编码比int32高效 int32 int int int32 Fixnum or Bignum (as required) int integer sint64 使用变长编码，带符号的int类型，对负数编码比int64高效 int64 long int/long int64 Bignum long integer/string fixed32 4字节编码， 如果变量经常大于$ 2^{28} $ 的话，会比uint32高效 uint32 int int int32 Fixnum or Bignum (as required) uint integer fixed64 8字节编码， 如果变量经常大于$ 2^{56} $ 的话，会比uint64高效 uint64 long int/long uint64 Bignum ulong integer/string sfixed32 4字节编码 int32 int int int32 Fixnum or Bignum (as required) int integer sfixed64 8字节编码 int64 long int/long int64 Bignum long integer/string bool bool boolean bool bool TrueClass/FalseClass bool boolean string 必须包含utf-8编码或者7-bit ASCII text string String str/unicode string String (UTF-8) string string bytes 任意的字节序列 string ByteString str []byte String (ASCII-8BIT) ByteString string 补充说明： In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit. In all cases, setting values to a field will perform type checking to make sure it is valid. 64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See 2. Python strings are represented as unicode on decode but can be str if an ASCII string is given (this is subject to change). Integer is used on 64-bit machines and string is used on 32-bit machines. 关于标准值类型，还可以参考Scalar Value Types 如果你想了解这些数据是怎么序列化和反序列化的，可以点击 Protocol Buffer Encoding 了解更多关于protobuf编码内容。 分配Tag每一个变量在message内都需要自定义一个唯一的数字Tag，protobuf会根据Tag从数据中查找变量对应的位置，具体原理跟protobuf的二进制数据格式有关。Tag一旦指定，以后更新协议的时候也不能修改，否则无法对旧版本兼容。 Tag的取值范围最小是1，最大是$ 2^{29} $-1，但 19000~19999 是 protobuf 预留的，用户不能使用。 虽然 Tag 的定义范围比较大，但不同 Tag 也会对 protobuf 编码带来一些影响： 1 ~ 15：单字节编码 16 ~ 2047：双字节编码 使用频率高的变量最好设置为1 ~ 15，这样可以减少编码后的数据大小，但由于Tag一旦指定不能修改，所以为了以后扩展，也记得为未来保留一些 1 ~ 15 的 Tag 指定变量规则在 proto3 中，可以给变量指定以下两个规则： singular：0或者1个，但不能多于1个 repeated：任意数量（包括0） 当构建 message 的时候，build 数据的时候，会检测设置的数据跟规则是否匹配 在proto2中，规则为： required：必须有一个 optional：0或者1个 repeated：任意数量（包括0） 注释用//表示注释开头，如 12345message SearchRequest &#123; string query = 1; int32 page_number = 2; // Which page number do we want int32 result_per_page = 3; // Number of results to return per page&#125; 保留变量不被使用上面我们说到，一旦 Tag 指定后就不能变更，这就会带来一个问题，假如在版本1的协议中，我们有个变量： 1int32 number = 1； 在版本2中，我们决定废弃对它的使用，那我们应该如何修改协议呢？注释掉它？删除掉它？如果把它删除了，后来者很可能在定义新变量的时候，使新的变量 Tag = 1 ，这样会导致协议不兼容。那有没有办法规避这个问题呢？我们可以用 reserved 关键字，当一个变量不再使用的时候，我们可以把它的变量名或 Tag 用 reserved 标注，这样，当这个 Tag 或者变量名字被重新使用的时候，编译器会报错 12345message Foo &#123; // 注意，同一个 reserved 语句不能同时包含变量名和 Tag reserved 2, 15, 9 to 11; reserved &quot;foo&quot;, &quot;bar&quot;;&#125; 默认值当解析 message 时，如果被编码的 message 里没有包含某些变量，那么根据类型不同，他们会有不同的默认值： string：默认是空的字符串 byte：默认是空的bytes bool：默认为false numeric：默认为0 enums：定义在第一位的枚举值，也就是0 messages：根据生成的不同语言有不同的表现，参考generated code guide 注意，收到数据后反序列化后，对于标准值类型的数据，比如bool，如果它的值是 false，那么我们无法判断这个值是对方设置的，还是对方压根就没给这个变量设置值。 定义枚举 Enumerations在 protobuf 中，我们也可以定义枚举，并且使用该枚举类型，比如： 123456789101112131415message SearchRequest &#123; string query = 1; int32 page_number = 2; // Which page number do we want int32 result_per_page = 3; // Number of results to return per page enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; Corpus corpus = 4;&#125; 枚举定义在一个消息内部或消息外部都是可以的，如果枚举是 定义在 message 内部，而其他 message 又想使用，那么可以通过 MessageType.EnumType 的方式引用。定义枚举的时候，我们要保证第一个枚举值必须是0，枚举值不能重复，除非使用 option allow_alias = true 选项来开启别名。如： 123456enum EnumAllowingAlias &#123; option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1;&#125; 枚举值的范围是32-bit integer，但因为枚举值使用变长编码，所以不推荐使用负数作为枚举值，因为这会带来效率问题。 如何引用其他 proto 文件在proto语法中，有两种引用其他 proto 文件的方法： import 和 import public，这两者有什么区别呢？下面举个例子说明： 在情景1中， my.proto 不能使用 second.proto 中定义的内容 在情景2中， my.proto 可以使用 second.proto 中定义的内容 情景1和情景2中，my.proto 都可以使用 first.proto 情景1和情景2中，first.proto 都可以使用 second.proto 12// my.protoimport &quot;first.proto&quot;; 123// first.proto//import &quot;second.proto&quot;;import public &quot;second.proto&quot;; 12// second.proto... 升级 proto 文件正确的姿势升级更改 proto 需要遵循以下原则 不要修改任何已存在的变量的 Tag 如果你新增了变量，新生成的代码依然能解析旧的数据，但新增的变量将会变成默认值。相应的，新代码序列化的数据也能被旧的代码解析，但旧代码会自动忽略新增的变量。 废弃不用的变量用 reserved 标注 int32、 uint32、 int64、 uint64 和 bool 是相互兼容的，这意味你可以更改这些变量的类型而不会影响兼容性 sint32 和 sint64 是兼容的，但跟其他类型不兼容 string 和 bytes 可以兼容，前提是他们都是UTF-8编码的数据 fixed32 和 sfixed32 是兼容的, fixed64 和 sfixed64是兼容的 Any 的使用Any可以让你在 proto 文件中使用未定义的类型，具体里面保存什么数据，是在上层业务代码使用的时候决定的，使用 Any 必须导入 import google/protobuf/any.proto 123456import &quot;google/protobuf/any.proto&quot;;message ErrorStatus &#123; string message = 1; repeated google.protobuf.Any details = 2;&#125; Oneof 的使用Oneof 类似union，如果你的消息中有很多可选字段，而同一个时刻最多仅有其中的一个字段被设置的话，你可以使用oneof来强化这个特性并且节约存储空间，如 12345678message LoginReply &#123; oneof test_oneof &#123; string name = 3; string age = 4; &#125; required string status = 1; required string token = 2;&#125; 这样，name 和 age 都是 LoginReply 的成员，但不能给他们同时设置值（设置一个oneof字段会自动清理其他的oneof字段）。 Maps 的使用protobuf 支持定义 map 类型的成员，如： 12map&lt;key_type, value_type&gt; map_field = N;// 举例：map&lt;string, Project&gt; projects = 3; key_type:必须是string或者int value_type：任意类型 使用 map 要注意： Map 类型不能使 repeated Map 是无序的 以文本格式展示时，Map 以 key 来排序 如果有相同的键会导致解析失败 Packages 的使用为了防止不同消息之间的命名冲突，你可以对特定的.proto文件提指定 package 名字。在定义消息的成员的时候，可以指定包的名字： 12package foo.bar;message Open &#123; ... &#125; 123456message Foo &#123; ... // 带上包名 foo.bar.Open open = 1; ...&#125; OptionsOptions 分为 file-level options（只能出现在最顶层，不能在消息、枚举、服务内部使用）、 message-level options（只能在消息内部使用）、field-level options（只能在变量定义时使用） java_package (file option)：指定生成类的包名，如果没有指定此选项，将由关键字package指定包名。此选项只在生成 java 代码时有效 java_multiple_files (file option)：如果为 true， 定义在最外层的 message 、enum、service 将作为单独的类存在 java_outer_classname (file option)：指定最外层class的类名，如果不指定，将会以文件名作为类名 optimize_for (file option)：可选有 [SPEED|CODE_SIZE|LITE_RUNTIME] ，分别是效率优先、空间优先，第三个lite是兼顾效率和代码大小，但是运行时需要依赖 libprotobuf-lite cc_enable_arenas (file option):启动arena allocation，c++代码使用 objc_class_prefix (file option)：Objective-C使用 deprecated (field option)：提示变量已废弃、不建议使用 12345option java_package = &quot;com.example.foo&quot;;option java_multiple_files = true;option java_outer_classname = &quot;Ponycopter&quot;;option optimize_for = CODE_SIZE;int32 old_field = 6 [deprecated=true]; 定义 Services这个其实和gRPC相关，详细可参考：gRPC， 这里做一个简单的介绍要定义一个服务，你必须在你的 .proto 文件中指定 service 123service RouteGuide &#123; ...&#125; 然后在我们的服务中定义 rpc 方法，指定它们的请求的和响应类型。gRPC 允许你定义4种类型的 service 方法 简单RPC客户端使用 Stub 发送请求到服务器并等待响应返回，就像平常的函数调用一样，这是一个阻塞型的调用 12// Obtains the feature at a given position.rpc GetFeature(Point) returns (Feature) &#123;&#125; 服务器端流式 RPC客户端发送请求到服务器，拿到一个流去读取返回的消息序列。客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在响应类型前插入 stream 关键字，可以指定一个服务器端的流方法 12345// Obtains the Features available within the given Rectangle. Results are// streamed rather than returned at once (e.g. in a response message with a// repeated field), as the rectangle may cover a large area and contain a// huge number of features.rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125; 客户端流式 RPC客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在请求类型前指定 stream 关键字来指定一个客户端的流方法 123// Accepts a stream of Points on a route being traversed, returning a// RouteSummary when traversal is completed.rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125; 双向流式 RPC双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。每个流中的消息顺序被预留。你可以通过在请求和响应前加 stream 关键字去制定方法的类型 123// Accepts a stream of RouteNotes sent while a route is being traversed,// while receiving other RouteNotes (e.g. from other users).rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125; 代码生成使用 protoc 工具可以把编写好的 proto 文件“编译”为Java, Python, C++, Go, Ruby, JavaNano, Objective-C,或C#代码， protoc 可以从点击这里进行下载。protoc 的使用方式如下： 1protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto 参数说明： IMPORT_PATH：指定 proto 文件的路径，如果没有指定， protoc 会从当前目录搜索对应的 proto 文件，如果有多个路径，那么可以指定多次--proto_path 指定各语言代码的输出路径 –cpp_out：生成c++代码 java_out ：生成java代码 python_out ：生成python代码 go_out ：生成go代码 ruby_out ：生成ruby代码 javanano_out ：适合运行在有资源限制的平台（如Android）的java代码 objc_out ：生成 Objective-C代码 csharp_out ：生成C#代码 php_out ：生成PHP代码]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰模式]]></title>
    <url>%2F2017%2F03%2F09%2Fpattern_decorator%2F</url>
    <content type="text"><![CDATA[概述装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责，就增加功能来说装饰模式比生成子类更为灵活。它通过创建一个包装对象，也就是装饰来包裹真实的对象 情景举例我们先来分析这样一个画图形的需求： 它能绘制各种背景，如红色、蓝色、绿色 它能绘制形状，如三角形，正方形，圆形 它能给形状加上阴影 就先列这三个简单的需求吧，下面让我们比较下各种实现的优缺点 丑陋的实现来看看我们用继承是如何实现的，首先，抽象出一个Shape接口我想大家都不会有意见的是不是？ 12345678910/** * @author HansChen */public interface Shape &#123; /** * 绘制图形 */ void draw();&#125; 然后我们定义各种情况下的子类，结构如下，看到这么多的子类，是不是有点要爆炸的感觉？真是想想都可怕 而且如果再新增一种需求，比如现在要画椭圆，那么维护的人员估计就要爆粗了吧？ 为了避免写出上面的代码，聪明的童鞋们可能会提出第二种方案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author HansChen */public class ShapeImpl implements Shape &#123; enum Type &#123; Circle, Square, Trilatera &#125; enum Color &#123; Red, Green, Blue &#125; private Type type; private Color color; private boolean shadow; public ShapeImpl() &#123; &#125; public Type getType() &#123; return type; &#125; public void setType(Type type) &#123; this.type = type; &#125; public Color getColor() &#123; return color; &#125; public void setColor(Color color) &#123; this.color = color; &#125; public boolean isShadow() &#123; return shadow; &#125; public void setShadow(boolean shadow) &#123; this.shadow = shadow; &#125; @Override public void draw() &#123; // TODO: 2017/3/9 根据属性情况画出不同的图 &#125;&#125; 这样，根据不同的画图需求，只需要设置不同的属性就可以了，这样确实避免了类爆炸增长的问题，但这种方式违反了开放封闭原则，比如画正方形的方式变了，需要对ShapeImpl进行修改，或者如果新增需求，如画椭圆，也需要对ShapeImpl进行修改。而且这个类不方便扩展，子类将继承一些对自身并不合适的方法。 装饰模式概念介绍 装饰模式（Decorator）也叫包装器模式（Wrapper），是指动态地给一个对象添加一些额外的职责 以下情况使用Decorator模式： 需要扩展一个类的功能，或给一个类添加附加职责。 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类 但这种灵活也会带来一些缺点，这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂 下面来看看装饰模式的结构： Component抽象组件，是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。（注：在装饰模式中，必然有一个最基本、最核心、最原始的接口或者抽象类充当Component抽象组件） ConcreteComponent具体组件，是最核心、最原始、最基本的接口或抽象类的实现，我们需要装饰的就是它 Decorator装饰角色， 一般是一个抽象类，实现接口或者抽象方法，它的属性里必然有一个private变量指向Component抽象组件。 具体装饰角色，如上图中的ConcreteDecoratorA和ConcreteDecoratorB，我们要把我们最核心的、最原始的、最基本的东西装饰成其它东西。 代码示例如下： 1234567 /** * @author HansChen */public interface Component &#123; void operation();&#125; 1234567public class ConcreteComponent implements Component &#123; @Override public void operation() &#123; System.out.print("do something"); &#125;&#125; 12345678910111213public class Decorator implements Component &#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125; 123456789101112public class ConcreteDecoratorA extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); System.out.println("do something"); &#125;&#125; 123456789101112public class ConcreteDecoratorB extends Decorator &#123; public ConcreteDecoratorB(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); System.out.println("do something"); &#125;&#125; 上面说了一堆结构和示例代码，但大家可能还是不太好理解，下面用装饰模式来重新实现画图的功能 用装饰模式实现需求先上结构图 首先定义可动态扩展对象的抽象 1234567public interface Shape &#123; /** * 绘制图形 */ void draw();&#125; 定义具体的组件，每一个组件代表一个形状 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.print("正方形"); &#125;&#125; 1234567public class Trilateral implements Shape &#123; @Override public void draw() &#123; System.out.print("三角形"); &#125;&#125; 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.print("圆形"); &#125;&#125; 定义可装饰者的抽象类 12345678910111213public class ShapeDecorator implements Shape &#123; private Shape shape; public ShapeDecorator(Shape shape) &#123; this.shape = shape; &#125; @Override public void draw() &#123; shape.draw(); &#125;&#125; 定义具体的装饰者 123456789101112public class Blue extends ShapeDecorator &#123; public Blue(Shape shape) &#123; super(shape); &#125; @Override public void draw() &#123; super.draw(); System.out.print(" 蓝色"); &#125;&#125; 123456789101112public class Green extends ShapeDecorator &#123; public Green(Shape shape) &#123; super(shape); &#125; @Override public void draw() &#123; super.draw(); System.out.print(" 绿色"); &#125;&#125; 123456789101112public class Red extends ShapeDecorator &#123; public Red(Shape shape) &#123; super(shape); &#125; @Override public void draw() &#123; super.draw(); System.out.print(" 红色"); &#125;&#125; 123456789101112public class Shadow extends ShapeDecorator &#123; public Shadow(Shape shape) &#123; super(shape); &#125; @Override public void draw() &#123; super.draw(); System.out.print(" 有阴影"); &#125;&#125; 好了，现在让我们看看具体怎么使用： 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; //正方形 红色 有阴影 Shape shape = new Square(); shape = new Red(shape); shape = new Shadow(shape); shape.draw(); //圆形 绿色 shape = new Circle(); shape = new Green(shape); shape.draw(); //三角形 蓝色 有阴影 shape = new Trilateral(); shape = new Blue(shape); shape = new Shadow(shape); shape.draw(); &#125;&#125; 可以看到，装饰模式是非常灵活的，通过不同的装饰，实现不同的效果 装饰模式的应用举例这里再列举一些用到了装饰模式的情景，童鞋们可以根据这些场景加深对装饰模式的理解 Java中IO设计 Android中Context和ContextWrapper的设计 总结装饰模式是为已有功能动态地添加功能的一种方式，它把每个要装饰的功能放在单独的类中，并让这个类包括要装饰的对象，有效地把核心职能和装饰功能区分开了。但它带来灵活的同时，也容易导致别人不了解自己的设计方式，不知如何使用。就像Java中I/O库，人们第一次接触的时候，往往无法轻易理解它。这其中的平衡取舍，就看自己咯]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
        <tag>包装器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之桥接模式]]></title>
    <url>%2F2017%2F03%2F01%2Fpattern_bridge%2F</url>
    <content type="text"><![CDATA[场景问题发送消息现在我们要实现这样一个功能：发送消息。从业务上看，消息又分成普通消息、加急消息和特急消息多种，不同的消息类型，业务功能处理是不一样的，比如加急消息是在消息上添加“加急”字样，而特急消息除了添加特急外，还会做一条催促的记录，多久不完成会继续催促。从发送消息的手段上看，又有系统内短消息、手机短消息、邮件等等。现在要实现这样的发送提示消息的功能，该如何实现呢？ 不用模式的解决方案实现简化版本先实现一个简单点的版本：消息只是实现发送普通消息，发送的方式先实现系统内短消息和邮件。其它的功能，等这个版本完成过后，再继续添加，这样先把问题简单化，实现起来会容易一点。由于发送普通消息会有两种不同的实现方式，为了让外部能统一操作，因此，把消息设计成接口，然后由两个不同的实现类，分别实现系统内短消息方式和邮件发送消息的方式。此时系统结构如下： 先来看看消息的统一接口，示例代码如下： 12345678910public interface Message &#123; /** * 发送消息 * * @param message 要发送的消息内容 * @param toUser 消息发送的目的人员 */ void send(String message, String toUser);&#125; 再来分别看看两种实现方式，这里只是为了示意，并不会真的去发送Email和站内短消息，先看站内短消息的方式，示例代码如下： 1234567public class CommonMessageSMS implements Message &#123; @Override public void send(String message, String toUser) &#123; System.out.println("使用站内短消息的方式，发送消息'" + message + "'给" + toUser); &#125;&#125; 同样的，实现以Email的方式发送普通消息，示例代码如下： 1234567public class CommonMessageEmail implements Message &#123; @Override public void send(String message, String toUser) &#123; System.out.println("使用Email的方式，发送消息'" + message + "'给" + toUser); &#125;&#125; 实现发送加急消息上面的实现，看起来很简单，对不对。接下来，添加发送加急消息的功能，也有两种发送的方式，同样是站内短消息和Email的方式。加急消息的实现跟普通消息不同，加急消息会自动在消息上添加加急，然后再发送消息；另外加急消息会提供监控的方法，让客户端可以随时通过这个方法来了解对于加急消息处理的进度，比如：相应的人员是否接收到这个信息，相应的工作是否已经开展等等。因此加急消息需要扩展出一个新的接口，除了基本的发送消息的功能，还需要添加监控的功能，这个时候，系统的结构如图所示： 先看看扩展出来的加急消息的接口，示例代码如下： 12345678910public interface UrgencyMessage extends Message &#123; /** * 监控某消息的处理过程 * * @param messageId 被监控的消息的编号 * @return 包含监控到的数据对象，这里示意一下，所以用了Object */ Object watch(String messageId);&#125; 相应的实现方式还是发送站内短消息和Email两种，同样需要两个实现类来分别实现这两种方式，先看站内短消息的方式，示例代码如下： 1234567891011121314public class UrgencyMessageSMS implements UrgencyMessage &#123; @Override public void send(String message, String toUser) &#123; message = "加急：" + message; System.out.println("使用站内短消息的方式，发送消息'" + message + "'给" + toUser); &#125; @Override public Object watch(String messageId) &#123; //获取相应的数据，组织成监控的数据对象，然后返回 return null; &#125;&#125; 再看看Emai的方式，示例代码如下： 1234567891011121314public class UrgencyMessageEmail implements UrgencyMessage &#123; @Override public void send(String message, String toUser) &#123; message = "加急：" + message; System.out.println("使用Email的方式，发送消息'" + message + "'给" + toUser); &#125; @Override public Object watch(String messageId) &#123; //获取相应的数据，组织成监控的数据对象，然后返回 return null; &#125;&#125; 事实上，在实现加急消息发送的功能上，可能会使用前面发送不同消息的功能，也就是让实现加急消息处理的对象继承普通消息的相应实现，这里为了让结构简单一点，清晰一点，所以没有这样做。 有何问题上面这样实现，好像也能满足基本的功能要求，可是这么实现好不好呢？有没有什么问题呢？我们继续向下来添加功能实现，为了简洁，就不再去进行代码示意了，通过实现的结构示意图就可以看出实现上的问题。 继续添加特急消息的处理特急消息不需要查看处理进程，只要没有完成，就直接催促，也就是说，对于特急消息，在普通消息的处理基础上，需要添加催促的功能。而特急消息、还有催促的发送方式，相应的实现方式还是发送站内短消息和Email两种，此时系统的结构如图所示： 仔细观察上面的系统结构示意图，会发现一个很明显的问题，那就是：通过这种继承的方式来扩展消息处理，会非常不方便。你看，实现加急消息处理的时候，必须实现站内短消息和Email两种处理方式，因为业务处理可能不同；在实现特急消息处理的时候，又必须实现站内短消息和Email这两种处理方式。这意味着，以后每次扩展一下消息处理，都必须要实现这两种处理方式，是不是很痛苦，这还不算完，如果要添加新的实现方式呢？继续向下看吧。 继续添加发送手机消息的处理方式如果看到上面的实现，你还感觉问题不是很大的话，继续完成功能，添加发送手机消息的处理方式仔细观察现在的实现，如果要添加一种新的发送消息的方式，是需要在每一种抽象的具体实现里面，都要添加发送手机消息的处理的。也就是说：发送普通消息、加急消息和特急消息的处理，都可以通过手机来发送。这就意味着，需要添加三个实现。此时系统结构如图所示： 这下能体会到这种实现方式的大问题了吧。 小结一下出现的问题采用通过继承来扩展的实现方式，有个明显的缺点：扩展消息的种类不太容易，不同种类的消息具有不同的业务，也就是有不同的实现，在这种情况下，每个种类的消息，需要实现所有不同的消息发送方式。更可怕的是，如果要新加入一种消息的发送方式，那么会要求所有的消息种类，都要加入这种新的发送方式的实现。要是考虑业务功能上再扩展一下呢？比如：要求实现群发消息，也就是一次可以发送多条消息，这就意味着很多地方都得修改，太恐怖了。那么究竟该如何实现才能既实现功能，又能灵活的扩展呢？ 解决方案桥接模式来解决用来解决上述问题的一个合理的解决方案，就是使用桥接模式。那么什么是桥接模式呢？桥接模式定义： 将抽象部分和实现部分分离，使它们都可以独立地变化 应用桥接模式来解决的思路 仔细分析上面的示例，根据示例的功能要求，示例的变化具有两个维度，一个维度是抽象的消息这边，包括普通消息、加急消息和特急消息，这几个抽象的消息本身就具有一定的关系，加急消息和特急消息会扩展普通消息；另一个维度在具体的消息发送方式上，包括站内短消息、Email和手机短信息，这几个方式是平等的，可被切换的方式。这两个维度一共可以组合出9种不同的可能性来。现在出现问题的根本原因，就在于消息的抽象和实现是混杂在一起的，这就导致了，一个维度的变化，会引起另一个维度进行相应的变化，从而使得程序扩展起来非常困难。要想解决这个问题，就必须把这两个维度分开，也就是将抽象部分和实现部分分开，让它们相互独立，这样就可以实现独立的变化，使扩展变得简单。桥接模式通过引入实现的接口，把实现部分从系统中分离出去；那么，抽象这边如何使用具体的实现呢？肯定是面向实现的接口来编程了，为了让抽象这边能够很方便的与实现结合起来，把顶层的抽象接口改成抽象类，在里面持有一个具体的实现部分的实例。这样一来，对于需要发送消息的客户端而言，就只需要创建相应的消息对象，然后调用这个消息对象的方法就可以了，这个消息对象会调用持有的真正的消息发送方式来把消息发送出去。也就是说客户端只是想要发送消息而已，并不想关心具体如何发送。 模式结构和说明桥接模式的结构图： Abstraction：抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。 RefinedAbstraction：扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。 Implementor：定义实现部分的接口，这个接口不用和Abstraction里面的方法一致，通常是由Implementor接口提供基本的操作，而Abstraction里面定义的是基于这些基本操作的业务方法，也就是说Abstraction定义了基于这些基本操作的较高层次的操作。 ConcreteImplementor：真正实现Implementor接口的对象。 桥接模式示例代码先看看Implementor接口的定义，示例代码如下： 1234public interface Implementor &#123; void operationImpl();&#125; 再看看Abstraction接口的定义，注意一点，虽然说是接口定义，但其实是实现成为抽象类。示例代码如下： 1234567891011121314151617181920public abstract class Abstraction &#123; /** * 持有一个实现部分的对象 */ protected Implementor impl; /** * 构造方法，传入实现部分的对象 * * @param impl 实现部分的对象 */ public Abstraction(Implementor impl) &#123; this.impl = impl; &#125; public void operation() &#123; impl.operationImpl(); &#125;&#125; 该来看看具体的实现了，示例代码如下： 123456public class ConcreteImplementorA implements Implementor &#123; public void operationImpl() &#123; //真正的实现 &#125;&#125; 另外一个实现，示例代码如下： 123456public class ConcreteImplementorB implements Implementor &#123; public void operationImpl() &#123; //真正的实现 &#125;&#125; 最后来看看扩展Abstraction接口的对象实现，示例代码如下： 12345678910111213141516public class RefinedAbstraction extends Abstraction &#123; public RefinedAbstraction(Implementor impl) &#123; super(impl); &#125; /** * 示例操作，实现一定的功能 */ public void otherOperation() &#123; //实现一定的功能，可能会使用具体实现部分的实现方法， //但是本方法更大的可能是使用Abstraction中定义的方法， //通过组合使用Abstraction中定义的方法来完成更多的功能 &#125;&#125; 使用桥接模式重写示例学习了桥接模式的基础知识过后，该来使用桥接模式重写前面的示例了。通过示例，来看看使用桥接模式来实现同样的功能，是否能解决“既能方便的实现功能，又能有很好的扩展性”的问题。要使用桥接模式来重新实现前面的示例，首要任务就是要把抽象部分和实现部分分离出来，分析要实现的功能，抽象部分就是各个消息的类型所对应的功能，而实现部分就是各种发送消息的方式。其次要按照桥接模式的结构，给抽象部分和实现部分分别定义接口，然后分别实现它们就可以了。 从简单功能开始从相对简单的功能开始，先实现普通消息和加急消息的功能，发送方式先实现站内短消息和Email这两种。使用桥接模式来实现这些功能的程序结构如图所示 还是看看代码实现，会更清楚一些。先看看消息发送器接口，示例代码如下： 123456789101112131415/** * 消息发送器 * * @author HansChen */public interface MessageSender &#123; /** * 发送消息 * * @param message 要发送的消息内容 * @param toUser 消息发送的目的人员 */ void send(String message, String toUser);&#125; 再看看抽象部分定义的接口，示例代码如下： 12345678910111213141516171819202122232425262728293031/** * 抽象的消息对象 * * @author HansChen */public class AbstractMessageController &#123; /** * 持有一个实现部分的对象 */ MessageSender impl; /** * 构造方法，传入实现部分的对象 * * @param impl 实现部分的对象 */ AbstractMessageController(MessageSender impl) &#123; this.impl = impl; &#125; /** * 发送消息，转调实现部分的方法 * * @param message 要发送的消息内容 * @param toUser 消息发送的目的人员 */ protected void sendMessage(String message, String toUser) &#123; impl.send(message, toUser); &#125;&#125; 看看如何具体的实现发送消息，先看站内短消息的实现吧，示例代码如下： 123456789101112/** * 以站内短消息的方式发送消息 * * @author HansChen */public class MessageSenderSMS implements MessageSender &#123; @Override public void send(String message, String toUser) &#123; System.out.println("使用站内短消息的方式，发送消息'" + message + "'给" + toUser); &#125;&#125; 再看看Email方式的实现，示例代码如下： 123456789101112/** * 以Email的方式发送消息 * * @author HansChen */public class MessageSenderEmail implements MessageSender &#123; @Override public void send(String message, String toUser) &#123; System.out.println("使用Email的方式，发送消息'" + message + "'给" + toUser); &#125;&#125; 接下来该看看如何扩展抽象的消息接口了，先看普通消息的实现，示例代码如下： 123456789101112public class CommonMessageController extends AbstractMessageController &#123; public CommonMessageController(MessageSender impl) &#123; super(impl); &#125; @Override public void sendMessage(String message, String toUser) &#123; //对于普通消息，什么都不干，直接调父类的方法，把消息发送出去就可以了 super.sendMessage(message, toUser); &#125;&#125; 再看看加急消息的实现，示例代码如下： 1234567891011121314151617181920212223public class UrgencyMessageController extends AbstractMessageController &#123; public UrgencyMessageController(MessageSender impl) &#123; super(impl); &#125; @Override protected void sendMessage(String message, String toUser) &#123; message = "加急：" + message; super.sendMessage(message, toUser); &#125; /** * 扩展自己的新功能：监控某消息的处理过程 * * @param messageId 被监控的消息的编号 * @return 包含监控到的数据对象，这里示意一下，所以用了Object */ public Object watch(String messageId) &#123; //获取相应的数据，组织成监控的数据对象，然后返回 return null; &#125;&#125; 添加功能看了上面的实现，发现使用桥接模式来实现也不是很困难啊，关键得看是否能解决前面提出的问题，那就来添加还未实现的功能看看，添加对特急消息的处理，同时添加一个使用手机发送消息的方式。该怎么实现呢？很简单，只需要在抽象部分再添加一个特急消息的类，扩展抽象消息就可以把特急消息的处理功能加入到系统中了；对于添加手机发送消息的方式也很简单，在实现部分新增加一个实现类，实现用手机发送消息的方式，也就可以了。这么简单？好像看起来完全没有了前面所提到的问题。的确如此，采用桥接模式来实现过后，抽象部分和实现部分分离开了，可以相互独立的变化，而不会相互影响。因此在抽象部分添加新的消息处理，对发送消息的实现部分是没有影响的；反过来增加发送消息的方式，对消息处理部分也是没有影响的。 接着看看代码实现，先看看新的特急消息的处理类，示例代码如下： 12345678910111213141516public class SpecialUrgencyMessageController extends AbstractMessageController &#123; public SpecialUrgencyMessageController(MessageSender impl) &#123; super(impl); &#125; @Override protected void sendMessage(String message, String toUser) &#123; message = "特急：" + message; super.sendMessage(message, toUser); &#125; public void hurry(String messageId) &#123; //执行催促的业务，发出催促的信息 &#125;&#125; 再看看使用手机短消息的方式发送消息的实现，示例代码如下： 1234567public class MessageSenderMobile implements MessageSender &#123; @Override public void send(String message, String toUser) &#123; System.out.println("使用手机的方式，发送消息'" + message + "'给" + toUser); &#125;&#125; 测试一下功能看了上面的实现，可能会感觉得到，使用桥接模式来实现前面的示例过后，添加新的消息处理，或者是新的消息发送方式是如此简单，可是这样实现，好用吗？写个客户端来测试和体会一下，示例代码如下： 12345678910111213141516171819202122232425262728293031public class Client &#123; public static void main(String[] args) &#123; //创建具体的实现对象 MessageSender impl = new MessageSenderSMS(); //创建一个普通消息对象 AbstractMessageController controller = new CommonMessageController(impl); controller.sendMessage("请喝一杯茶", "小李"); //创建一个紧急消息对象 controller = new UrgencyMessageController(impl); controller.sendMessage("请喝一杯茶", "小李"); //创建一个特急消息对象 controller = new SpecialUrgencyMessageController(impl); controller.sendMessage("请喝一杯茶", "小李"); //把实现方式切换成手机短消息，然后再实现一遍 impl = new MessageSenderMobile(); controller = new CommonMessageController(impl); controller.sendMessage("请喝一杯茶", "小李"); controller = new UrgencyMessageController(impl); controller.sendMessage("请喝一杯茶", "小李"); controller = new SpecialUrgencyMessageController(impl); controller.sendMessage("请喝一杯茶", "小李"); &#125;&#125; 运行结果如下： 123456使用站内短消息的方式，发送消息&apos;请喝一杯茶&apos;给小李使用站内短消息的方式，发送消息&apos;加急：请喝一杯茶&apos;给小李使用站内短消息的方式，发送消息&apos;特急：请喝一杯茶&apos;给小李使用手机的方式，发送消息&apos;请喝一杯茶&apos;给小李使用手机的方式，发送消息&apos;加急：请喝一杯茶&apos;给小李使用手机的方式，发送消息&apos;特急：请喝一杯茶&apos;给小李 前面三条是使用的站内短消息，后面三条是使用的手机短消息，正确的实现了预期的功能。看来前面的实现应该是正确的，能够完成功能，且能灵活扩展。 广义桥接-Java中无处不桥接使用Java编写程序，一个很重要的原则就是“面向接口编程”，说得准确点应该是“面向抽象编程”，由于在Java开发中，更多的使用接口而非抽象类，因此通常就说成“面向接口编程”了。接口把具体的实现和使用接口的客户程序分离开来，从而使得具体的实现和使用接口的客户程序可以分别扩展，而不会相互影响。 桥接模式中的抽象部分持有具体实现部分的接口，最终目的是什么，还不是需要通过调用具体实现部分的接口中的方法，来完成一定的功能，这跟直接使用接口没有什么不同，只是表现形式有点不一样。再说，前面那个使用接口的客户程序也可以持有相应的接口对象，这样从形式上就一样了。 也就是说，从某个角度来讲，桥接模式不过就是对“面向抽象编程”这个设计原则的扩展。正是通过具体实现的接口，把抽象部分和具体的实现分离开来，抽象部分相当于是使用实现部分接口的客户程序，这样抽象部分和实现部分就松散耦合了，从而可以实现相互独立的变化。 这样一来，几乎可以把所有面向抽象编写的程序，都视作是桥接模式的体现，至少算是简化的桥接模式，就算是广义的桥接吧。而Java编程很强调“面向抽象编程”，因此，广义的桥接，在Java中可以说是无处不在。 桥接模式在Android中的应用如果各位童鞋看到这里仍然对桥接模式还是不太清楚，在这里给大家举个在Android中非常常用的桥接模式栗子：AbsListView与ListAdapter之间的桥接模式。童鞋们可以根据这个栗子体会一下桥接模式的好处。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2016%2F12%2F27%2Fpattern_proxy%2F</url>
    <content type="text"><![CDATA[概述我们执行一个功能的函数时，经常需要在其中写入与功能不是直接相关但很有必要的代码，如日志记录、信息发送、安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦： 枝节性代码游离在功能性代码之外，它下是函数的目的 枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合 枝节性代码带来的耦合度会造成功能性代码移植困难，可重用性降低 毫无疑问，枝节性代码和功能性代码需要分开来才能降低耦合程度，我们可以使用代理模式(委托模式)完成这个要求。代理模式的作用是：为其它对象提供一种代理以控制对这个对象的访问。在某些情况下，一 个客户不想直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。 代理模式一般涉及到三个角色： 抽象角色：声明真实对象和代理对象的共同接口 代理角色：代理对象内部包含有真实角色的引用，从而可以操作真实角色，同时代理对象 与真实对象有相同的接口，能在任何时候代替真实对象，代理对象可以在执行真实对 象前后加入特定的逻辑以实现功能的扩展。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象 常见的代理应用场景有： 远程代理：对一个位于不同的地址空间对象提供一个局域代表对象，如RMI中的stub 虚拟代理：根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建 保护代理：控制对一个对象的访问权限 智能引用：提供比目标对象额外的服务和功能 接下来，我们用代码来说明什么是代理模式 代理模式UML图先看看代理模式的结构图： 代码下面给出一个小栗子说明代理模式，先定义一个抽象角色，也就是一个公共接口，声明一些需要代理的方法,本文定义一个Subject接口，为了简单说明，只是在里面定义一个request方法： 1234public interface Subject &#123; void request();&#125; 定义Subject的实现类RealSubject，它是一个真实角色： 1234567public class RealSubject implements Subject &#123; @Override public void request() &#123; System.out.print("do real request"); &#125;&#125; 定义一个代理角色ProxySubject，跟RealSubject一样，它也继承了Subject接口： 123456789101112131415public class ProxySubject implements Subject &#123; private RealSubject mSubject; public ProxySubject() &#123; mSubject = new RealSubject(); &#125; @Override public void request() &#123; System.out.print("before"); mSubject.request(); System.out.print("after"); &#125;&#125; 客户端调用代码 12345678public class Client &#123; public static void main(String[] args) &#123; Subject subject = new ProxySubject(); subject.request(); &#125;&#125; 这样，一个简易的代理模式模型就建立了，客户端在使用过程中，无需关注RealSubject，只需要关注ProxySubject就行了，并且可以在ProxySubject中插入一些非功能信的代码，比如输出Log，统计执行时间等等 远程代理远程代理，对一个位于不同的地址空间对象提供一个局域代表对象。这样说大家可能比较抽象，不太能理解，但其实童鞋们可能在就接触过了，在Android中，Binder的使用就是典型的远程代理。比如ActivityManager： 在启动Activity的时，会调用ActivityManager的startActivity方法，我们看看Activity是怎么获取的： 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; // 返回代理类 return new ActivityManagerProxy(obj);&#125; 可以看到，最终是返回了一个ActivityManager的代理类，因为真正的ActivityManager是运行在内核空间的，Android应用无法直接访问得到，那么就可以借助这个ActivityManagerProxy，通过Binder与真正的ActivityManager，也就是ActivityManagerService交互。其中ActivityManagerService和ActivityManagerProxy都实现了同一个接口：IActivityManager。这个就是Android中典型的代理模式的栗子了。至于ActivityManagerService和ActivityManagerProxy是如何通过Binder实现远程调用，这个就是另一个话题Binder的内容了，这里不再做阐述 延迟加载根据需要将一个资源消耗很大或者比较复杂的对象，延迟加载，在真正需要的时候才创建。假设我们创建RealSubject需要耗费一定的资源，那么，我们可以把创建它延迟到实际调用的时候，优化Client初始化速度，比如，这样修改ProxySubject以达到延迟加载: 12345678910111213141516public class ProxySubject implements Subject &#123; private RealSubject mSubject; public ProxySubject() &#123; &#125; @Override public void request() &#123; // 延时加载 if (mSubject == null) &#123; mSubject = new RealSubject(); &#125; mSubject.request(); &#125;&#125; Client在实例化ProxySubject的时候，不需消耗资源，而是等到真正调用request的时候，才会加载RealSubject，达到延时加载的效果 保护代理可以在Proxy类中加入进行权限，验证是否具有执行真实代码的权限，只有权限验证通过了才进行真实对象的调用 1234567891011121314151617public class ProxySubject implements Subject &#123; private RealSubject mSubject; private User mUser; public ProxySubject(User user) &#123; this.mUser = user; &#125; @Override public void request() &#123; // 验证权限 if (mUser.isLogin()) &#123; mSubject.request(); &#125; &#125;&#125; 额外功能通过引入代理类，可以方便地在功能性代码前后插入扩展，如Log输出，调用统计等，实现对原代码的无侵入式代码扩展，如： 123456789101112131415public class ProxySubject implements Subject &#123; private RealSubject mSubject; public ProxySubject() &#123; mSubject = new RealSubject(); &#125; @Override public void request() &#123; System.out.print("Log: before"); mSubject.request(); System.out.print("Log: after"); &#125;&#125; 静态代理和动态代理静态代理和动态代理的概念和使用可以参考我另一篇文章：Java动态代理：http://blog.csdn.net/shensky711/article/details/52872249]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入利器 - Dagger ‡]]></title>
    <url>%2F2016%2F12%2F18%2Fdagger2%2F</url>
    <content type="text"><![CDATA[概述在开发过程中，为了实现解耦，我们经常使用依赖注入，常见的依赖注入方式有： 构造方法注入：在构造方法中把依赖作为参数传递进去 setter方法注入：添加setter方法，把依赖传递进去 接口注入：把注入方法抽到一个接口中，然后实现该接口，把依赖传递进去 下面用一个小栗子来说明三种方式的用法： 12345678910111213141516171819202122public class PersonService implements DependencyInjecter &#123; private PersonDao personDao; // 构造方法注入 public PersonService(PersonDao personDao) &#123; this.personDao = personDao; &#125; // setter方法注入 public void setPersonDao(PersonDao personDao) &#123; this.personDao = personDao; &#125; // 接口注入：实现DependencyInjecter接口 @Override public void injectPersonDao(PersonDao personDao) &#123; this.personDao = personDao; &#125; ... ... &#125; 我们来看下使用一般的依赖注入方法时，代码会是怎么样的： 123456789101112131415public class MainActivity extends AppCompatActivity &#123; private PersonService mService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建PersonService的依赖：personDao PersonDao personDao = new PersonDaoImpl(); // 通过构造方法注入依赖 mService = new PersonService(personDao); &#125;&#125; 看起来还好是吧？但现实情况下，依赖情况往往是比较复杂的，比如很可能我们的依赖关系如下图： PersonDaoImpl依赖类A，类A依赖B，B依赖C和D…在这种情况下，我们就要写出下面这样的代码了： 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private PersonService mService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建依赖D D d = new D(); // 创建依赖C C c = new C(); // 创建依赖B B b = new B(c, d); // 创建依赖A A a = new A(b); // 创建PersonService的依赖：personDao PersonDao personDao = new PersonDaoImpl(a); // 通过构造方法注入依赖 mService = new PersonService(personDao); &#125;&#125; MainActivity只是想使用PersonService而已，却不得不关注PersonService的依赖是什么、PersonDaoImpl依赖的依赖是什么，需要把整个依赖关系搞清楚才能使用PersonService。而且还有一个不好的地方，一旦依赖关系变更了，比如A不再依赖B了，那么就得修改所有创建A的地方。那么，有没有更好的方式呢？Dagger就是为此而生的，让我们看看使用Dagger后，MainActivity会变成什么模样： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; @Inject PersonService mService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Dagger注入，读者现在可先不关注里面做了什么操作 DaggerPersonServiceComponent.create().inject(MainActivity.this); // 注意，mService已经是非空了，可以正常使用 mService.update(1, "HansChen"); ...... &#125;&#125; 之前创建A、B、C、D、PersonDaoImpl等依赖的代码全不见了，只需要调用一个注入语句就全搞定了。调用了注入语句之后，mService就可以正常使用了，是不是挺方便呢？至于这句注入语句具体干了什么，读者现在可以先不管，后面会有详细说明，这里只是做一个使用演示而已。 我们大概猜想一下，在MainActivity使用PersonService需要做哪些？ 分析生成依赖关系图，如PersonService–&gt;PersonDaoImpl–&gt;A–&gt;B–&gt;C&amp;D 根据依赖关系图获取相关依赖，比如依次创建D、C、B、A、PersonDaoImpl、PersonService的实例 把生成的PersonService实例传递给MainActivity的mService成员变量 其实Dagger做的也就是上面这些事情了，接下来就让我们真正开始学习Dagger吧 声明需要注入的对象首先我们应该用javax.inject.Inject去注解需要被自动注入的对象，@Inject是Java标准的依赖注入（JSR-330）注解。比如下面栗子中，需要注入的对象就是MainActivity的mService。这里有个要注意的地方，被@Inject注解的变量不能用private修饰 1234567public class MainActivity extends AppCompatActivity &#123; // 注意，不能被private修饰 @Inject PersonService mService; ......&#125; 如何实例化出依赖？在执行依赖注入的时候，Dagger会查找@Inject注解的成员变量，并尝试获取该类的实例，Dagger最直接的方式就是直接new出相应的对象了。实例化对象的时候，会调用对象的构造方法，但假如有多个构造方法，具体用哪个构造方法来实例化对象？Dagger肯定是不会帮我们“擅自做主”的，用哪个构造方法来实例化对象应该是由我们做主的，所以我们需要给相应的构造方法添加@Inject注解。当Dagger需要实例化该对象的时候，会调用@Inject注解的构造方法来实例化对象： 123456789101112public class PersonService implements DependencyInjecter &#123; private PersonDao personDao; // 用@Inject注解，相当于告诉Dagger需要实例化PersonService的时候，请调用这个构造方法 @Inject public PersonService(PersonDao personDao) &#123; this.personDao = personDao; &#125; ......&#125; 聪明的你应该发现了，调用PersonService的构造方法需要传入PersonDao实例，所以要实例化PersonService，必须先要实例化PersonDao，Dagger会帮我们自动分析出这个依赖关系，并把它添加到依赖关系图里面！Dagger会尝试先去实例化一个PersonDao,如果PersonDao又依赖于另外一个对象A，那么就先尝试去实例化A……以此类推，是不是很像递归？当所有依赖都被实例化出来之后，我们的PersonService当然也被构造出来了。 问题又来了，如果PersonDao是一个接口呢？Dagger怎么知道这个接口应该怎么实现？答案是不知道的，那么Dagger怎么实例化出一个接口出来？这个就是Module存在的意义之一了。关于Module的讲解我们会在后面详细说明，我们现在只要知道，Module里面会定义一些方法，这些方法会返回我们的依赖，就像： 1234567891011@Modulepublic class PersonServiceModule &#123; /** * 提供PersonDao接口实例 */ @Provides PersonDao providePersonDao(A a) &#123; return new PersonDaoImpl(a); &#125;&#125; Dagger根据需求获取一个实例的时候，并不总是通过new出来的，它会优先查找Module中是否有返回相应实例的方法，如果有，就调用Module的方法来获取实例。 比如你用@Inject注解了一个成员变量，Dagger会查找Module中是否有用@Provides注解的，返回该类实例的方法，有的话就会调用provide方法来获得实例，然后注入，如果没有的话Dagger就会尝试new出一个实例。就像我们现在这个栗子，PersonService依赖于PersonDao接口，Dagger不能直接为我们new出一个接口，但我们可以提供一个Module，在Module中定义一个返回PersonDao接口实例的方法，这样，Dagger就可以解决实例化PersonDao的问题了。 我们再梳理一下流程，如果我们用@Inject注解了一个成员变量，并调用注入代码之后，Dagger会这样处理： 查找Module中是否有用@Provides注解的，返回该类实例的方法 如果有，就调用那个provide方法来获得实例，然后注入 如果没有，就尝试调用相应的类中被@Inject注解的构造方法new出一个实例，然后注入 如果没有一个构造方法被@Inject注解，Dagger会因不能满足依赖而出错 所以假如一个变量被@Inject注解，要么在Module中提供provide方法获取实例，要么该类提供一个被@Inject注解的构造方法，否则Dagger会出错 Module的使用一般而言，Dagger会获取所有依赖的实例，比如当需要一个TestBean的时候，会通过new TestBean()创建实例并注入到类中。但是，以下情况会就不好处理了： 需要生成的是一个接口，而Dagger不能直接实例化接口 不能在第三方库的类中添加注解 可配置的对象必须是配置的 为了解决以上问题，我们需要定义一个被@Module注解的类，在里面定义用@Provides注解的方法。用该方法返回所需的实例。 12345678910111213141516171819202122232425262728293031@Modulepublic class PersonServiceModule &#123; @Provides D provideD() &#123; return new D(); &#125; @Provides C provideC() &#123; return new C(); &#125; @Provides B provideB(C c, D d) &#123; return new B(c, d); &#125; @Provides A provideA(B b) &#123; return new A(b); &#125; /** * 提供PersonDao实例 */ @Provides PersonDao providePersonDao(A a) &#123; return new PersonDaoImpl(a); &#125;&#125; 就像providePersonDao返回了PersonDao接口实例，Dagger虽然不能直接实例化出PersonDao接口，但却可以调用Module的providePersonDao方法来获得一个实例。providePersonDao方法需要传入A的实例，那么这里也构成了一个依赖关系图。Dagger会先获取A的实例，然后把实例传递给providePersonDao方法。 Component的使用到目前为止，我们虽然知道了： Dagger怎么获取实例： 从Module的provide方法中获取 通过@Inject注解的构造方法new出新的实例 Dagger会推导provide方法和构造方法的参数，形成依赖图，并“满足”我们依赖图的需求，获取依赖的实例 看样子需要注入的依赖可以获取了，但是不是总觉得还有点“零碎”，整个流程还没连贯起来？比如，Module既然是一个类，生成依赖图的时候，怎么知道跟哪个Module挂钩？即使最后生成了需要的实例，注入的“目的地”是哪里？怎么才能把它注入到“目的地”？残缺的这部分功能，正是Component提供的，Component起到了一个桥梁的作用，贯通Module和注入目标。我们来看看最开始那个例子，我们是怎么进行依赖注入的： 1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @Inject PersonService mService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); PersonServiceComponent component = DaggerPersonServiceComponent.builder() .personServiceModule(new PersonServiceModule()) .build(); // 注入,所有@Inject注解的成员变量都会同时注入 component.inject(MainActivity.this); // 通过component获取实例，注意，这里只是演示用法，其实mService在component.inject的时候已经完成了注入 mService = component.getPersonService(); &#125;&#125; 这个DaggerPersonServiceComponent是什么鬼？DaggerPersonServiceComponent其实是Dagger为我们自动生成的类，它实现了一个Component接口（这个接口是需要我们自己写的），我们来看下它实现的接口长什么样子： 1234567891011121314151617181920/** * 指定PersonServiceModule，当需要获取某实例的时候，会查找PersonServiceModule中是否有返回相应类型的方法，有的话就通过该方法获得实例 * * @author HansChen */@Component(modules = PersonServiceModule.class)public interface PersonServiceComponent &#123; /** * 查找activity中被@Inject注解的成员变量，并尝试获取相应的实例，把实例赋给activity的成员变量 * 注意函数格式:返回值为空、带有一个参数 */ void inject(MainActivity activity); /** * Dagger会尝试从Module中获取PersonService实例，如果Module中不能获取对应实例，则通过PersonService的构造方法new出一个实例 * 注意函数格式：参数为空，返回值非空 */ PersonService getPersonService();&#125; 这个接口被Component注解修饰，它里面可以定义3种类型的方法： 返回值为空，有一个参数：查找参数中被@Inject注解的成员变量，并尝试获取相应的实例（通过Module的provide方法或@Inject注解的构造方法new出新的实例），把实例赋给参数的成员变量 返回值非空，参数为空：获取相应实例并返回 返回值是Component，参数是Moduld，通过该方法可以创建SubComponent实例 既然获取实例的时候，有可能用到Module，那么就必须为这个Component指定使用的Module是什么。具体做法就是在@Component注解中指定modules。定义好Component之后，Dagger会自动帮我们生成实现类，这就是Dagger强大的地方！生成的类名格式是：Dagger+Component名。Component提供了2种方法，一个是注入式方法，一个是获取实例方法。具体用什么方法，就看个人需求了。一个Component其实也对应了一个依赖图，因为Component使用哪个Module是确定不变的，依赖关系无非也就是跟Module和类的定义有关。一旦这些都确定下来了，在这个Component范围内，依赖关系也就被确定下来了。额外再说一点，在Dagger1中，Component的功能是由ObjectGraph实现的，Component是用来代替它的。 Component定义好之后，build一下工程，Dagger就会自动为我们生成实现类了，就可以使用自动生成的实现类来进行依赖注入了。到现在为止，我们已经通过Dagger完成了依赖注入。可能看起来比正常方法麻烦得多，但是Dagger框架可以让依赖的注入和配置独立于组件之外，它帮助你专注在那些重要的功能类上。通过声明依赖关系和指定规则构建整个应用程序。 熟悉完Dagger基本的使用之后，接下来我们来讲解一些稍微高级一点的用法： Dagger的进阶使用Components之间的关系在Dagger中，Component之间可以有两种关系:Subcomponents和Component dependencies。他们有什么作用呢？比如在我们应用中，经常会有一些依赖我们在各个界面都使用得到，比如操作数据库、比如网络请求。假设我们有个ServerApi的接口，在页面A、B、C都使用到了，那么我们要在页面A、B、C的Component里面都能获取到ServerApi的实例，但显然，获取ServerApi实例的方法都是一样的，我们不想写重复的代码。于是我们可定义一个ApplicationComponent，在里面返回ServerApi实例，通过Component之间的关系便可以共享ApplicationComponent提供的依赖图。 下面通过Android中的一个小栗子来说明Subcomponents和Component dependencies如何使用 dependencies先说明下各个模块之间的关系首先，我们定义一个ApplicationComponent，它定义了一个方法，通过它来获得ServerApi实例。ApplicationComponent还关联了ApplicationModule，这个Module是ServerApi实例的提供者，注意，这个Moduld还可以返回Context实例 12345@Component(modules = ApplicationModule.class)public interface ApplicationComponent &#123; ServerApi getServerApi();&#125; 12345678910111213141516171819@Modulepublic class ApplicationModule &#123; private final Context mAppContext; ApplicationModule(Context context) &#123; mAppContext = context.getApplicationContext(); &#125; @Provides Context provideAppContext() &#123; return mAppContext; &#125; @Provides ServerApi provideServerApi(Context context) &#123; return new ServerApiImpl(context); &#125;&#125; 1234567891011121314public class DemoApplication extends Application &#123; private ApplicationComponent mAppComponent; @Override public void onCreate() &#123; super.onCreate(); mAppComponent = DaggerApplicationComponent.builder().applicationModule(new ApplicationModule(this)).build(); &#125; public ApplicationComponent getAppComponent() &#123; return mAppComponent; &#125;&#125; MainActivity使用MVP模式，在MainPresenter里面需要传入一个ServerApi对象 123456// 注意，这里有个dependencies声明@Component(dependencies = ApplicationComponent.class, modules = MainPresenterModule.class)public interface MainPresenterComponent &#123; MainPresenter getMainPresenter();&#125; 1234567891011121314@Modulepublic class MainPresenterModule &#123; private MainView mMainView; public MainPresenterModule(MainView mainView) &#123; this.mMainView = mainView; &#125; @Provides MainView provideMainView() &#123; return mMainView; &#125;&#125; 1234567891011public class MainPresenter &#123; private MainView mMainView; private ServerApi mServerApi; @Inject public MainPresenter(MainView mainView, ServerApi serverApi) &#123; this.mMainView = mainView; this.mServerApi = serverApi; &#125;&#125; 先抛开dependencies，我们分析这个这个依赖树是怎么样的Component中getMainPresenter的目的很简单，就是返回MainPresenter，而MainPresenter又依赖MainView和ServerApi，MainView还好说，在MainPresenterModule中有provide方法，但是ServerApi呢？就像上面说的那样，如果我们在这个Moduld中也添加相应的provide方法，那真是太麻烦了（当然，这样做完全是可以实现的），所以我们依赖了ApplicationComponent，通过dependencies，在被依赖的Component暴露的对象，在子Component中是可见的。这个是什么意思呢？意思有两个： 被依赖Component接口暴露的对象，可以添加到依赖者的依赖图中 Component接口没有暴露的对象，依赖者是不可见的 对于第一点应该比较好理解，就像这个栗子，MainPresenterComponent生成MainPresenter需要ServerApi，而ApplicationComponent中有接口暴露了ServerApi，所以MainPresenterComponent可以获得ServerApi对于第二点，假设MainPresenter还需要传入一个Context对象，我们注意到，ApplicationModule是可以提供Context的，那MainPresenterComponent能不能通过ApplicationComponent获取Context实例？答案是不行的，因为ApplicationComponent没有暴露这个对象。想要获取Context，除非ApplicationComponent中再添加一个getContext的方法。 他们之间的关系可以用下图描述： SubcomponentsSubcomponents 实现方法一： 先定义子 Component，使 用@Subcomponent 标注（不可同时再使用 @Component） 父 Component 中定义获得子 Component 的方法 让我们对上面的栗子改造改造：去除MainPresenterComponent的Component注解，改为Subcomponent： 1234567@Subcomponent(modules = MainPresenterModule.class)public interface MainPresenterComponent &#123; void inject(MainActivity activity); MainPresenter getMainPresenter();&#125; 在ApplicationComponent中新增plus方法（名字可随意取），返回值为MainPresenterComponent，参数为MainPresenterModule： 12345@Component(modules = ApplicationModule.class)public interface ApplicationComponent &#123; MainPresenterComponent plus(MainPresenterModule module);&#125; 这样，就构建了一个ApplicationComponent的子图：MainPresenterComponent。子图和dependencies的区别就是，子图可以范围父图所有的依赖，也就是说，子图需要的依赖，不再需要在父Component中暴露任何对象，可以直接通过父图的Moduld提供！他们的关系变为了： 这里需要注意的是，以上代码直接在父 Component 返回子 Component 的形式，要求子 Component 依赖的 Module 必须包含一个无参构造函数，用以自动实例化。如果 Module 需要传递参数，则需要使用 @Subcomponent.builder 的方式，实现方法二实现步骤如下： 在子 Component，定义一个接口或抽象类（通常定义为 Builder），使用 @Subcomponent.Builder 标注 编写返回值为 Builder，方法的参数为需要传入参数的 Module 编写返回值为当前子 Component的 无参方法 父 Component 中定义获得子 Component.Builder 的方法 代码如下： 1234567891011121314151617181920212223242526272829303132333435@Modulepublic class TestModule &#123; public TestModule(String test) &#123; &#125; @Provides AuthManager provideAuthManager() &#123; return AuthManager.getInstance(); &#125;&#125;@Subcomponent(modules = &#123;TestModule.class&#125;)public interface TestComponent &#123; AuthManager getAuthManager(); @Subcomponent.Builder interface Builder &#123; Builder createBuilder(TestModule module); TestComponent build(); &#125;&#125;@Singleton@Component(modules = ApplicationModule.class)public interface ApplicationComponent &#123; ... TestComponent.Builder testComponentBuilder();&#125;// 使用TestComponent testComponent = mApplicationComponent.testComponentBuilder().createBuilder(new TestModule("test")).build(); Binds注解在Dagger2中，一般都是使用@provide方法注入接口。在Android 中，一般我们会这样做，创建一个接口 Presenter 命名 为 HomePresenter 123public interface HomePresenter &#123; Observable&lt;List&lt;User&gt;&gt; loadUsers()&#125; 然后创建一个这个接口的实例：HomePresenterImp 12345678public class HomePresenterImp implements HomePresenter &#123; public HomePresenterImp()&#123; &#125; @Override public Observable&lt;List&lt;User&gt;&gt; loadUsers()&#123; //Return user list observable &#125;&#125; 然后在 Module 中，提供实例化的 provide 方法： 1234567@Modulepublic class HomeModule &#123; @Provides public HomePresenter providesHomePresenter()&#123; return new HomePresenterImp(); &#125;&#125; 但是，如果我们需要添加一个依赖到 presenter 叫 UserService，那就意味着，我们也要在 module 中添加一个 provide 方法提供这个 UserService，然后在 HomePresenterImp 类中加入一个 UserService 参数的构造方法。有没有觉得这种方法很麻烦呢？我们还可以用 @Binds 注解，如： 1234567@Modulepublic abstract class HomeModule &#123; // 变为 abstract 方法， 同时 Module 也必须声明为 abstract， 传入的参数必须为返回参数的实现类 // 当需要 HomePresenter 时，dagger 会自动实例化 HomePresenterImp 并返回 @Binds public abstract HomePresenter bindHomePresenter(HomePresenterImp homePresenterImp);&#125; 除了方便，使用 @Binds 注解还可以让 dagger2 生成的代码效率更高。但是需要注意的是，由于 Module 变为抽象类，Module 不能再包含非 static 的带 @Provides 注解的方法。而且这时候，依赖此 Module 的 Component 也不需要传入此 Module 实例了（也实例化不了，因为它是抽象的）。相当于此 Module 仅仅作为描述依赖关系的一个类 ScopesScopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。@Singleton是被Dagger预先定义的作用域注解。 没有指定作用域的@Provides方法将会在每次注入的时候都创建新的对象 一个没有scope的component不可以依赖一个有scope的组件component 子组件和父组件的scope不能相同 Module中provide方法的scope需要与Component的scope一致 我们通常的ApplicationComponent都会使用Singleton注解，也就会是说我们如果自定义component必须有自己的scope。读者到这里，可能还不能理解Scopes的作用，我们先来看下默认提供的Singlton到底有什么作用，然后再讨论Scopes的意义： SingltonSingletons是java提供的一个scope，我们来看看Singletons能做什么事情。为@Provides注释的方法或可注入的类添加添加注解@Singlton，构建的这个对象图表将使用唯一的对象实例，比如我们有个ServerApi方法一：用@Singleton注解类： 1234567891011@Singletonpublic class ServerApi &#123; @Inject public ServerApi() &#123; &#125; public boolean login(String username, String password) &#123; return "HansChen".equals(username) &amp;&amp; "123456".equals(password); &#125;&#125; 方法二：用@Singleton注解Module的provide方法： 123456789@Modulepublic class ApplicationModule &#123; @Singleton @Provides ServerApi provideServerApi() &#123; return new ServerApi(); &#125;&#125; 然后我们有个Component： 123456@Singleton@Component(modules = ApplicationModule.class)public interface ApplicationComponent &#123; ServerApi getServerApi();&#125; 然后执行依赖注入： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Inject ServerApi mService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ApplicationComponent component = DaggerApplicationComponent.create(); Log.d("Hans", component.getServerApi().toString()); Log.d("Hans", component.getServerApi().toString()); Log.d("Hans", component.getServerApi().toString()); &#125;&#125; 使用了以上两种方法的任意一种，我们都会发现，通过component.getServerApi()获得的实例都是同一个实例。不过要注意一点的是，如果类用@Singleton注解了，但Module中又存在一个provide方法是提供该类实例的，但provide方法没有用@Singleton注解，那么Component中获取该实例就不是单例的，因为会优先查找Module的方法。这个单例是相对于同一个Component而言的，不同的Component获取到的实例将会是不一样的。 自定义Scope既然一个没有scope的component不可以依赖一个有scope的组件component，那么我们必然需要自定义scope来去注解自己的Component了，定义方法如下： 12345@Documented@Scope@Retention(RetentionPolicy.RUNTIME)public @interface FragmentScoped &#123;&#125; 定义出来的FragmentScoped在使用上和Singleton是一样的，那它和Singleton除了是不一样的注解之外，还有什么不一样呢？答案是没有！我们自定义的scope和Singleton并没有任何不一样，不会因为Singleton是java自带的注解就会有什么区别。 那么，这个scope的设定是为了什么呢？ scope的作用scope除了修饰provide方法可以让我们获得在同一个Component实例范围内的单例之外，主要的作用就是对Component和Moduld的分层管理以及依赖逻辑的可读性。这里借用一个网络上的图片说明： ApplicationComponent一般会用singleton注解，相对的，它的Module中provide方法也只能用singleton注解。UserComponent是用UserSCope能直接使用ApplicationModule吗？不能！因为他俩的scope不一致，这就是这个设定带来的好处，防止不同层级的组件混乱。另外，因为有了scope的存在，各种组件的作用和生命周期也变得可读起来了 Lazy注入有时可能会需要延迟获取一个实例。对任何绑定的 T，可以构建一个 Lazy 来延迟实例化直至第一次调用 Lazy 的 get() 方法。注入之后，第一次get的时会实例化出 T，之后的调用都会获取相同的实例。 1234567891011121314151617181920public class MainActivity extends AppCompatActivity implements MainView &#123; // 懒加载 @Inject Lazy&lt;MainPresenter&gt; mPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MainPresenterComponent component = DaggerMainPresenterComponent.builder() .mainPresenterModule(new MainPresenterModule(this)) .applicationComponent(((DemoApplication) getApplication()).getAppComponent()) .build(); component.inject(this); Log.d("Hans", mPresenter.get().toString()); // 实例化MainPresenter Log.d("Hans", mPresenter.get().toString()); // 跟上次获取的实例是同一个实例 &#125;&#125; Provider注入跟Lazy注入不一样的是，有时候我们希望每次调用get的时候，获取到的实例都是不一样的，这时候可以用Provider注入 1234567891011121314151617181920public class MainActivity extends AppCompatActivity implements MainView &#123; // Provider @Inject Provider&lt;MainPresenter&gt; mPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MainPresenterComponent component = DaggerMainPresenterComponent.builder() .mainPresenterModule(new MainPresenterModule(this)) .applicationComponent(((DemoApplication) getApplication()).getAppComponent()) .build(); component.inject(this); Log.d("Hans", mPresenter.get().toString()); // 实例化MainPresenter Log.d("Hans", mPresenter.get().toString()); // 获取新的MainPresenter实例 &#125;&#125; Qualifiers注入到目前为止，我们的demo里，Moduld的provide返回的对象都是不一样的,但是下面这种情况就不好处理了： 1234567891011121314151617@Modulepublic class ApplicationModule &#123; ...... // 返回ServerApi实例 @Provides ServerApi provideServerApiA(Context context) &#123; return new ServerApiImplA(context); &#125; // 返回ServerApi实例 @Provides ServerApi provideServerApiB(Context context) &#123; return new ServerApiImplB(context); &#125;&#125; provideServerApiA和provideServerApiB返回的都是ServerApi，Dagger是无法判断用哪个provide方法的。这时候就需要添加Qualifiers了： 1234567891011121314151617@Modulepublic class ApplicationModule &#123; ...... @Provides @Named("ServerApiImplA") ServerApi provideServerApiA(Context context) &#123; return new ServerApiImplA(context); &#125; @Provides @Named("ServerApiImplB") ServerApi provideServerApiB(Context context) &#123; return new ServerApiImplB(context); &#125;&#125; 通过这样一个限定，就能区分出2个方法的区别了，当然，在使用过程中，也同样要指明你用哪个name的实例,Dagger会根据你的name来选取对应的provide方法： 1234567891011public class MainPresenter &#123; private MainView mMainView; private ServerApi mServerApi; @Inject public MainPresenter(MainView mainView, @Named("ServerApiImplA") ServerApi serverApi) &#123; this.mMainView = mainView; this.mServerApi = serverApi; &#125;&#125; 除了用Named注解，你也可以创建你自己的限定注解： 123456@Qualifier@Documented@Retention(RUNTIME)public @interface YourQualifier &#123; String value() default "";&#125; 编译时验证Dagger 包含了一个注解处理器（annotation processor）来验证模块和注入。这个过程很严格而且会抛出错误，当有非法绑定或绑定不成功时。下面这个例子缺少了 Executor： 123456@Moduleclass DripCoffeeModule &#123; @Provides Heater provideHeater(Executor executor) &#123; return new CpuHeater(executor); &#125;&#125; 当编译时，javac 会拒绝绑定缺少的部分: 12[ERROR] COMPILATION ERROR :[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method. 可以通过给方法 Executor 添加@Provides注解来解决这个问题，或者标记这个模块是不完整的。不完整的模块允许缺少依赖关系 123456@Module(complete = false)class DripCoffeeModule &#123; @Provides Heater provideHeater(Executor executor) &#123; return new CpuHeater(executor); &#125;&#125; 小结第一次接触用Dagger框架写的代码时候，如果不了解各种注解作用的时候，那真会有一脸懵逼的感觉，而且单看文章，其实还是很抽象，建议大家用Dagger写个小demo玩玩，很快就上手了，这里提供几个使用Dagger的栗子，希望可以帮助大家上手Dagger Dagger demo 谷歌官方 MVP+Dagger2 Demo]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>依赖注入</tag>
        <tag>Dagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robolectric使用教程]]></title>
    <url>%2F2016%2F12%2F10%2Frobolectric%2F</url>
    <content type="text"><![CDATA[概述Android的单元测试可以分为两部分： Local unit tests：运行于本地JVM Instrumented test：运行于真机或者模拟器 如果使用Local测试，需要保证测试过程中不会调用Android系统API，否则会抛出RuntimeException异常，因为Local测试是直接跑在本机JVM的，而之所以我们能使用Android系统API，是因为编译的时候，我们依赖了一个名为“android.jar”的jar包，但是jar包里所有方法都是直接抛出了一个RuntimeException，是没有任何任何实现的，这只是Android为了我们能通过编译提供的一个Stub！当APP运行在真实的Android系统的时候，由于类加载机制，会加载位于framework的具有真正实现的类。由于我们的Local是直接在PC上运行的，所以调用这些系统API便会出错。那么问题来了，我们既要使用Local测试，但测试过程又难免遇到调用系统API那怎么办？其中一个方法就是mock objects，比如借助Mockito，另外一种方式就是使用Robolectric， Robolectric就是为解决这个问题而生的。它实现一套JVM能运行的Android代码，然后在unit test运行的时候去截取android相关的代码调用，然后转到他们的他们实现的Shadow代码去执行这个调用的过程 如何使用？为项目添加依赖1testCompile "org.robolectric:robolectric:3.1.4" Robolectric在第一次运行时，会下载一些sdk依赖包，每个sdk依赖包大概50M，下载速度比较慢，用户可以直接在网上下载相应依赖包，放置在本地maven仓库地址中，默认路径为：C:\Users\username\.m2\repository\org\robolectric 指定RobolectricTestRunner为运行器为测试用例添加注解,指定测试运行器为RobolectricTestRunner。注意，这里要通过Config指定constants = BuildConfig.class，Robolectric 会通过constants推导出输出路径，如果不进行配置，Robolectric可能不能找到你的manifest、resources和assets资源 12345@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class)public class MainActivityTest &#123;&#125; 什么是Shadow类Shadow是Robolectric的立足之本，如其名，作为影子，一定是变幻莫测，时有时无，且依存于本尊。Robolectric定义了大量模拟Android系统类行为的Shadow类，当这些系统类被创建的时候，Robolectric会查找对应的Shadow类并创建一个Shadow类与原始类关联。每当系统类的方法被调用的时候，Robolectric会保证Shadow对应的方法会调用。这些Shadow对象，丰富了本尊的行为，能更方便的对Android相关的对象进行测试。比如，我们可以借助ShadowActivity验证页面是否正确跳转了 12345678910111213141516171819/** * 验证点击事件是否触发了页面跳转，验证目标页面是否预期页面 * * @throws Exception */@Testpublic void testJump() throws Exception &#123; // 默认会调用Activity的生命周期: onCreate-&gt;onStart-&gt;onResume MainActivity activity = Robolectric.setupActivity(MainActivity.class); // 触发按钮点击 activity.findViewById(R.id.activity_main_jump).performClick(); // 获取对应的Shadow类 ShadowActivity shadowActivity = Shadows.shadowOf(activity); // 借助Shadow类获取启动下一Activity的Intent Intent nextIntent = shadowActivity.getNextStartedActivity(); // 校验Intent的正确性 assertEquals(nextIntent.getComponent().getClassName(), SecondActivity.class.getName());&#125; @Config配置可以通过@Config定制Robolectric的运行时的行为。这个注解可以用来注释类和方法，如果类和方法同时使用了@Config，那么方法的设置会覆盖类的设置。你可以创建一个基类，用@Config配置测试参数，这样，其他测试用例就可以共享这个配置了 配置SDK版本Robolectric会根据manifest文件配置的targetSdkVersion选择运行测试代码的SDK版本，如果你想指定sdk来运行测试用例，可以通过下面的方式配置 1234567@Config(sdk = Build.VERSION_CODES.JELLY_BEAN)public class SandwichTest &#123; @Config(sdk = Build.VERSION_CODES.KITKAT) public void getSandwich_shouldReturnHamSandwich() &#123; &#125;&#125; 配置Application类Robolectric会根据manifest文件配置的Application配置去实例化一个Application类，如果你想在测试用例中重新指定，可以通过下面的方式配置 1234567@Config(application = CustomApplication.class)public class SandwichTest &#123; @Config(application = CustomApplicationOverride.class) public void getSandwich_shouldReturnHamSandwich() &#123; &#125;&#125; 指定Resource路径Robolectric可以让你配置manifest、resource和assets路径，可以通过下面的方式配置 123456789@Config(manifest = "some/build/path/AndroidManifest.xml", assetDir = "some/build/path/assetDir", resourceDir = "some/build/path/resourceDir")public class SandwichTest &#123; @Config(manifest = "other/build/path/AndroidManifest.xml") public void getSandwich_shouldReturnHamSandwich() &#123; &#125;&#125; 使用第三方Library Resources当Robolectric测试的时候，会尝试加载所有应用提供的资源，但如果你需要使用第三方库中提供的资源文件，你可能需要做一些特别的配置。不过如果你使用gradle来构建Android应用，这些配置就不需要做了，因为Gradle Plugin会在build的时候自动合并第三方库的资源，但如果你使用的是Maven，那么你需要配置libraries变量： 1234567@RunWith(RobolectricTestRunner.class)@Config(libraries = &#123; "build/unpacked-libraries/library1", "build/unpacked-libraries/library2"&#125;)public class SandwichTest &#123;&#125; 使用限定的资源文件Android会在运行时加载特定的资源文件，如根据设备屏幕加载不同分辨率的图片资源、根据系统语言加载不同的string.xml，在Robolectric测试当中，你也可以进行一个限定，让测试程序加载特定资源.多个限定条件可以用破折号拼接在在一起。 1234567891011/** * 使用qualifiers加载对应的资源文件 * * @throws Exception */@Config(qualifiers = "zh-rCN")@Testpublic void testString() throws Exception &#123; final Context context = RuntimeEnvironment.application; assertThat(context.getString(R.string.app_name), is("单元测试Demo"));&#125; Properties文件如果你嫌通过注解配置上面的东西麻烦，你也可以把以上配置放在一个Properties文件之中，然后通过@Config指定配置文件，比如，首先创建一个配置文件robolectric.properties: 12345# 放置Robolectric的配置选项:sdk=21manifest=some/build/path/AndroidManifest.xmlassetDir=some/build/path/assetDirresourceDir=some/build/path/resourceDir 然后把robolectric.properties文件放到src/test/resources目录下，运行的时候，会自动加载里面的配置 系统属性配置 robolectric.offline：true代表关闭运行时获取jar包 robolectric.dependency.dir：当处于offline模式的时候，指定运行时的依赖目录 robolectric.dependency.repo.id：设置运行时获取依赖的Maven仓库ID，默认是sonatype robolectric.dependency.repo.url：设置运行时依赖的Maven仓库地址，默认是https://oss.sonatype.org/content/groups/public/ robolectric.logging.enabled：设置是否打开调试开关 以上设置可以通过Gradle进行配置，如： 123456789android &#123; testOptions &#123; unitTests.all &#123; systemProperty 'robolectric.dependency.repo.url', 'https://local-mirror/repo' systemProperty 'robolectric.dependency.repo.id', 'local' &#125; &#125;&#125; 驱动Activity生命周期利用ActivityController我们可以让Activity执行相应的生命周期方法，如： 123456789101112131415161718192021222324252627282930313233343536@Testpublic void testLifecycle() throws Exception &#123; // 创建Activity控制器 ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class); MainActivity activity = controller.get(); assertNull(activity.getLifecycleState()); // 调用Activity的performCreate方法 controller.create(); assertEquals("onCreate", activity.getLifecycleState()); // 调用Activity的performStart方法 controller.start(); assertEquals("onStart", activity.getLifecycleState()); // 调用Activity的performResume方法 controller.resume(); assertEquals("onResume", activity.getLifecycleState()); // 调用Activity的performPause方法 controller.pause(); assertEquals("onPause", activity.getLifecycleState()); // 调用Activity的performStop方法 controller.stop(); assertEquals("onStop", activity.getLifecycleState()); // 调用Activity的performRestart方法 controller.restart(); // 注意此处应该是onStart，因为performRestart不仅会调用restart，还会调用onStart assertEquals("onStart", activity.getLifecycleState()); // 调用Activity的performDestroy方法 controller.destroy(); assertEquals("onDestroy", activity.getLifecycleState());&#125; 通过ActivityController，我们可以模拟各种生命周期的变化。但是要注意，我们虽然可以随意调用Activity的生命周期，但是Activity生命周期切换有自己的检测机制，我们要遵循Activity的生命周期规律。比如，如果当前Activity并非处于stop状态，测试代码去调用了controller.restart方法，此时Activity是不会回调onRestart和onStart的。 除了控制生命周期，还可以在启动Activity的时候传递Intent： 123456789101112/** * 启动Activity的时候传递Intent * * @throws Exception */@Testpublic void testStartActivityWithIntent() throws Exception &#123; Intent intent = new Intent(); intent.putExtra("test", "HelloWorld"); Activity activity = Robolectric.buildActivity(MainActivity.class).withIntent(intent).create().get(); assertEquals("HelloWorld", activity.getIntent().getExtras().getString("test"));&#125; onRestoreInstanceState回调中传递Bundle： 1234567891011/** * savedInstanceState会在onRestoreInstanceState回调中传递给Activity * * @throws Exception */@Testpublic void testSavedInstanceState() throws Exception &#123; Bundle savedInstanceState = new Bundle(); Robolectric.buildActivity(MainActivity.class).create().restoreInstanceState(savedInstanceState).get(); // verify something&#125; 在真实环境下，视图是在onCreate之后的某一时刻在attach到Window上的，在此之前，View是处于不可操作状态的，你不能点击它。在Activity的onPostResume方法调用之后，View才会attach到Window之中。但是，在Robolectric之中，我们可以用控制器的visible方法使得View变为可见，变为可见之后，就可以模拟点击事件了 12345678910111213@Testpublic void testVisible() throws Exception &#123; ActivityController&lt;MainActivity&gt; controller = Robolectric.buildActivity(MainActivity.class); MainActivity activity = controller.get(); // 调用Activity的performCreate并且设置视图visible controller.create().visible(); // 触发点击 activity.findViewById(R.id.activity_main_button1).performClick(); // 验证 assertEquals(shadowOf(activity).getNextStartedActivity().getComponent().getClassName(), SecondActivity.class.getName());&#125; 追加模块为了减少依赖包的大小，Robolectric的shadows类成了好几部分： SDK Package Robolectric Add-On Package com.android.support.support-v4 org.robolectric:shadows-support-v4 com.android.support.multidex org.robolectric:shadows-multidex com.google.android.gms:play-services org.robolectric:shadows-play-services com.google.android.maps:maps org.robolectric:shadows-maps org.apache.httpcomponents:httpclient org.robolectric:shadows-httpclient 用户可以根据自身需求添加以下依赖包，如 123456789dependencies &#123; ... ... testCompile 'org.robolectric:robolectric:3.1.4' testCompile 'org.robolectric:shadows-support-v4:3.1.4' testCompile 'org.robolectric:shadows-multidex:3.1.4' testCompile 'org.robolectric:shadows-play-services:3.1.4' testCompile 'org.robolectric:shadows-maps:3.1.4' testCompile 'org.robolectric:shadows-httpclient:3.1.4'&#125; 自定义Shadow类 Shadow类需要一个public的无参构造方法以方便Robolectric框架可以实例化它，通过@Implements注解与原始类关联在一起 若原始类有有参构造方法，在Shadow类中定义public void类型的名为__constructor__的方法，且方法参数与原始类的构造方法参数一直 定义与原始类方法签名一致的方法，在里面重写实现，Shadow方法需用@Implementation进行注解 下面我们来创建RobolectricBean的Shadow类原始类： 123456789101112131415161718192021public class RobolectricBean &#123; String name; int color; public RobolectricBean(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public int getColor() &#123; return color; &#125; public void setColor(int color) &#123; this.color = color; &#125;&#125; Shadow类: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 创建&#123;@link RobolectricBean&#125;的影子类 * * @author HansChen */@Implements(RobolectricBean.class)public class ShadowRobolectricBean &#123; /** * 通过@RealObject注解可以访问原始对象，但注意，通过@RealObject注解的变量调用方法，依然会调用Shadow类的方法，而不是原始类的方法 * 只能用来访问原始类的field */ @RealObject RobolectricBean realBean; /** * 需要一个无参构造方法 */ public ShadowRobolectricBean() &#123; &#125; /** * 对应原始类的构造方法 * * @param name 对应原始类构造方法的传入参数 */ public void __constructor__(String name) &#123; realBean.name = name; &#125; /** * 原始对象的方法被调用的时候，Robolectric会根据方法签名查找对应的Shadow方法并调用 */ @Implementation public String getName() &#123; return "Hello, I ma shadow of RobolectricBean: " + realBean.name; &#125; @Implementation public int getColor() &#123; return realBean.color; &#125; @Implementation public void setColor(int color) &#123; realBean.color = color; &#125;&#125; Shadow类中访问原始类的fieldShadow类中可以定义一个原始类的成员变量，并用@RealObject注解，这样，Shadow类就能访问原始类的field了，但是注意，通过@RealObject注解的变量调用方法，依然会调用Shadow类的方法，而不是原始类的方法，只能用它来访问原始类的field。 123456789@Implements(Point.class)public class ShadowPoint &#123; @RealObject private Point realPoint; ... public void __constructor__(int x, int y) &#123; realPoint.x = x; realPoint.y = y; &#125;&#125; 如何在测试用例中让Shadow生效在Config注解中添加shadows参数，指定对应的Shadow生效 123456@RunWith(RobolectricTestRunner.class)@Config(shadows = ShadowRobolectricBean.class)public class RobolectricBeanTest &#123; ... ...&#125; 注意，自定义的Shadow类不能通过Shadows.shadowOf()获取，需要用ShadowExtractor.extract()来获取，获取之后进行类型转换: 1ShadowRobolectricBean shadowBean = (ShadowRobolectricBean) ShadowExtractor.extract(bean); 常用测试场景页面跳转验证12345678910111213141516171819/** * 验证点击事件是否触发了页面跳转，验证目标页面是否预期页面 * * @throws Exception */@Testpublic void testJump() throws Exception &#123; // 默认会调用Activity的生命周期: onCreate-&gt;onStart-&gt;onResume MainActivity activity = Robolectric.setupActivity(MainActivity.class); // 触发按钮点击 activity.findViewById(R.id.activity_main_jump).performClick(); // 获取对应的Shadow类 ShadowActivity shadowActivity = Shadows.shadowOf(activity); // 借助Shadow类获取启动下一Activity的Intent Intent nextIntent = shadowActivity.getNextStartedActivity(); // 校验Intent的正确性 assertEquals(nextIntent.getComponent().getClassName(), SecondActivity.class.getName());&#125; UI组件状态验证12345678910111213141516171819202122/** * 验证UI组件状态 * * @throws Exception */@Testpublic void testCheckBoxState() throws Exception &#123; MainActivity activity = Robolectric.setupActivity(MainActivity.class); CheckBox checkBox = (CheckBox) activity.findViewById(R.id.activity_main_check_box); // 验证CheckBox初始状态 assertFalse(checkBox.isChecked()); // 点击按钮反转CheckBox状态 activity.findViewById(R.id.activity_main_switch_check_box).performClick(); // 验证状态是否正确 assertTrue(checkBox.isChecked()); // 点击按钮反转CheckBox状态 activity.findViewById(R.id.activity_main_switch_check_box).performClick(); // 验证状态是否正确 assertFalse(checkBox.isChecked());&#125; 验证Dialog123456789101112131415161718192021/** * 验证Dialog是否正确弹出 * * @throws Exception */@Testpublic void testDialog() throws Exception &#123; MainActivity activity = Robolectric.setupActivity(MainActivity.class); AlertDialog dialog = ShadowAlertDialog.getLatestAlertDialog(); // 判断Dialog尚未弹出 assertNull(dialog); activity.findViewById(R.id.activity_main_show_dialog).performClick(); dialog = ShadowAlertDialog.getLatestAlertDialog(); // 判断Dialog已经弹出 assertNotNull(dialog); // 获取Shadow类进行验证 ShadowAlertDialog shadowDialog = shadowOf(dialog); assertEquals("AlertDialog", shadowDialog.getTitle()); assertEquals("Oops, now you see me ~", shadowDialog.getMessage());&#125; 验证Toast123456789101112131415161718192021/** * 验证Toast是否正确弹出 * * @throws Exception */@Testpublic void testToast() throws Exception &#123; MainActivity activity = Robolectric.setupActivity(MainActivity.class); Toast toast = ShadowToast.getLatestToast(); // 判断Toast尚未弹出 assertNull(toast); activity.findViewById(R.id.activity_main_show_toast).performClick(); toast = ShadowToast.getLatestToast(); // 判断Toast已经弹出 assertNotNull(toast); // 获取Shadow类进行验证 ShadowToast shadowToast = shadowOf(toast); assertEquals(Toast.LENGTH_SHORT, shadowToast.getDuration()); assertEquals("oops", ShadowToast.getTextOfLatestToast());&#125; 验证Fragment123456789101112131415161718@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class, application = CustomApplication.class)public class MyFragmentTest &#123; private MyFragment myFragment; @Before public void setUp() throws Exception &#123; myFragment = new MyFragment(); // 把Fragment添加到Activity中 FragmentTestUtil.startFragment(myFragment); &#125; @Test public void testFragment() throws Exception &#123; assertNotNull(myFragment.getView()); &#125;&#125; 验证BroadcastReceiver首先看下广播接收器： 123456public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // do something &#125;&#125; 广播的测试点可以包含两个方面 验证应用程序是否注册了该广播 验证广播接收器的处理逻辑是否正确，关于逻辑是否正确，可以直接人为的触发onReceive()方法，让然后进行验证 12345678910111213141516171819202122232425262728@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class, application = CustomApplication.class)public class MyReceiverTest &#123; @Test public void restRegister() throws Exception &#123; ShadowApplication shadowApplication = ShadowApplication.getInstance(); String action = "ut.cn.unittestdemo.receiver"; Intent intent = new Intent(action); // 验证是否注册了相应的Receiver assertTrue(shadowApplication.hasReceiverForIntent(intent)); &#125; @Test public void restReceive() throws Exception &#123; String action = "ut.cn.unittestdemo.receiver"; Intent intent = new Intent(action); intent.putExtra("EXTRA_USERNAME", "HansChen"); MyReceiver myReceiver = new MyReceiver(); myReceiver.onReceive(RuntimeEnvironment.application, intent); // verify something &#125;&#125; 验证ServiceService和Activity一样，都有生命周期，Robolectric也提供了Service的生命周期控制器，使用方式和Activity类似，这里就不做详细解释了 12345678910111213141516171819202122232425262728293031323334353637@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class, application = CustomApplication.class)public class TestServiceTest &#123; private ServiceController&lt;TestService&gt; controller; private TestService testService; @Before public void setUp() throws Exception &#123; controller = Robolectric.buildService(TestService.class); testService = controller.get(); &#125; /** * 控制Service生命周期进行验证 * * @throws Exception */ @Test public void testLifecycle() throws Exception &#123; controller.create(); // verify something controller.startCommand(0, 0); // verify something controller.bind(); // verify something controller.unbind(); // verify something controller.destroy(); // verify something &#125;&#125;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>Robolectric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板方法模式和策略模式]]></title>
    <url>%2F2016%2F12%2F01%2Fdesign-patterns-template-and-strategy%2F</url>
    <content type="text"><![CDATA[概述我们知道，OOP三个基本特征是:封装、继承、多态。通过继承，我们可以基于差异编程，也就是说，对于一个满足我们大部分需求的类，可以创建它的一个子类并只改变我们不期望的那部分。但是在实际使用中，继承很容易被过度使用，并且过度使用的代价是比较高的，所以我们减少了继承的使用，使用组合或委托代替 优先使用对象组合而不是类继承 在本文中，我们会分别介绍模板方法模式和策略模式，这两个模式分别使用了继承和委托两种方式。这两种模式解决的问题是类似的，经常可以互换使用，它们都可以分离通用的算法和具体的上下文。比如我们有一个通用的算法，算法有不同的实现方式，为了遵循依赖倒置原则，我们希望算法不依赖于具体实现。 本文冒泡排序法来进行举例说明： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author HansChen */public class Sorter &#123; /** * 冒泡排序 */ public int sort(int[] array) &#123; int operations = 0; if (array.length &lt;= 1) &#123; return operations; &#125; for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; operations++; if (needSwap(array, j)) &#123; swap(array, j); &#125; &#125; &#125; return operations; &#125; /** * @return 是否需要交换数组中 index 和 index+1 元素 */ private boolean needSwap(int[] array, int index) &#123; return array[index] &gt; array[index + 1]; &#125; /** * 交换array数组中的 index 和 index+1 元素 */ private void swap(int[] array, int index) &#123; int temp = array[index]; array[index] = array[index + 1]; array[index + 1] = temp; &#125;&#125; 这是我们实现的冒泡排序算法，这个sort方法可以对int数组进行排序。但我们发现，这种写法的扩展性是不强的，如果我们要实现double数组排序呢？如果我们需要排序的是一个对象数组？难道需要各自定义一个方法吗？如果它们都使用冒泡排序算法，那么sort的算法逻辑肯定是相似的，有没有一种方法能让这个算法逻辑复用呢？下面用模板方法模式和策略模式对它进行改造 模板方法模式 模板方法模式:定义一个算法的骨架，将骨架中的特定步骤延迟到子类中。模板方法模式使得子类可以不改变算法的结构即可重新定义该算法的某些特定步骤 下图是用模板方法模式对冒泡排序重构后的结构图： 首先，我们在BubbleSorter的sort方法中定义算法骨架，再定义一些延迟到子类中的抽象方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author HansChen */public abstract class BubbleSorter&lt;T&gt; &#123; /** * 冒泡排序 */ public int sort(T array) &#123; setArray(array); int length = getLength(); int operations = 0; if (length &lt;= 1) &#123; return operations; &#125; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; operations++; if (needSwap(j)) &#123; swap(j); &#125; &#125; &#125; return operations; &#125; /** * 初始化排序数组 */ protected abstract void setArray(T array); /** * @return 返回数组长度 */ protected abstract int getLength(); /** * @return 是否需要交换数组中 index 和 index+1 元素 */ protected abstract boolean needSwap(int index); /** * 交换array数组中的 index 和 index+1 元素 */ protected abstract void swap(int index);&#125; 有了BubbleSorter类，我们就可以创建任意不同类型的对象排序的简单派生类，比如创建IntBubbleSorter去排序整型数组： 1234567891011121314151617181920212223242526public class IntBubbleSorter extends BubbleSorter&lt;int[]&gt; &#123; private int[] array; @Override protected void setArray(int[] array) &#123; this.array = array; &#125; @Override protected int getLength() &#123; return array == null ? 0 : array.length; &#125; @Override protected boolean needSwap(int index) &#123; return array != null &amp;&amp; (array[index] &gt; array[index + 1]); &#125; @Override protected void swap(int index) &#123; int temp = array[index]; array[index] = array[index + 1]; array[index + 1] = temp; &#125;&#125; 再比如创建DoubleBubbleSorter去排序双精度型数组： 1234567891011121314151617181920212223242526public class DoubleBubbleSorter extends BubbleSorter&lt;double[]&gt; &#123; private double[] array; @Override protected void setArray(double[] array) &#123; this.array = array; &#125; @Override protected int getLength() &#123; return array == null ? 0 : array.length; &#125; @Override protected boolean needSwap(int index) &#123; return array != null &amp;&amp; (array[index] &gt; array[index + 1]); &#125; @Override protected void swap(int index) &#123; double temp = array[index]; array[index] = array[index + 1]; array[index + 1] = temp; &#125;&#125; 甚至我们不仅限于对数组排序，还可以对List集合排序，比如创建IntegerListBubbleSorter对List集合进行冒泡排序： 1234567891011121314151617181920212223242526public class IntegerListBubbleSorter extends BubbleSorter&lt;List&lt;Integer&gt;&gt; &#123; private List&lt;Integer&gt; list; @Override protected void setArray(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override protected int getLength() &#123; return list == null ? 0 : list.size(); &#125; @Override protected boolean needSwap(int index) &#123; return list != null &amp;&amp; (list.get(index) &gt; list.get(index + 1)); &#125; @Override protected void swap(int index) &#123; int temp = list.get(index); list.set(index, list.get(index + 1)); list.set(index + 1, temp); &#125;&#125; 定义上述类之后，我们看下怎么使用上面的类： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; //对整型数组排序 int[] intArray = &#123;9, 8, 7, 6, 5, 4, 3, 2, 1, 0&#125;; int operations = new IntBubbleSorter().sort(intArray); System.out.println("[Template Method] operations:" + operations + ", array:" + Arrays.toString(intArray)); //对double数组排序 double[] doubleArray = &#123;9.9, 8.8, 7.7, 6.6, 5.5, 4.4, 3.3, 2.2, 1.1, 0.0&#125;; operations = new DoubleBubbleSorter().sort(doubleArray); System.out.println("[Template Method] operations:" + operations + ", array:" + Arrays.toString(doubleArray)); //对List集合排序 List&lt;Integer&gt; list = Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1, 0); operations = new IntegerListBubbleSorter().sort(list); System.out.println("[Template Method] operations:" + operations + ", list:" + list.toString()); &#125;&#125; 模板方法模式展示了经典重用的一种形式，通用算法被放在基类中，通过继承在不同的子类中实现该通用算法。我们通过定义通用类BubbleSorter，把冒泡排序的算法骨架放在基类，然后实现不同的子类分别对int数组、double数组、List集合进行排序。但这样是有代价的，因为继承是非常强的关系，派生类不可避免地与基类绑定在一起了。但如果我现在需要用快速排序而不是冒泡排序来进行排序，但快速排序却没有办法重用setArray、getLength、needSwap和swap方法了。不过，策略模式提供了另一种可选的方案 策略模式策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换，下面用策略模式对冒泡排序进行重构 下图是用策略模式对冒泡排序重构后的结构图： 首先定义一个BubbleSorter类，它持有一个抽象策略接口： 123456789101112131415161718192021222324252627282930313233343536public class BubbleSorter&lt;T&gt; &#123; /** * 抽象策略接口，可以有不同的实现 */ private SortHandler&lt;T&gt; sortHandler; public BubbleSorter(SortHandler&lt;T&gt; sortHandler) &#123; this.sortHandler = sortHandler; &#125; /** * 冒泡排序 */ public int sort(T array) &#123; sortHandler.setArray(array); int length = sortHandler.getLength(); int operations = 0; if (length &lt;= 1) &#123; return operations; &#125; for (int i = 0; i &lt; length - 1; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; operations++; if (sortHandler.needSwap(j)) &#123; sortHandler.swap(j); &#125; &#125; &#125; return operations; &#125;&#125; 定义抽象策略接口： 12345678910111213141516171819202122public interface SortHandler&lt;T&gt; &#123; /** * 初始化排序数组 */ void setArray(T array); /** * @return 返回数组长度 */ int getLength(); /** * @return 是否需要交换数组中 index 和 index+1 元素 */ boolean needSwap(int index); /** * 交换array数组中的 index 和 index+1 元素 */ void swap(int index);&#125; 创建具体的策略类IntSortHandler对整型数组进行操作： 1234567891011121314151617181920212223242526public class IntSortHandler implements SortHandler&lt;int[]&gt; &#123; private int[] array; @Override public void setArray(int[] array) &#123; this.array = array; &#125; @Override public int getLength() &#123; return array == null ? 0 : array.length; &#125; @Override public boolean needSwap(int index) &#123; return array != null &amp;&amp; (array[index] &gt; array[index + 1]); &#125; @Override public void swap(int index) &#123; int temp = array[index]; array[index] = array[index + 1]; array[index + 1] = temp; &#125;&#125; 创建具体的策略类DoubleSortHandler对双精度型数组进行操作： 1234567891011121314151617181920212223242526public class DoubleSortHandler implements SortHandler&lt;double[]&gt; &#123; private double[] array; @Override public void setArray(double[] array) &#123; this.array = array; &#125; @Override public int getLength() &#123; return array == null ? 0 : array.length; &#125; @Override public boolean needSwap(int index) &#123; return array != null &amp;&amp; (array[index] &gt; array[index + 1]); &#125; @Override public void swap(int index) &#123; double temp = array[index]; array[index] = array[index + 1]; array[index + 1] = temp; &#125;&#125; 创建具体的策略类IntegerListSortHandler对List集合进行操作： 1234567891011121314151617181920212223242526public class IntegerListSortHandler implements SortHandler&lt;List&lt;Integer&gt;&gt; &#123; private List&lt;Integer&gt; list; @Override public void setArray(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public int getLength() &#123; return list == null ? 0 : list.size(); &#125; @Override public boolean needSwap(int index) &#123; return list != null &amp;&amp; (list.get(index) &gt; list.get(index + 1)); &#125; @Override public void swap(int index) &#123; int temp = list.get(index); list.set(index, list.get(index + 1)); list.set(index + 1, temp); &#125;&#125; 定义上述类之后，我们看下怎么使用策略模式 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; //对整型数组排序 int[] intArray = &#123;9, 8, 7, 6, 5, 4, 3, 2, 1, 0&#125;; BubbleSorter&lt;int[]&gt; intBubbleSorter = new BubbleSorter&lt;&gt;(new IntSortHandler()); int operations = intBubbleSorter.sort(intArray); System.out.println("[Strategy] operations:" + operations + ", array:" + Arrays.toString(intArray)); //对double数组排序 double[] doubleArray = &#123;9.9, 8.8, 7.7, 6.6, 5.5, 4.4, 3.3, 2.2, 1.1, 0.0&#125;; BubbleSorter&lt;double[]&gt; doubleBubbleSorter = new BubbleSorter&lt;&gt;(new DoubleSortHandler()); operations = doubleBubbleSorter.sort(doubleArray); System.out.println("[Strategy] operations:" + operations + ", array:" + Arrays.toString(doubleArray)); //对List集合排序 List&lt;Integer&gt; list = Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1, 0); BubbleSorter&lt;List&lt;Integer&gt;&gt; integerListBubbleSorter = new BubbleSorter&lt;&gt;(new IntegerListSortHandler()); operations = integerListBubbleSorter.sort(list); System.out.println("[Strategy] operations:" + operations + ", list:" + list); &#125;&#125; 策略模式不是将通用方法放到基类中，而是把它放进BubbleSorter的sort方法中，把排序算法中必须调用的抽象方法定义在SortHandler接口中，从这个接口中派生出不同的子类。把派生出的子类传给BubbleSorter后，sort方法就可以把具体工作委托给接口去完成。注意：SortHandler对BubbleSorter是一无所知的，它不依赖于冒泡排序的具体实现，这个和模板方法模式是不同的。如果其他排序算法也需要用到SortHandler，完全也可以在相关的排序算法中使用SortHandler 总结模板方法模式和策略模式都可以用来分离高层的算法和低层的具体实现细节，都允许高层的算法独立于它的具体实现细节重用。但策略模式还有一个额外的好处就是允许具体实现细节独立于高层的算法重用，但这也以一些额外的复杂性、内存以及运行事件开销作为代价 文中示例代码下载：https://github.com/shensky711/awesome-demo/tree/master/Patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式（Factory）]]></title>
    <url>%2F2016%2F11%2F26%2Fdesign-patterns-factory%2F</url>
    <content type="text"><![CDATA[概述根据依赖倒置原则，我们知道，我们应优先依赖抽象类而不是具体类。在应用开发过程中，有很多实体类都是非常易变的，依赖它们会带来问题，所以我们更应该依赖于抽象接口，已使我们免受大多数变化的影响。工厂模式（Factory）允许我们只依赖于抽象接口就能创建出具体对象的实例，所以在开发中，如果具体类是高度易变的，那么该模式就非常有用。 接下来我们就通过代码举例说明什么是工厂模式 简单工厂模式假设我们现在有个需求：把一段数据用Wi-Fi或者蓝牙发送出去。需求很简单是吧？刷刷刷就写下了以下实现： 12345678910111213141516171819private String mode; //Wi-Fi|Bluetoothpublic void onClick() &#123; byte[] data = &#123;0x00, 0x01&#125;; if ("Wi-Fi".equals(mode)) &#123; sendDataByWiFi(data); &#125; else &#123; sendDataByBluetooth(data); &#125;&#125;private void sendDataByWiFi(byte[] data) &#123; // send data via Wi-Fi&#125;private void sendDataByBluetooth(byte[] data) &#123; // send data via Bluetooth&#125; 但是上面的代码扩展性并不高，违反了开放封闭原则。比如现在又有了个新的需求，需要用zigbee把数据发送出去，就得再新增一个sendDataByZigbee方法了，而且还得修改onClick里面的逻辑。那么比较好的方法是怎么样的呢？ 定义一个数据发送器类： 123456789/** * 数据发送器Sender * * @author HansChen */public interface Sender &#123; void sendData(byte[] data);&#125; 实现WiFi数据发送： 123456789101112/** * Sender的实现类，通过Wi-Fi发送数据 * * @author HansChen */public class WiFiSender implements Sender &#123; @Override public void sendData(byte[] data) &#123; System.out.println("Send data by Wi-Fi"); &#125;&#125; 实现蓝牙数据发送： 123456789101112/** * Sender的实现类，通过蓝牙发送数据 * * @author HansChen */public class BluetoothSender implements Sender &#123; @Override public void sendData(byte[] data) &#123; System.out.println("Send data by Bluetooth"); &#125;&#125; 这样，原来发送数据的地方就改为了： 12345678910111213private String mode; //Wi-Fi|Bluetoothpublic void onClick() &#123; byte[] data = &#123;0x00, 0x01&#125;; Sender sender; if ("Wi-Fi".equals(mode)) &#123; sender = new WiFiSender(); &#125; else &#123; sender = new BluetoothSender(); &#125; sender.sendData(data);&#125; 有没有觉得代码优雅了一点？但是随着发送器Sender的实现类越来越多，每增加一个实现类，就需要在onClick里面实例化相应的实现类，能不能用一个单独的类来做这个创造实例的过程呢？这就是我们讲到的工厂。我们新增一个工厂类： 123456789101112131415161718/** * 简单工厂类 * * @author HansChen */public class SimpleFactory &#123; public static Sender createSender(String mode) &#123; switch (mode) &#123; case "Wi-Fi": return new WiFiSender(); case "Bluetooth": return new BluetoothSender(); default: throw new IllegalArgumentException("illegal type: " + mode); &#125; &#125;&#125; 这样一来，怎么实例化数据发送器我们也不用管了，最终代码变为： 12345678private String mode; //Wi-Fi|Bluetoothpublic void onClick() &#123; byte[] data = &#123;0x00, 0x01&#125;; Sender sender = SimpleFactory.createSender(mode); sender.sendData(data);&#125; 好了，到这里我们就完成了简单工厂模式的应用了，下图就是简单工厂模式的结构图： 工厂方法模式简单工厂模式的优点在于工厂类包含了必要的判断逻辑，根据传入的参数动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但是这里还是会有个问题，假设上面例子中新增了一个zigbee发送器，那么一定是需要修改简单工厂类的，也就是说，我们不但对扩展开放了，对修改也开放了，这是不好的。解决的方法是使用工厂方法模式，工厂方法模式是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。下面还是通过代码来说明： 在简单工厂模式的基础上，让我们对工厂类也升级一下，首先定义一个工厂类接口： 1234public interface SenderFactory &#123; Sender createSender();&#125; 然后为每一个发送器的实现类各创建一个具体的工厂方法去实现这个接口 定义WiFiSender的工厂类： 1234567public class WiFiSenderFactory implements SenderFactory &#123; @Override public Sender createSender() &#123; return new WiFiSender(); &#125;&#125; 定义BluetoothSender的工厂类： 1234567public class BluetoothSenderFactory implements SenderFactory &#123; @Override public Sender createSender() &#123; return new BluetoothSender(); &#125;&#125; 这样，即使有新的Sender实现类加进来，我们只需要新增相应的工厂类就行了，不需要修改原有的工厂，下图就是工厂方法模式的结构图： 客户端调用代码： 1234567891011121314private String mode; //Wi-Fi|Bluetoothpublic void onClick() &#123; byte[] data = &#123;0x00, 0x01&#125;; SenderFactory factory; if ("Wi-Fi".equals(mode)) &#123; factory = new WiFiSenderFactory(); &#125; else &#123; factory = new BluetoothSenderFactory(); &#125; Sender sender = factory.createSender(); sender.sendData(data);&#125; 细心的读者可能已经发现了，工厂方法模式实现时，客户端需要决定实例化哪一个工厂类，相比于简单工厂模式，客户端多了一个选择判断的问题，也就是说，工厂方法模式把简单工厂模式的内部逻辑判断移到了客户端！你想要加功能，本来是修改简单工厂类的，现在改为修改客户端。但是这样带来的好处是整个工厂和产品体系都没有“修改”的变化，只有“扩展”的变化，完全符合了开放封闭原则。 总结简单工厂模式和工厂方法模式都封装了对象的创建，它们使得高层策略模块在创建类的实例时无需依赖于这些类的具体实现。但是两种工厂模式之间又有差异： 简单工厂模式：最大的优点在于工厂类包含了必要的判断逻辑，根据客户端的条件动态地实例化相关的类。但这也是它的缺点，当扩展功能的时候，需要修改工厂方法，违反了开放封闭原则 工厂方法模式：符合开放封闭原则，但这带来的代价是扩展的时候要增加相应的工厂类，增加了开发量，而且需要修改客户端代码]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
        <tag>Factory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment源码分析]]></title>
    <url>%2F2016%2F11%2F15%2Ffragment%2F</url>
    <content type="text"><![CDATA[概述Fragment表示 Activity 中的行为或用户界面部分。您可以将多个 Fragment 组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个 Fragment。您可以将 Fragment 视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除 Fragment。Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有 Fragment 也会暂停；当 Activity 被销毁时，所有 Fragment 也会被销毁。 不过，当 Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个 Fragment，如添加或移除它们。 当您执行此类 Fragment 事务时，您也可以将其添加到由 Activity 管理的返回栈 — Activity 中的每个返回栈条目都是一条已发生 Fragment 事务的记录。 返回栈让用户可以通过按返回按钮撤消 Fragment 事务（后退）。 当您将 Fragment 作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且 Fragment 会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明Fragment，将其作为 &lt;fragment&gt; 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，利用应用代码进行插入。不过，Fragment 并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的 Fragment 用作 Activity 的不可见工作线程。 本文将通过分析源码，对 Fragment 的创建、销毁以及生命周期做一个更深入的认识。 建议读者在看这篇文章的时候，先看下Fragment事务管理源码分析，对Fragment管理类先有一个比较清楚的认识。 分析入口1234567891011121314151617/** * 构造并显示Fragment * * @param containerViewId 容器控件id * @param clz Fragment类 */protected void showFragment(@IdRes int containerViewId, Class&lt;? extends Fragment&gt; clz) &#123; FragmentManager fm = getFragmentManager(); FragmentTransaction ft = fm.beginTransaction();//开始事务管理 try &#123; Fragment f = clz.newInstance(); ft.add(containerViewId, f, clz.getName());//添加操作 ft.commit();//提交事务 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 上面的代码就是动态地往containerViewId里添加一个Fragment并让它显示出来，可以看到，这个涉及到Fragment的事务管理，详细可以参考Fragment事务管理源码分析，这里就不再阐述了。 代码分析BackStackRecord#run调用了commit之后，真正执行的地方是在BackStackRecord的run方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public void run() &#123; ...... if (mManager.mCurState &gt;= Fragment.CREATED) &#123; SparseArray&lt;Fragment&gt; firstOutFragments = new SparseArray&lt;Fragment&gt;(); SparseArray&lt;Fragment&gt; lastInFragments = new SparseArray&lt;Fragment&gt;(); calculateFragments(firstOutFragments, lastInFragments); beginTransition(firstOutFragments, lastInFragments, false); &#125; //遍历链表，根据cmd事务类型依次处理事务 Op op = mHead; while (op != null) &#123; switch (op.cmd) &#123; case OP_ADD: &#123; //添加一个新的Fragment Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.addFragment(f, false); &#125; break; case OP_REPLACE: &#123; Fragment f = op.fragment; int containerId = f.mContainerId; if (mManager.mAdded != null) &#123; for (int i = mManager.mAdded.size() - 1; i &gt;= 0; i--) &#123; Fragment old = mManager.mAdded.get(i); if (old.mContainerId == containerId) &#123; if (old == f) &#123; op.fragment = f = null; &#125; else &#123; if (op.removed == null) &#123; op.removed = new ArrayList&lt;Fragment&gt;(); &#125; op.removed.add(old); old.mNextAnim = op.exitAnim; if (mAddToBackStack) &#123; old.mBackStackNesting += 1; &#125; mManager.removeFragment(old, mTransition, mTransitionStyle); &#125; &#125; &#125; &#125; if (f != null) &#123; f.mNextAnim = op.enterAnim; mManager.addFragment(f, false); &#125; &#125; break; case OP_REMOVE: &#123; Fragment f = op.fragment; f.mNextAnim = op.exitAnim; mManager.removeFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_HIDE: &#123; Fragment f = op.fragment; f.mNextAnim = op.exitAnim; mManager.hideFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_SHOW: &#123; Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.showFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_DETACH: &#123; Fragment f = op.fragment; f.mNextAnim = op.exitAnim; mManager.detachFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_ATTACH: &#123; Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.attachFragment(f, mTransition, mTransitionStyle); &#125; break; default: &#123; throw new IllegalArgumentException("Unknown cmd: " + op.cmd); &#125; &#125; op = op.next; &#125; mManager.moveToState(mManager.mCurState, mTransition, mTransitionStyle, true); if (mAddToBackStack) &#123; mManager.addBackStackState(this); &#125;&#125; 因为我们调用的是add操作，所以执行的代码片段是： 123456case OP_ADD: &#123; Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.addFragment(f, false);&#125;break; 参数解释： op.fragment：showFragment中创建的Fragment实例，并且现在Fragment的mTag、mFragmentId、mContainerId已被初始化过了 op.enterAnim:入场动画，可以先不管 mManager：FragmentManagerImpl实例 FragmentManagerImpl#addFragment1234567891011121314151617181920212223242526272829public void addFragment(Fragment fragment, boolean moveToStateNow) &#123; //已添加的Fragment列表 if (mAdded == null) &#123; mAdded = new ArrayList&lt;Fragment&gt;(); &#125; //设置Fragment的mIndex，并把Fragment添加到mActive列表 makeActive(fragment); //判断是否被detach。默认为false if (!fragment.mDetached) &#123; if (mAdded.contains(fragment)) &#123; throw new IllegalStateException("Fragment already added: " + fragment); &#125; //把Fragment添加到mAdded列表 mAdded.add(fragment); //设置Fragment标记位 fragment.mAdded = true; fragment.mRemoving = false; //判断是否需要刷新菜单 if (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123; mNeedMenuInvalidate = true; &#125; //在这次分析中moveToStateNow为false，moveToState方法在本方法外层方法中调用 if (moveToStateNow) &#123; moveToState(fragment); &#125; &#125;&#125; addFragment里面把Fragment加入mActive和mAdded列表，并且设置标记为fragment.mAdded为true，fragment.mRemoving为false。执行完ADD操作后，执行moveToState，moveToState顾名思义，就是把Fragment变为某种状态 12345678//mManager.mCurState的状态很重要，我们下面会分析它现在处于什么状态mManager.moveToState(mManager.mCurState, mTransition, mTransitionStyle, true);//添加本次操作到回退栈中if (mAddToBackStack) &#123; mManager.addBackStackState(this);&#125; Fragment状态我们知道Fragment的生命周期是依赖于Activity的，比如Activity处于onResume,那么Fragment也会处于onResume状态，这里的参数mManager.mCurState对应的状态有： 1234567static final int INVALID_STATE = -1; // Invalid state used as a null value.static final int INITIALIZING = 0; // Not yet created.static final int CREATED = 1; // Created.static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.static final int STOPPED = 3; // Fully created, not started.static final int STARTED = 4; // Created and started, not resumed.static final int RESUMED = 5; // Created started and resumed. mCurState的初始状态是Fragment.INITIALIZING，那么在BackStackRecord中调用moveToState的时候，mCurState是什么值呢？它是会受Activity生命周期影响而变化的，我们来看下FragmentActivity的代码 123456789101112@SuppressWarnings("deprecation")@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; //绑定FragmentManager mFragments.attachHost(null /*parent*/); super.onCreate(savedInstanceState); ... ... //分发Fragment的create事件 mFragments.dispatchCreate();&#125; 123456789101112131415161718192021public void dispatchCreate() &#123; mHost.mFragmentManager.dispatchCreate();&#125;public void dispatchCreate() &#123; mStateSaved = false; //注意这里设置了新的state moveToState(Fragment.CREATED, false);&#125;void moveToState(int newState, boolean always) &#123; moveToState(newState, 0, 0, always);&#125;void moveToState(int newState, int transit, int transitStyle, boolean always) &#123; ... ... //给mCurState赋值 mCurState = newState; ... ...&#125; 在onCreate中把mCurState变为Fragment.CREATED状态了，Activity的其他生命周期方法回调的时候，也会改变这个状态，大致整理如下： onCreate：Fragment.CREATED onStart：Fragment.ACTIVITY_CREATED–&gt;Fragment.STARTED (Fragment.ACTIVITY_CREATED只会在Activity创建之后触发一次，Fragment.STARTED每次onStart的时候都会触发) onResume：Fragment.RESUMED onPause：Fragment.STARTED onStop：Fragment.STOPPED onDestroy：Fragment.INITIALIZING 下面是一张状态迁移图： 所以随着Activity生命周期的推进，Activity内所有Fragment的生命周期也会跟着推进。从Activity创建到显示出来，最后会处于onResume状态，那么我们这次就直接分析当前Activity处于onResume调用之后的情形好了。所以假定现在mCurState为Fragment.RESUMED， 让我们继续跟踪FragmentManagerImpl FragmentManagerImpl#moveToState1234567891011121314151617181920212223242526272829303132333435void moveToState(int newState, int transit, int transitStyle, boolean always) &#123; if (mHost == null &amp;&amp; newState != Fragment.INITIALIZING) &#123; throw new IllegalStateException("No activity"); &#125; if (!always &amp;&amp; mCurState == newState) &#123; return; &#125; mCurState = newState; if (mActive != null) &#123; boolean loadersRunning = false; //遍历所有Active状态的Fragment，改变所有Fragment的状态 for (int i=0; i&lt;mActive.size(); i++) &#123; Fragment f = mActive.get(i); if (f != null) &#123; //关键代码 moveToState(f, newState, transit, transitStyle, false); if (f.mLoaderManager != null) &#123; loadersRunning |= f.mLoaderManager.hasRunningLoaders(); &#125; &#125; &#125; if (!loadersRunning) &#123; startPendingDeferredFragments(); &#125; //让Activity刷新Menu if (mNeedMenuInvalidate &amp;&amp; mHost != null &amp;&amp; mCurState == Fragment.RESUMED) &#123; mHost.onInvalidateOptionsMenu(); mNeedMenuInvalidate = false; &#125; &#125;&#125; 设置最新的mCurState状态，通过上面的分析，我们知道newState等于Fragment.RESUMED。遍历mActive列表中保存的Fragment，改变Fragment状态，这里又调用了一个moveToState方法，这个方法就是真正回调Fragment生命周期的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123; // Fragments被detach或Fragment没有添加到mAdded列表的话，设置目标Fragment的新状态为CREATED状态，此次分析中不会进入这个分支 if ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123; newState = Fragment.CREATED; &#125; //此次分析中f.mRemoving为false if (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123; // While removing a fragment, we can't change it to a higher state. newState = f.mState; &#125; // 是否延时启动 if (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123; newState = Fragment.STOPPED; &#125; if (f.mState &lt; newState) &#123; //此次命中的分支 ...... //根据Fragment当前的状态，选择case的分支。需要注意的是，这里的switch case是没有break语句的。这种设计可以让Fragment把自身的状态依次推进到目标状态 switch (f.mState) &#123; case Fragment.INITIALIZING: if (f.mSavedFragmentState != null) &#123; ...... &#125; f.mHost = mHost; //mParent是在FragmentActivity的onCreate方法中调用attachHost传进来的，传进来的是空值 f.mParentFragment = mParent; f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl(); f.mCalled = false; //【Fragment生命周期】onAttach回调，里面会把mCalled设置为true f.onAttach(mHost.getContext()); if (!f.mCalled) &#123; throw new SuperNotCalledException("Fragment " + f + " did not call through to super.onAttach()"); &#125; if (f.mParentFragment == null) &#123; //让Activity可以监听到Fragment的attach mHost.onAttachFragment(f); &#125; else &#123; f.mParentFragment.onAttachFragment(f); &#125; //f.mRetaining默认为false if (!f.mRetaining) &#123; //关键代码，内部会调用【Fragment生命周期】onCreate f.performCreate(f.mSavedFragmentState); &#125; else &#123; f.restoreChildFragmentState(f.mSavedFragmentState, true); f.mState = Fragment.CREATED; &#125; f.mRetaining = false; //Fragment是否定义在Layout文件的&lt;fragment&gt;标签中的，本次栗子为代码动态添加Fragment，所以为false if (f.mFromLayout) &#123; // For fragments that are part of the content view // layout, we need to instantiate the view immediately // and the inflater will take care of adding it. f.mView = f.performCreateView(f.getLayoutInflater( f.mSavedFragmentState), null, f.mSavedFragmentState); if (f.mView != null) &#123; f.mView.setSaveFromParentEnabled(false); if (f.mHidden) f.mView.setVisibility(View.GONE); f.onViewCreated(f.mView, f.mSavedFragmentState); &#125; &#125; //注意，这里没有break case Fragment.CREATED: if (newState &gt; Fragment.CREATED) &#123; if (!f.mFromLayout) &#123; //开始创建Fragment的view ViewGroup container = null; if (f.mContainerId != 0) &#123; if (f.mContainerId == View.NO_ID) &#123; throwException(new IllegalArgumentException("")); &#125; //调用Activity的findViewById方法查找控件 container = (ViewGroup) mContainer.onFindViewById(f.mContainerId); if (container == null &amp;&amp; !f.mRestored) &#123; ...... &#125; &#125; f.mContainer = container; //关键代码，内部会调用【Fragment生命周期】onCreateView，并返回Fragment中new出的视图 f.mView = f.performCreateView(f.getLayoutInflater( f.mSavedFragmentState), container, f.mSavedFragmentState); if (f.mView != null) &#123; f.mView.setSaveFromParentEnabled(false); if (container != null) &#123; //设置入场动画 Animator anim = loadAnimator(f, transit, true, transitionStyle); if (anim != null) &#123; anim.setTarget(f.mView); setHWLayerAnimListenerIfAlpha(f.mView, anim); anim.start(); &#125; //把Fragment的view加入到父控件 container.addView(f.mView); &#125; if (f.mHidden) f.mView.setVisibility(View.GONE); //【Fragment生命周期】onViewCreated回调 f.onViewCreated(f.mView, f.mSavedFragmentState); &#125; &#125; //关键代码，内部会调用【Fragment生命周期】onActivityCreated f.performActivityCreated(f.mSavedFragmentState); if (f.mView != null) &#123; f.restoreViewState(f.mSavedFragmentState); &#125; f.mSavedFragmentState = null; &#125; case Fragment.ACTIVITY_CREATED: if (newState &gt; Fragment.ACTIVITY_CREATED) &#123; f.mState = Fragment.STOPPED; &#125; case Fragment.STOPPED: if (newState &gt; Fragment.STOPPED) &#123; if (DEBUG) Log.v(TAG, "moveto STARTED: " + f); //关键代码，内部会调用【Fragment生命周期】onStart f.performStart(); &#125; case Fragment.STARTED: if (newState &gt; Fragment.STARTED) &#123; //关键代码，内部会调用【Fragment生命周期】onResume f.performResume(); // Get rid of this in case we saved it and never needed it. f.mSavedFragmentState = null; f.mSavedViewState = null; &#125; &#125; &#125; else if (f.mState &gt; newState) &#123; //state降级处理 ...... &#125; if (f.mState != newState) &#123; f.mState = newState; &#125;&#125; 这段代码逻辑还是比较长，我把注释写在代码里了。可以看到，这个代码写得很巧妙，通过switch case控制，可以一层一层地把Fragment的生命周期推进下去，比如当前fragnemt的state是Fragment.STARTED，那么它就只会执行performResume，如果Fragment的状态是Fragment.INITIALIZING，那么就会从switch的最开始依次执行下来，把Fragment的生命周期onAttach–&gt;onResume依次调用。简要说明下上面的代码： mHost是FragmentHostCallback抽象类的实例，它的实现类是Activity的HostCallbacks mParent为null mHost.getContext()获取的context就是宿主Activity实例 Fragment中创建的View会自动通过container.addView(f.mView)添加到父控件中 很多Fragment的生命周期是通过Fragment的performXxx()方法去调用的，比如： 1234567891011121314151617181920212223242526272829void performCreate(Bundle savedInstanceState) &#123; ...... onCreate(savedInstanceState); ......&#125;View performCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; ...... return onCreateView(inflater, container, savedInstanceState);&#125;void performActivityCreated(Bundle savedInstanceState) &#123; ...... onActivityCreated(savedInstanceState); ......&#125;void performStart() &#123; ...... onStart(); ......&#125;void performResume() &#123; ...... onResume(); ......&#125; Fragment状态的降级操作有些童鞋们可能会有疑问，上面只分析到了onAttach-&gt;onResume生命周期的回调，那onPause、onDestroy等方法又是什么时候执行的呢？我们再看下刚才的代码 123456if (f.mState &lt; newState) &#123; ......&#125; else if (f.mState &gt; newState) &#123; //state降级处理 ......&#125; 答案就是在else if分支里面，比如当Acivity锁屏的时候，就Activity生命周期会自动回调onPause，从而触发dispatchPause，在里面调用moveToState(Fragment.STARTED, false);由于Fragment当前的状态是RESUMED状态，大于newState，所以就会走else if的分支，触发相应的生命周期方法。else if分支的逻辑和state升级的差不多，这里就再进行分析了 生命周期最后，放张官网上公布的Fragment生命周期图，通过代码分析，我们发现代码的中生命周期的调用顺序和图中确实是一致的 总结本文大致地从源码的角度分析了Fragment创建、生命周期回调的过程，如果读者对Fragment的remove、replace、hide、detach、attach等操作有兴趣的话，可以自行分析，核心代码主要在BackStackRecord类的run方法以及FragmentManagerImpl的moveToState方法中。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment事务管理源码分析]]></title>
    <url>%2F2016%2F11%2F11%2Ffragment-transaction%2F</url>
    <content type="text"><![CDATA[概述在Fragment使用中，有时候需要对Fragment进行add、remove、show、hide、replace等操作来进行Fragment的显示隐藏等管理，这些管理是通过FragmentTransaction进行事务管理的。事务管理是对于一系列操作进行管理，一个事务包含一个或多个操作命令，是逻辑管理的工作单元。一个事务开始于第一次执行操作语句，结束于Commit。通俗地将，就是把多个操作缓存起来，等调用commit的时候，统一批处理。下面会对Fragmeng的事务管理做一个代码分析 分析入口12345678910111213141516171819202122/** * 显示Fragment，如果Fragment已添加过，则直接show，否则构造一个Fragment * * @param containerViewId 容器控件id * @param clz Fragment类 */protected void showFragment(@IdRes int containerViewId, Class&lt;? extends Fragment&gt; clz) &#123; FragmentManager fm = getFragmentManager(); FragmentTransaction ft = fm.beginTransaction();//开始事务管理 Fragment f; if ((f = fm.findFragmentByTag(clz.getName())) == null) &#123; try &#123; f = clz.newInstance(); ft.add(containerViewId, f, clz.getName());//添加操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; ft.show(f);//添加操作 &#125; ft.commit();//提交事务&#125; 上面是一个简单的显示Fragment的栗子，简单判断一下Fragment是否已添加过，添加过就直接show，否则构造一个Fragment，最后提交事务。 代码分析FragmentManager上图是获取FragmentManager的大体过程 要管理Fragment事务，首先是需要拿到FragmentManager，在Activity中可以通过getFragmentManager()方法获取(使用兼容包的话，通过FragmentActivity#getSupportFragmentManager())，在这里我们就不对兼容包进行分析了 123456789final FragmentController mFragments = FragmentController.createController(new HostCallbacks());/** * Return the FragmentManager for interacting with fragments associated * with this activity. */public FragmentManager getFragmentManager() &#123; return mFragments.getFragmentManager();&#125; FragmentManager是一个抽象类，它是通过mFragments.getFragmentManager()来获取的，mFragments是FragmentController对象，它通过FragmentController.createController(new HostCallbacks())生成，这是一个静态工厂方法： 123public static final FragmentController createController(FragmentHostCallback&lt;?&gt; callbacks) &#123; return new FragmentController(callbacks);&#125; 在这里面直接new了一个FragmentController对象，注意FragmentController的构造方法需要传入一个FragmentHostCallback FragmentController构造方法1234private final FragmentHostCallback&lt;?&gt; mHost;private FragmentController(FragmentHostCallback&lt;?&gt; callbacks) &#123; mHost = callbacks;&#125; 构造方法很简单，传入了一个FragmentHostCallback实例 FragmentController#getFragmentManager123public FragmentManager getFragmentManager() &#123; return mHost.getFragmentManagerImpl();&#125; 这里又调用了mHost的getFragmentManagerImpl方法，希望童鞋们没有被绕晕，mHost是一个FragmentHostCallback实例，那我们回过头来看看它传进来的地方 FragmentHostCallback这个FragmentHostCallback是一个抽象类，我们可以看到，在Activity中是传入了 Activity#HostCallbacks内部类，这个就是FragmentHostCallback的实现类 FragmentHostCallback#getFragmentManagerImpl1234final FragmentManagerImpl mFragmentManager = new FragmentManagerImpl();FragmentManagerImpl getFragmentManagerImpl() &#123; return mFragmentManager;&#125; 终于找到FragmentManager的真身FragmentManagerImpl了 FragmentManagerImpl#beginTransaction1234@Overridepublic FragmentTransaction beginTransaction() &#123; return new BackStackRecord(this);&#125; 可以看到，所谓的FragmentTransaction其实就是一个BackStackRecord。到现在，FragmentManager和FragmentTransaction我们都找到了。下图就是各个类之间的关系： 下面开始真正的事务管理分析，我们先选择一个事务add来进行分析 FragmentTransaction#add12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) &#123; doAddOp(containerViewId, fragment, tag, OP_ADD); return this;&#125;private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; //设置fragment的FragmentManagerImpl，mManager其实就是Activity#HostCallbacks中的成员变量 fragment.mFragmentManager = mManager; //设置fragment的tag if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException("..."); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (containerViewId == View.NO_ID) &#123; throw new IllegalArgumentException("..."); &#125; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException(""); &#125; //设置fragment的mContainerId以及mFragmentId fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; //新增一个操作 Op op = new Op(); op.cmd = opcmd; op.fragment = fragment; //添加操作 addOp(op);&#125;//插入到链表的最后void addOp(Op op) &#123; if (mHead == null) &#123; mHead = mTail = op; &#125; else &#123; op.prev = mTail; mTail.next = op; mTail = op; &#125; op.enterAnim = mEnterAnim; op.exitAnim = mExitAnim; op.popEnterAnim = mPopEnterAnim; op.popExitAnim = mPopExitAnim; mNumOp++;&#125; add的操作步骤为： 设置fragment的FragmentManagerImpl 设置fragment的tag 设置fragment的mContainerId以及mFragmentId 插入一个类型为OP_ADD的操作到链表最后 这里用到了一个类： 1234567891011static final class Op &#123; Op next;//下一操作节点 Op prev;//上一操作节点 int cmd;//操作类型，可选有：OP_NULL|OP_ADD|OP_REPLACE|OP_REMOVE|OP_HIDE|OP_SHOW|OP_DETACH|OP_ATTACH Fragment fragment;//操作的Fragment对象 int enterAnim;//入场动画 int exitAnim;//出场动画 int popEnterAnim;//弹入动画 int popExitAnim;//弹出动画 ArrayList&lt;Fragment&gt; removed;&#125; 这是一个操作链表节点。所有add、remove、hide等事物最终会形成一个操作链 FragmentTransaction#commit等所有操作都插入后，最后我们需要调用FragmentTransaction的commit方法，操作才会真正地执行。 12345678910111213141516171819202122232425262728293031public int commit() &#123; return commitInternal(false);&#125;int commitInternal(boolean allowStateLoss) &#123; //防止重复commit if (mCommitted) &#123; throw new IllegalStateException("commit already called"); &#125; //DEBUG代码统统不管 if (FragmentManagerImpl.DEBUG) &#123; Log.v(TAG, "Commit: " + this); LogWriter logw = new LogWriter(Log.VERBOSE, TAG); PrintWriter pw = new FastPrintWriter(logw, false, 1024); dump(" ", null, pw, null); pw.flush(); &#125; mCommitted = true; //只有调用了addToBackStack方法之后，这个标记才会为true if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; //插入事物队列 mManager.enqueueAction(this, allowStateLoss); return mIndex;&#125; FragmentManagerImpl#enqueueAction12345678910111213141516171819202122232425/** * Adds an action to the queue of pending actions. * * @param action the action to add * @param allowStateLoss whether to allow loss of state information * @throws IllegalStateException if the activity has been destroyed */public void enqueueAction(Runnable action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; throw new IllegalStateException("Activity has been destroyed"); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;Runnable&gt;(); &#125; mPendingActions.add(action); if (mPendingActions.size() == 1) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125;&#125; 这里把操作添加到mPendingActions列表里去。并通过mHost.getHandler()获取Handler发送执行请求。从上面的分析知道，mHost就是Activity的HostCallbacks，构造方法中把Activity的mHandler传进去了，这里执行的mHost.getHandler()获取到的也就是Activity中的mHandler，这样做是因为需要在主线程中执行 1final Handler mHandler = new Handler(); 再看看mExecCommit中做了什么操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Runnable mExecCommit = new Runnable() &#123; @Override public void run() &#123; execPendingActions(); &#125;&#125;;/** * Only call from main thread! */public boolean execPendingActions() &#123; if (mExecutingActions) &#123; throw new IllegalStateException("Recursive entry to executePendingTransactions"); &#125; //再次检测是否主线程 if (Looper.myLooper() != mHost.getHandler().getLooper()) &#123; throw new IllegalStateException("Must be called from main thread of process"); &#125; boolean didSomething = false; while (true) &#123; int numActions; synchronized (this) &#123; //参数检测 if (mPendingActions == null || mPendingActions.size() == 0) &#123; break; &#125; numActions = mPendingActions.size(); if (mTmpActions == null || mTmpActions.length &lt; numActions) &#123; mTmpActions = new Runnable[numActions]; &#125; mPendingActions.toArray(mTmpActions); mPendingActions.clear(); mHost.getHandler().removeCallbacks(mExecCommit); &#125; mExecutingActions = true; //遍历执行待处理的事务操作 for (int i=0; i&lt;numActions; i++) &#123; mTmpActions[i].run(); mTmpActions[i] = null; &#125; mExecutingActions = false; didSomething = true; &#125; doPendingDeferredStart(); return didSomething;&#125; 插入了事物之后，就是在主线程中把需要处理的事务统一处理，处理事务是通过执行mTmpActions[i].run()进行的，这个mTmpActions[i]就是前面我们通过enqueueAction方法插入的BackStackRecord，童鞋们可能没注意到，它可是一个Runnable，我们来看看它的定义 123456final class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, Runnable &#123; static final String TAG = FragmentManagerImpl.TAG; ... ...&#125; 兜兜转转，我们又回到了BackStackRecord BackStackRecord#run12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public void run() &#123; ...... if (mManager.mCurState &gt;= Fragment.CREATED) &#123; SparseArray&lt;Fragment&gt; firstOutFragments = new SparseArray&lt;Fragment&gt;(); SparseArray&lt;Fragment&gt; lastInFragments = new SparseArray&lt;Fragment&gt;(); calculateFragments(firstOutFragments, lastInFragments); beginTransition(firstOutFragments, lastInFragments, false); &#125; //遍历链表，根据cmd事务类型依次处理事务 Op op = mHead; while (op != null) &#123; switch (op.cmd) &#123; case OP_ADD: &#123; Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.addFragment(f, false); &#125; break; case OP_REPLACE: &#123; Fragment f = op.fragment; int containerId = f.mContainerId; if (mManager.mAdded != null) &#123; for (int i = mManager.mAdded.size() - 1; i &gt;= 0; i--) &#123; Fragment old = mManager.mAdded.get(i); if (old.mContainerId == containerId) &#123; if (old == f) &#123; op.fragment = f = null; &#125; else &#123; if (op.removed == null) &#123; op.removed = new ArrayList&lt;Fragment&gt;(); &#125; op.removed.add(old); old.mNextAnim = op.exitAnim; if (mAddToBackStack) &#123; old.mBackStackNesting += 1; &#125; mManager.removeFragment(old, mTransition, mTransitionStyle); &#125; &#125; &#125; &#125; if (f != null) &#123; f.mNextAnim = op.enterAnim; mManager.addFragment(f, false); &#125; &#125; break; case OP_REMOVE: &#123; Fragment f = op.fragment; f.mNextAnim = op.exitAnim; mManager.removeFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_HIDE: &#123; Fragment f = op.fragment; f.mNextAnim = op.exitAnim; mManager.hideFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_SHOW: &#123; Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.showFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_DETACH: &#123; Fragment f = op.fragment; f.mNextAnim = op.exitAnim; mManager.detachFragment(f, mTransition, mTransitionStyle); &#125; break; case OP_ATTACH: &#123; Fragment f = op.fragment; f.mNextAnim = op.enterAnim; mManager.attachFragment(f, mTransition, mTransitionStyle); &#125; break; default: &#123; throw new IllegalArgumentException("Unknown cmd: " + op.cmd); &#125; &#125; op = op.next; &#125; mManager.moveToState(mManager.mCurState, mTransition, mTransitionStyle, true); if (mAddToBackStack) &#123; mManager.addBackStackState(this); &#125;&#125; 到这一步，提交的事务就被真正执行了，我们知道，即使commit了事务之后，也不是同步执行的，是通过Handler发送到主线程执行的。 所有事务的处理都是在run方法里面执行，但是我们留意到，想要搞清楚add、remove等事务背后真正做了什么，还需要深入了解FragmentManagerImpl。 本文主要讲解Fragment事务的流程，FragmentManagerImpl的分析准备放到下一篇分析文章Fragment源码分析中，相信通过分析之后，就可以对Fragment的生命周期也有一个很好的认识了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
        <tag>源码分析</tag>
        <tag>事务管理</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2F2016%2F10%2F20%2Fjava-proxy%2F</url>
    <content type="text"><![CDATA[概述动态代理是java的一大特性，动态代理的优势就是实现无侵入式的代码扩展。它可以增强我们原有的方法，比如常用的日志监控,添加缓存等，也可以实现方法拦截，通过代理方法修改原方法的参数和返回值等。要了解动态代理，我们需要先看看什么是静态代理 静态代理首先你有一个接口： 1234public interface Api &#123; String doSomething(String input);&#125; 这个接口有一个原始的实现： 1234567public class ApiImpl implements Api &#123; @Override public String doSomething(String input) &#123; return input + "原始方法"; &#125;&#125; 现在问题来了，有一个新的需求，我需要在所有调用doSomething的地方都添加一个log，那怎么办呢？我们当然可以在原有代码上直接加上log，但是ApiImpl里面的log真的是那段代码需要的吗？如果不修改原有代码，能不能实现？当然可以，如，我们添加一个代理类： 1234567891011121314public class ApiProxy implements Api &#123; private Api mBase; public ApiProxy(Api base) &#123; mBase = base; &#125; @Override public String doSomething(String input) &#123; System.out.println("someone call me~"); return mBase.doSomething(input); &#125;&#125; 这样，通过ApiProxy我们就是实现静态代理，这里只是简单的添加了log，我们完全可以在ApiProxy的doSomething方法里面，篡改输入参数input以及返回值，从而做一些坏事~ 动态代理在上面静态代理例子中，我们已经实现了代理的功能，那为何还需要动态代理呢？设想一下以下两种情况 如果Api接口类中有100个方法，需要为每个方法都添加log 项目中有100个类，需要为每个类的方法都添加log 对于第一种情况，如果使用静态代理，那就只能这样了： 12345678910111213141516171819202122public class ApiProxy implements Api &#123; private Api mBase; public ApiProxy(Api base) &#123; mBase = base; &#125; @Override public String doSomething(String input) &#123; System.out.println("someone call me~"); return mBase.doSomething(input); &#125; @Override public String doSomething1(String input) &#123; System.out.println("someone call me~"); return mBase.doSomething1(input); &#125; //为每个方法添加实现......&#125; 而对于第二种情况，就只能新建100个代理类了。这种处理方式肯定不是我们喜欢的，怎么优雅地去解决了？动态代理这时候终于可以上场了。 JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了，比如: 实现InvocationHandler 1234567891011121314151617181920212223public class ApiHandler implements InvocationHandler &#123; private Api mBase; public ApiHandler(Api base) &#123; mBase = base; &#125; /** * 此方法会在proxy实例调用方法的时候回调 * * @param proxy 代理对象 * @param method 被调用的方法 * @param args 调用参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("someone call me~"); return method.invoke(mBase, args); &#125;&#125; 动态创建代理类 1234567private static void proxyTest() &#123; ClassLoader loader = Api.class.getClassLoader();//加载代理类的ClassLoader Class[] interfaces = new Class[]&#123;Api.class&#125;;//需要代理的接口 Api proxy = (Api) Proxy.newProxyInstance(loader, interfaces, new ApiHandler(new ApiImpl()));//创建代理对象 proxy.doSomething("test");//会调用ApiHandler的invoke方法 proxy.doSomething1("test");//会调用ApiHandler的invoke方法&#125; 这样，一个动态代理就完成了，但这里有个需要注意的，动态代理只能代理接口，也就是说interfaces数组里面，只能放接口Class 代理Hook代理有比原始对象更强大的能力，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。首先我们得找到被Hook的对象，也就是Hook点；什么样的对象比较适合Hook呢？静态变量和单例；在一个进程之内，静态变量和单例变量是不容易发生变化的，所以容易定位，而普通的对象则要么无法标志，要么容易改变，我们根据这个原则找到所谓的Hook点。一般Hook的步骤有： 寻找Hook点，如静态变量或单例对象，尽量Hook pulic的对象和方法，非public不保证每个版本都一样，需要适配。 选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib 用代理对象替换原始对象，如果没有公开是geter/setter方法，可以使用反射]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>proxy</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android分包MultiDex源码分析]]></title>
    <url>%2F2016%2F10%2F18%2Fmultidex%2F</url>
    <content type="text"><![CDATA[概述Android开发者应该都遇到了64K最大方法数限制的问题，针对这个问题，google也推出了multidex分包机制，在生成apk的时候，把整个应用拆成n个dex包（classes.dex、classes2.dex、classes3.dex），每个dex不超过64k个方法。使用multidex，在5.0以前的系统，应用安装时只安装main dex（包含了应用启动需要的必要class），在应用启动之后，需在Application的attachBaseContext中调用MultiDex.install(base)方法，在这时候才加载第二、第三…个dex文件，从而规避了64k问题。当然，在attachBaseContext方法中直接install启动second dex会有一些问题，比如install方法是一个同步方法，当在主线程中加载的dex太大的时候，耗时会比较长，可能会触发ANR。不过这是另外一个问题了，解决方法可以参考：Android最大方法数和解决方案 http://blog.csdn.net/shensky711/article/details/52329035。 本文主要分析的是MultiDex.install()到底做了什么，如何把secondary dexes中的类动态加载进来。 MultiDex使用到的路径解析 ApplicationInfo.sourceDir:apk的安装路径，如/data/app/com.hanschen.multidex-1.apk Context.getFilesDir()：返回/data/data/&lt;packagename&gt;/files目录，一般通过openFileOutput方法输出文件到该目录 ApplicationInfo.dataDir: 返回/data/data/&lt;packagename&gt;目录 源码分析代码入口代码入口很简单，简单粗暴，就调用了一个静态方法MultiDex.install(base);，传入一个Context对象 12345@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(base);&#125; MultiDex.install分析下面是主要的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static void install(Context context) &#123; Log.i("MultiDex", "install"); if (IS_VM_MULTIDEX_CAPABLE) &#123; //VM版本大于2.1时，IS_VM_MULTIDEX_CAPABLE为true，这时候MultiDex.install什么也不用做，直接返回。因为大于2.1的VM会在安装应用的时候，就把多个dex合并到一块 &#125; else if (VERSION.SDK_INT &lt; 4) &#123; //Multi dex最小支持的SDK版本为4 throw new RuntimeException("Multi dex installation failed. SDK " + VERSION.SDK_INT + " is unsupported. Min SDK version is " + 4 + "."); &#125; else &#123; try &#123; ApplicationInfo e = getApplicationInfo(context); if (e == null) &#123; return; &#125; Set var2 = installedApk; synchronized (installedApk) &#123; String apkPath = e.sourceDir; //检测应用是否已经执行过install()了，防止重复install if (installedApk.contains(apkPath)) &#123; return; &#125; installedApk.add(apkPath); //获取ClassLoader，后面会用它来加载second dex DexClassLoader classLoader; ClassLoader loader; try &#123; loader = context.getClassLoader(); &#125; catch (RuntimeException var9) &#123; return; &#125; if (loader == null) &#123; return; &#125; //清空目录：/data/data/&lt;packagename&gt;/files/secondary-dexes/，其实我没搞明白这个的作用，因为从后面的代码来看，这个目录是没有使用到的 try &#123; clearOldDexDir(context); &#125; catch (Throwable var8) &#123; &#125; File dexDir = new File(e.dataDir, "code_cache/secondary-dexes"); //把dex文件缓存到/data/data/&lt;packagename&gt;/code_cache/secondary-dexes/目录，[后有详细分析] List files = MultiDexExtractor.load(context, e, dexDir, false); if (checkValidZipFiles(files)) &#123; //进行安装，[后有详细分析] installSecondaryDexes(loader, dexDir, files); &#125; else &#123; //文件无效，从apk文件中再次解压secondary dex文件后进行安装 files = MultiDexExtractor.load(context, e, dexDir, true); if (!checkValidZipFiles(files)) &#123; throw new RuntimeException("Zip files were not valid."); &#125; installSecondaryDexes(loader, dexDir, files); &#125; &#125; &#125; catch (Exception var11) &#123; throw new RuntimeException("Multi dex installation failed (" + var11.getMessage() + ")."); &#125; &#125;&#125; 这段代码的主要逻辑整理如下： VM版本检测，如果大于2.1就什么都不做(系统在安装应用的时候已经帮我们把dex合并了)，如果系统SDK版本小于4就抛出运行时异常 把apk中的secondary dexes解压到缓存目录，并把这些缓存读取出来。应用第二次启动的时候，会尝试从缓存目录中读取，除非读取出的文件校验失败，否则不再从apk中解压dexes 根据当前的SDK版本，执行不同的安装方法 先来看看MultiDexExtractor.load(context, e, dexDir, false) 1234567891011121314151617181920212223242526272829303132/** * 解压apk文件中的classes2.dex、classes3.dex等文件解压到dexDir目录中 * * @param dexDir 解压目录 * @param forceReload 是否需要强制从apk文件中解压，否的话会直接读取旧文件 * @return 解压后的文件列表 * @throws IOException */static List&lt;File&gt; load(Context context, ApplicationInfo applicationInfo, File dexDir, boolean forceReload) throws IOException &#123; File sourceApk = new File(applicationInfo.sourceDir); long currentCrc = getZipCrc(sourceApk); List files; if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123; try &#123; //从缓存目录中直接查找缓存文件，跳过解压 files = loadExistingExtractions(context, sourceApk, dexDir); &#125; catch (IOException var9) &#123; files = performExtractions(sourceApk, dexDir); putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1); &#125; &#125; else &#123; //把apk中的secondary dex文件解压到缓存目录，并把解压后的文件返回 files = performExtractions(sourceApk, dexDir); //把解压信息保存到sharedPreferences中 putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1); &#125; return files;&#125; 首先判断以下是否需要强制从apk文件中解压，再进行下CRC校验，如果不需要从apk重新解压，就直接从缓存目录中读取已解压的文件返回，否则解压apk中的classes文件到缓存目录，再把相应的文件返回。这个方法再往下的分析就不贴出来了，不复杂，大家可以自己去看看。读取后会把解压信息保存到sharedPreferences中，里面会保存时间戳、CRC校验和dex数量。 得到dex文件列表后，要做的就是把dex文件关联到应用，这样应用findclass的时候才能成功。这个主要是通过installSecondaryDexes方法来完成的 1234567891011121314151617181920212223242526272829/** * 安装dex文件 * * @param loader 类加载器 * @param dexDir 缓存目录，用以存放opt之后的dex文件 * @param files 需要安装的dex * @throws IllegalArgumentException * @throws IllegalAccessException * @throws NoSuchFieldException * @throws InvocationTargetException * @throws NoSuchMethodException * @throws IOException */private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;File&gt; files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123; if (!files.isEmpty()) &#123; //对不同版本的SDK做不同处理 if (VERSION.SDK_INT &gt;= 19) &#123; MultiDex.V19.install(loader, files, dexDir); &#125; else if (VERSION.SDK_INT &gt;= 14) &#123; MultiDex.V14.install(loader, files, dexDir); &#125; else &#123; MultiDex.V4.install(loader, files); &#125; &#125;&#125; 可以看到，对于不同的SDK版本，分别采用了不同的处理方法，我们主要分析SDK&gt;=19的情况，其他情况大同小异，读者可以自己去分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static final class V19 &#123; private V19() &#123; &#125; /** * 安装dex文件 * * @param loader 类加载器 * @param additionalClassPathEntries 需要安装的dex * @param optimizedDirectory 缓存目录，用以存放opt之后的dex文件 * @throws IllegalArgumentException * @throws IllegalAccessException * @throws NoSuchFieldException * @throws InvocationTargetException * @throws NoSuchMethodException */ private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123; //通过反射获取ClassLoader对象中的pathList属性，其实是ClassLoader的父类BaseDexClassLoader中的成员 Field pathListField = MultiDex.findField(loader, "pathList"); //通过属性获取该属性的值，该属性的类型是DexPathList Object dexPathList = pathListField.get(loader); ArrayList suppressedExceptions = new ArrayList(); //通过反射调用dexPathList的makeDexElements返回Element对象数组。方法里面会读取每一个输入文件，生成DexFile对象，并将其封装进Element对象 Object[] elements = makeDexElements(dexPathList, new ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions); //将elements数组跟dexPathList对象的dexElements数组合并，并把合并后的数组作为dexPathList新的值 MultiDex.expandFieldArray(dexPathList, "dexElements", elements); //处理异常 if (suppressedExceptions.size() &gt; 0) &#123; Iterator suppressedExceptionsField = suppressedExceptions.iterator(); while (suppressedExceptionsField.hasNext()) &#123; IOException dexElementsSuppressedExceptions = (IOException) suppressedExceptionsField.next(); Log.w("MultiDex", "Exception in makeDexElement", dexElementsSuppressedExceptions); &#125; Field suppressedExceptionsField1 = MultiDex.findField(loader, "dexElementsSuppressedExceptions"); IOException[] dexElementsSuppressedExceptions1 = (IOException[]) ((IOException[]) suppressedExceptionsField1.get(loader)); if (dexElementsSuppressedExceptions1 == null) &#123; dexElementsSuppressedExceptions1 = (IOException[]) suppressedExceptions.toArray(new IOException[suppressedExceptions .size()]); &#125; else &#123; IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions1.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions1, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions1.length); dexElementsSuppressedExceptions1 = combined; &#125; suppressedExceptionsField1.set(loader, dexElementsSuppressedExceptions1); &#125; &#125; private static Object[] makeDexElements(Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Method makeDexElements = MultiDex.findMethod(dexPathList, "makeDexElements", new Class[]&#123;ArrayList.class, File.class, ArrayList.class&#125;); return (Object[]) ((Object[]) makeDexElements.invoke(dexPathList, new Object[]&#123;files, optimizedDirectory, suppressedExceptions&#125;)); &#125;&#125; 在Android中，有两个ClassLoader，分别是DexPathList和PathClassLoader，它们的父类都是BaseDexClassLoader，DexPathList和PathClassLoader的实现都是在BaseDexClassLoader之中，而BaseDexClassLoader的实现又基本是通过调用DexPathList的方法完成的。DexPathList里面封装了加载dex文件为DexFile对象（调用了native方法，有兴趣的童鞋可以继续跟踪下去）的方法。上述代码中的逻辑如下： 通过反射获取pathList对象 通过pathList把输入的dex文件输出为elements数组，elements数组中的元素封装了DexFile对象 把新输出的elements数组合并到原pathList的dexElements数组中 异常处理 当把dex文件加载到pathList的dexElements数组之后，整个multidex.install基本上就完成了。但可能还有些童鞋还会有些疑问，仅仅只是把Element数组合并到ClassLoader就可以了吗？还是没有找到加载类的地方啊？那我们再继续看看，当用到一个类的时候，会用ClassLoader去加载一个类，加载类会调用类加载器的findClass方法 1234567891011121314@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); //调用pathList的findClass方法 Class c = pathList.findClass(name, suppressedExceptions); if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException("Didn't find class \"" + name + "\" on path: " + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c;&#125; 于是继续跟踪： 123456789101112131415161718public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; //遍历dexElements数组 for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; //继续跟踪会发现调用的是一个native方法 Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null;&#125; 到现在就清晰了，当加载一个类的时候，会遍历dexElements数组，通过native方法从Element元素中加载类名相应的类 总结到最后，总结整个multidex.install流程，其实很简单，就做了一件事情，把apk中的secondary dex文件通过ClassLoader转换成Element数组，并把输出的数组合与ClassLoader的Element数组合并。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MultiDex</tag>
        <tag>分包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI教程与技术手册]]></title>
    <url>%2F2016%2F10%2F13%2Fjava-native-interface-specification%2F</url>
    <content type="text"><![CDATA[概述对于JNI，有些童鞋在没有接触过的时候，可能会觉得比较复杂，但是其实当你真正去了解、去使用的时候，就会发现JNI的使用还是比较简单的，JNI本身提供了一系列的API让我们可以在native方法中操作java。JNI的使用无非也就是使用这些接口和java交互。这几天在学习JNI接口的时候，发现网上搜索的JNI的中文虽然不少，但是很多都是零零碎碎的小例子，有一些官方文档的翻译，但要么是不全面，要么是资料比较旧了，干脆自己根据java native interface specification整理了一份技术资料。当然，很多时候看中文资料是词不达意的，如果文中有疑问的地方欢迎指出，或者翻阅原文 首先，JNI是一个本地编程接口。它允许运行在Java虚拟机的Java代码与用其他语言（如C,C++和汇编）编写的库交互JNI最大的好处是JNI不受Java虚拟机实现方式的限制，因此，Java虚拟机厂商添加JNI的支持并不会影响虚拟机其它功能模块。native代码只需要编写一遍，就可以在所有支持JNI的虚拟机上工作。 通过JNI，你可以在native代码中： 创建、检查或者更新java对象 调用java方法 捕捉和抛出异常 加载class和获取class信息 运行时类型检查 JNI接口函数和指针本地代码通过JNI函数（接口指针，接口指针是指针的指针）来访问java VM。 JNI接口指针只在当前线程有效，因此在native方法中不要跨线程传递接口指针参数。native方法接收JNI接口指针参数，VM确保在同一个线程中调用native方法的时候，传递同一个接口指针给接口指针给native方法。然而，native方法可能在Java中的不同线程中调用，所以native方法接收到的接口指针可能是不一样的。 编译、加载和链接本地方法编译Java VM是多线程的 ，所以native libraries应该用多线程编译器来进行编译和链接。例如使用Sun Studio compiler编译器的时候，要为c++代码添加-mt标记；使用 GNU gcc compiler的时候，需添加-D_REENTRANT 或-D_POSIX_C_SOURCE 加载native库通过System.loadLibrary方法进行加载。如： 12345678910package pkg; class Cls &#123; native double f(int i, String s); static &#123; System.loadLibrary("pkg_Cls"); &#125; &#125; 系统会对library名会进行转换，在不同平台上有不同的转换方式，例如，Solaris系统转换pkg_Cls为libpkg_Cls.so，而Win32系统转换pkg_Cls为pkg_Cls.dll 链接如果系统不支持动态链接，那么所有本地方法需要预链接到虚拟机，这种情况下，VM已经完成System.loadLibrary了。程序员也可以调用JNI函数RegisterNatives()来注册该类关联的本地方法 Native Method命名解析一个本地方法名有以下几个组成部分： 前缀Java_ 完整类名（类名中的.用_代替） 下划线_ 方法名（方法名中的特殊字符需要转义） 参数签名（非必须，有重载方法的时候才需要），如果有重载的本地方法，需要再添加两个下划线__，然后再添加方法签名（由java字段描述符描述，用_代替描述符中的包名分割/符，签名中的特殊字符需要转义） Unicode 转义字符 转义符 说明 _0XXXX 一个Unicode字符XXXX。注意小写是用来表示非ascii Unicode字符, 如:_0abcd与_0ABCD不相同 _1 字符_ _2 参数签名中的字符; _3 参数签名中的字符[ java字段描述符 Java 类型 符号 Boolean Z Byte B Char C Short S Int I Long J Float F Double D Void V 数组 [ , 如：int[]-&gt; [I, int[][]-&gt; [[I, Thread[]-&gt; [Ljava/lang/Thread; objects 以”L”开头，以”;”结尾，中间是用”/“ 隔开的包及类名。比如：Ljava/lang/String;如果是嵌套类，则用$来表示嵌套。例如 “(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z“ 举例123456789package pkg; class Cls &#123; //对应本地方法名：Java_pkg_Cls_f__ILjava_lang_String_2 native double f(int i, String s); ... &#125; Native方法参数 JNI接口指针是native方法的第一个参数，JNI接口指针的类型是JNIEnv。 第二个参数取决于native method是否静态方法，如果是非静态方法，那么第二个参数是对对象的引用，如果是静态方法，则第二个参数是对它的class类的引用 剩下的参数跟Java方法参数一一对应 123456789package pkg; class Cls &#123; native double f(int i, String s); ... &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//注意，c和c++在使用JNI接口的时候有点不一致，请仔细观察通过env调用接口的调用方式//C版本jdouble Java_pkg_Cls_f__ILjava_lang_String_2 ( JNIEnv *env, /* interface pointer */ jobject obj, /* "this" pointer */ jint i, /* argument #1 */ jstring s) /* argument #2 */&#123; /* Obtain a C-copy of the Java string */ const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0); /* process the string */ ... /* Now we are done with str */ (*env)-&gt;ReleaseStringUTFChars(env, s, str); return ...&#125;//C++版本extern "C" /* specify the C calling convention */ jdouble Java_pkg_Cls_f__ILjava_lang_String_2 ( JNIEnv *env, /* interface pointer */ jobject obj, /* "this" pointer */ jint i, /* argument #1 */ jstring s) /* argument #2 */ &#123; const char *str = env-&gt;GetStringUTFChars(s, 0); ... env-&gt;ReleaseStringUTFChars(s, str); return ... &#125; java对象引用 基本类型（如整型，字符等）在Java和native之间是采用值传递 Java对象采用的是引用传递 虚拟机必须保持已传递给native的对象的引用，以使这些对象不被垃圾回收器回收。native code也必须有一种方法通知虚拟机它不再需要某个对象，并且垃圾收集器必须能够将其回收 全局引用、局部引用和弱全局引用JNI中使用的引用可以划分为三类：全局引用、局部引用和弱全局引用。局部引用在方法调用的时候有效，在方法调用结束之后会自动释放。全局引用会一直可用，直到显式地对其进行释放。弱全局引用跟全局引用的区别是弱全局引用持有的java对象可以被VM进行回收，所以才使用弱全局引用前，我们需要对其进行检测，看它对应的对象是否被回收了。 对象是作为局部引用传递给native方法的，所有通过JNIEnv方法（也就是JNI提供的API）返回的java对象都是局部引用。JNI允许程序从局部引用创建一个全局引用。JNIEnv的方法既可以接收全局引用也可以接收局部引用。一个native方法既可以返回局部引用也可以返回全局引用。 大多数情况下，在方法调用结束之后，我们依赖VM去帮我们释放所有局部引用，但是以下几种情况下，我们应该显式地释放局部引用： 方法中创建了一个比较大的java对象的，并持有其局部引用，使用完之后，如果接下来都不再需要使用了，如果仍然不对它进行释放的话，在方法结束之前，这个对象都不会进行释放，这样会对资源造成浪费 JNI会将创建的局部引用都存储在一个局部引用表中，如果这个表超过了最大容量限制，就会造成局部引用表溢出，使程序崩溃。比如在一个循环中创建局部引用，最好在每一轮循环中释放局部引用，否则随着循环次数增加，很可能就内存溢出了 局部引用仅仅在其创建的线程内有效，native代码不能跨线程传递局部引用。 访问字段和方法JNI允许native代码访问对象的成员以及调用它的方法，通过两个步骤即可实现访问，比如，我们需要调用cls中的f方法： 12jmethodID mid = env-&gt;GetMethodID(cls, "f", "(ILjava/lang/String;)D");//mid可以重复使用jdouble result = env-&gt;CallDoubleMethod(obj, mid, 10, str); 但是需要注意的是，字段ID或方法ID并不能防止VM卸载该类。当类被卸载后，方法ID和字段ID将变成不可用的。因此，我们需要确保： 持有class的引用，让它不被卸载，或者 重新获取方法id或者字段id 程序错误检测JNI不对空指针或非法参数类型等错误进行检测，因为： 检查所有可能的错误会降低方法执行的性能 在很多时候，没有足够的运行时信息去进行检测 程序员不得传递一个非法指针或者错误的类型给JNI函数，否则可能会导致系统异常货虚拟机崩溃 Java异常JNI允许本地方法抛出处理任何异常，也可以处理Java中抛出的异常，剩下没有处理的异常会继续给VM处理 异常和错误码大多数情况下，JNI提供的方法通过返回错误码或者抛出java异常来处理错误，因此，程序中可以： 检查JNI函数返回值 调用ExceptionOccurred()方法，获取方法中抛出的异常 有两种情况下，程序需要优先检测java异常而不是先检测返回码 通过JNI调用Java方法的时候，需要ExceptionOccurred()检测是否在Java方法中抛出了异常 一些访问数组的方法，它不返回错误码，但是会抛出ArrayIndexOutOfBoundsException 或者 ArrayStoreException异常 异常处理有两种方法可以在本地方法中处理异常 检测到异常的时候立即返回，异常将会在调用该本地代码的地方抛出 在本地方法中调用ExceptionClear()清除异常，处理接下来的逻辑 异常抛出的时，本地方法需清除异常后，才能继续调用其他JNI接口方法，有异常发生后，只有以下方法才能被安全调用： 123456789101112131415ExceptionOccurred()ExceptionDescribe()ExceptionClear()ExceptionCheck()ReleaseStringChars()ReleaseStringUTFChars()ReleaseStringCritical()Release&lt;Type&gt;ArrayElements()ReleasePrimitiveArrayCritical()DeleteLocalRef()DeleteGlobalRef()DeleteWeakGlobalRef()MonitorExit()PushLocalFrame()PopLocalFrame() 原始类型 Java 类型 native类型 描述 boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar unsigned 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void N/A JNI中还定义了以下两个宏定义方便使用： 12#define JNI_FALSE 0 #define JNI_TRUE 1 引用类型JNI为不同的java对象提供了不同的引用类型，JNI引用类型如下：在c里面，所有JNI引用类型其实都是jobject 字段和方法ID在C中，字段和方法ID是一个指向结构体的指针 12345struct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */ 值类型值类型jvalue是一个联合体结构，定义如下： 1234567891011typedef union jvalue &#123; jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;&#125; jvalue; 签名类型描述请参考：java字段描述符如： 12//方法签名为：(ILjava/lang/String;[I)J long f (int n, String s, int[] arr); UTF-8字符JNI的 UTF-8与标准的 UTF-8格式有两个区别： 空字符(char)0使用双字节格式编码，而不是单字节编码，所以Java虚拟机的UTF-8字符串不可能有嵌入的空值。 只使用单字节、双字节和三字节编码格式，不支持标准的四字节编码，用two-times-three-byte格式代替 JNI接口函数在下面的说明中，必须说明JNI函数必须接受一个非空对象，你必须保证传入的参数不为空，JNI函数不需要再对它进行空指针判断 返回码说明1234567#define JNI_OK (0) /* no error */#define JNI_ERR (-1) /* generic error */#define JNI_EDETACHED (-2) /* thread detached from the VM */#define JNI_EVERSION (-3) /* JNI version error */#define JNI_COMMIT 1 /* copy content, do not free buffer */#define JNI_ABORT 2 /* free buffer w/o copying back */ 接口详细12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118/** * 返回本地方法接口的版本 * * @param env JNI接口指针 * * @return 高16位返回主版本号，低16位返回次版本号,如在JDK/JRE 1.6中，返回0x00010006。也有可能返回 JNI_EDETACHED 和 JNI_EVERSION 错误码 */jint (*GetVersion)(JNIEnv *);/** * 从二进制的.class的数据缓冲区中加载类 * * @param env JNI接口指针 * @param name UTF8编码的需要加载的类的名字 * @param loader 类加载器 * @param buf 包含.class字节码的数组 * @param bufLen 长度 * * @return class对象或NULL * * @throws ClassFormatError 不是有效的class数据 * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口 * @throws OutOfMemoryError 内存不足 * @throws SecurityException 如果该类是属于java包的 */jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize);/** * 用于加载本地定义的类 * * @param env JNI接口指针 * @param name 完整的包名("/"代替".") 或 数组类型字段描述("["开头，紧跟签名描述)，如"java/lang/String" for java.lang.String, "[Ljava/lang/Object;" for java.lang.Object[] * * @return class对象或NULL * * @throws ClassFormatError 不是有效的class数据 * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口 * @throws OutOfMemoryError 内存不足 * @throws NoClassDefFoundError 找不到name对应的class类 */jclass (*FindClass)(JNIEnv *, const char *);/** * 从java.lang.reflect.Method 或 java.lang.reflect.Constructor 获取method ID * * @param env JNI接口指针 * @param method java.lang.reflect.Method 或 java.lang.reflect.Constructor对象 * * @return 方法ID */jmethodID (*FromReflectedMethod)(JNIEnv *, jobject);/** * 从java.lang.reflect.Field获取field ID * * @param env JNI接口指针 * @param field java.lang.reflect.Field对象 * * @return field ID */jfieldID (*FromReflectedField)(JNIEnv *, jobject);/** * 从method ID获取 java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象 * * @param env JNI接口指针 * @param cls 该方法的类对象 * @param methodID 方法ID * @param isStatic 是否静态方法 * * @return java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象 * * @throws OutOfMemoryError 内存不足 */jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean);/** * 如果clazz不是class对象或接口，则返回该class的超类 * * @param env JNI接口指针 * @param clazz class对象 * * @return 返回输入类的父类 或 NULL */jclass (*GetSuperclass)(JNIEnv *, jclass);/** * class1是否可以安全地转换为class2，以下三种情况会返回TRUE * 1. 当class1和class2是同一个java class的引用 * 2. class1是class2的子类 * 3. class2是class1的某个接口 * * @param env JNI接口指针 * @param clazz1 class1 * @param clazz2 class2 * * @return JNI_TRUE or JNI_FALSE */jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass);/** * 根据 field ID 获取 java.lang.reflect.Field 对象 * * @param env JNI接口指针 * @param cls 该方法的类对象 * @param fieldID 字段ID * @param isStatic 是否静态变量 * * @return java.lang.reflect.Field 对象 * * @throws OutOfMemoryError 内存不足 */jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean);/** * 抛出异常 * * @param env JNI接口指针 * @param obj java.lang.Throwable 对象 * * @return 0：成功， 负数：失败 * * @throws Throwable */jint (*Throw)(JNIEnv *, jthrowable);/** * 根据clazz和message构造一个异常对象，并将它抛出 * * @param env JNI接口指针 * @param clazz java.lang.Throwable的子类 * @param message 错误信息 * * @return 0：成功， 负数：失败 * * @throws Throwable */jint (*ThrowNew)(JNIEnv *, jclass, const char *);/** * 判断是否有异常抛出，在调用ExceptionClear()或java代码处理了exception之前，都可以用这个方法判断是否有异常 * * @param env JNI接口指针 * * @return 异常对象 or NULL */jthrowable (*ExceptionOccurred)(JNIEnv *);/** * 打印异常信息 * * @param env JNI接口指针 */void (*ExceptionDescribe)(JNIEnv *);/** * 清除所有已抛出的异常 * * @param env JNI接口指针 */void (*ExceptionClear)(JNIEnv *);/** * 抛出致命错误并且不希望虚拟机进行恢复。无返回值 * * @param env JNI接口指针 * @param msg 错误信息 */void (*FatalError)(JNIEnv *, const char *);/** * 创建一个新的本地引用帧 * * @param env JNI接口指针 * @param capacity 容量 * * @return 0：成功，负数：失败 * * @throws OutOfMemoryError */jint (*PushLocalFrame)(JNIEnv *, jint);/** * 弹出当前本地引用帧，释放所有本地引用 * * @param env JNI接口指针 * @param result * * @return */jobject (*PopLocalFrame)(JNIEnv *, jobject);/** * 为传入的obj创建全局引用，obj可以是全局引用也可以是局部引用。全局引用需要调用DeleteGlobalRef来释放 * * @param env JNI接口指针 * @param obj 全局或局部引用 * * @return 全局引用 or NULL(内存不足) */jobject (*NewGlobalRef)(JNIEnv *, jobject);/** * 释放全局引用 * * @param env JNI接口指针 * @param globalRef 全局引用 */void (*DeleteGlobalRef)(JNIEnv *, jobject);/** * 释放局部引用 * * @param env JNI接口指针 * @param localRef 局部引用 */void (*DeleteLocalRef)(JNIEnv *, jobject);/** * 判断两个引用是否同一java对象的引用 * * @param env JNI接口指针 * @param ref1 引用1 * @param ref2 引用2 * * @return JNI_TRUE:两个引用指向同一个java对象 */jboolean (*IsSameObject)(JNIEnv *, jobject, jobject);/** * 为传入的ref创建局部引用，ref可以是全局引用也可以是局部引用 * * @param env JNI接口指针 * @param ref 全局或局部引用 * * @return 局部引用 or NULL */jobject (*NewLocalRef)(JNIEnv *, jobject);/** * 确保当前线程可以创建capacity个局部引用。在进入本地方法时，VM确保可以可以创建最少16个局部引用 * * @param env JNI接口指针 * @param capacity 局部引用个数 * * @return 0：成功，负数：失败 * * @throws OutOfMemoryError 内存不足 */jint (*EnsureLocalCapacity)(JNIEnv *, jint);/** * 创建一个新的java对象（不会调用对象的构造方法） * * @param env JNI接口指针 * @param clazz 非数组class对象 * * @return java对象 * * @throws InstantiationException clazz是一个接口或抽象类 * @throws OutOfMemoryError 内存不足 */jobject (*AllocObject)(JNIEnv *, jclass);/** * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得 * * @param env JNI接口指针 * @param clazz 非数组class对象 * @param ... 传递给构造方法的参数 * * @return java对象 or NULL(对象构造失败) * * @throws InstantiationException clazz是一个接口或抽象类 * @throws OutOfMemoryError 内存不足 */jobject (*NewObject)(JNIEnv *, jclass, jmethodID, ...);/** * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得 * * @param env JNI接口指针 * @param clazz 非数组class对象 * @param args va_list结构，里面有传递给构造方法的参数 * * @return java对象 or NULL(对象构造失败) * * @throws InstantiationException clazz是一个接口或抽象类 * @throws OutOfMemoryError 内存不足 */jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list);/** * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得 * * @param env JNI接口指针 * @param clazz 非数组class对象 * @param args 参数数组，里面是传递给构造方法的参数 * * @return java对象 or NULL(对象构造失败) * * @throws InstantiationException clazz是一个接口或抽象类 * @throws OutOfMemoryError 内存不足 */jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, jvalue *);/** * 返回对象对应的class对象 * * @param env JNI接口指针 * @param obj 非空java对象 * * @return class对象 */jclass (*GetObjectClass)(JNIEnv *, jobject);/** * 判断obj是否clazz的实例对象 * * @param env JNI接口指针 * @param obj java对象 * @param clazz class对象 * * @return */jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass);/** * 返回非静态方法的method ID * * @param env JNI接口指针 * @param clazz class对象 * @param name 方法名 * @param sig 方法签名 * * @return 方法ID or NULL * * @throws NoSuchMethodError 找不到对应的方法 * @throws ExceptionInInitializerError class初始化失败 * @throws OutOfMemoryError 内存不足 */jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *);/** * Call&lt;type&gt;Method(JNIEnv *env, jobject obj, jmethodID methodID, ...);调用参数放到可变参数中 * Call&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组 * Call&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);调用参数放入va_list结构中 * * 以上三组调用接口都是根据 method ID调用java实例方法（非静态方法）的接口，其中method ID是通过GetMethodID()获取的 * 当这些方法用于调用java对象的私有方法或构造函数时，method ID必须从obj的真实类获取，而不应从其某个父类获取 * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同 * * * @param env JNI接口指针 * @param obj java对象 * @param methodID 方法ID * @param args 调用参数 * * @return java方法返回结果 * * @throws java方法中可能抛出的异常 */jobject (*CallObjectMethod)(JNIEnv *, jobject, jmethodID, ...);jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list);jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jboolean (*CallBooleanMethod)(JNIEnv *, jobject, jmethodID, ...);jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list);jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jbyte (*CallByteMethod)(JNIEnv *, jobject, jmethodID, ...);jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list);jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jchar (*CallCharMethod)(JNIEnv *, jobject, jmethodID, ...);jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list);jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jshort (*CallShortMethod)(JNIEnv *, jobject, jmethodID, ...);jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list);jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jint (*CallIntMethod)(JNIEnv *, jobject, jmethodID, ...);jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list);jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jlong (*CallLongMethod)(JNIEnv *, jobject, jmethodID, ...);jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list);jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jfloat (*CallFloatMethod)(JNIEnv *, jobject, jmethodID, ...);jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list);jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);jdouble (*CallDoubleMethod)(JNIEnv *, jobject, jmethodID, ...);jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list);jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);void (*CallVoidMethod)(JNIEnv *, jobject, jmethodID, ...);void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list);void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);/** * CallNonvirtual&lt;type&gt;Method(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中 * CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组 * CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中 * * 以上三组调用接口都是根据 method ID 和 class 调用java实例方法（非静态方法）的接口，其中method ID是基于clazz通过GetMethodID()获取的 * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同 * 注意，和Call&lt;type&gt;Method不同，如果子类重写了父类的方法，Call&lt;type&gt;Method调用的是子类的方法，如果想调用父类的方法， * 则需要用CallNonvirtual&lt;type&gt;Method，这个方法可以传入父类的class和父类的method id，从而达到调用父类方法的效果 * * * @param env JNI接口指针 * @param clazz class对象 * @param obj java对象 * @param methodID 方法ID * @param args 调用参数 * * @return java方法返回结果 * * @throws java方法中可能抛出的异常 */jobject (*CallNonvirtualObjectMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jboolean (*CallNonvirtualBooleanMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jbyte (*CallNonvirtualByteMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jchar (*CallNonvirtualCharMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jshort (*CallNonvirtualShortMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jint (*CallNonvirtualIntMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jlong (*CallNonvirtualLongMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jfloat (*CallNonvirtualFloatMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);jdouble (*CallNonvirtualDoubleMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);void (*CallNonvirtualVoidMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);/** * 根据class对象获取非静态成员变量的field ID * * @param env JNI接口指针 * @param clazz class对象 * @param name 变量名 * @param sig 变量签名 * * @return field ID or NULL * * @throws NoSuchFieldError 找不到对应的变量ID * @throws ExceptionInInitializerError class初始化失败 * @throws OutOfMemoryError 内存不足 */jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *);/** * 根据field id取出对象中相应的变量值，field Id通过GetFieldID()获取 * * @param env JNI接口指针 * @param obj java对象 * @param fieldID 有效的field id * * @return 相应的变量值 */jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID);jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID);jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID);jchar (*GetCharField)(JNIEnv *, jobject, jfieldID);jshort (*GetShortField)(JNIEnv *, jobject, jfieldID);jint (*GetIntField)(JNIEnv *, jobject, jfieldID);jlong (*GetLongField)(JNIEnv *, jobject, jfieldID);jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID);jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID);/** * 根据field id为相应的变量设置新的值，field Id通过GetFieldID()获取 * * @param env JNI接口指针 * @param obj java对象 * @param fieldID 有效的field id * @param value 要设置的值 */void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject);void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean);void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte);void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar);void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort);void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint);void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong);void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat);void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble);/** * 返回静态方法的method ID * * @param env JNI接口指针 * @param clazz class对象 * @param name 方法名 * @param sig 方法签名 * * @return 方法ID or NULL * * @throws NoSuchMethodError 找不到对应的方法 * @throws ExceptionInInitializerError class初始化失败 * @throws OutOfMemoryError 内存不足 */jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *);/** * CallStatic&lt;type&gt;Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中 * CallStatic&lt;type&gt;MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组 * CallStatic&lt;type&gt;MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中 * * 以上三组调用接口都是根据 method ID调用java静态方法的接口，其中method ID是通过GetStaticMethodID()获取的 * method ID必须从clazz的真实类获取，而不应从其某个父类获取 * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同 * * * @param env JNI接口指针 * @param clazz class对象 * @param methodID 方法ID * @param args 调用参数 * * @return java方法返回结果 * * @throws java方法中可能抛出的异常 */jobject (*CallStaticObjectMethod)(JNIEnv *, jclass, jmethodID, ...);jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list);jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jboolean (*CallStaticBooleanMethod)(JNIEnv *, jclass, jmethodID, ...);jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list);jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jbyte (*CallStaticByteMethod)(JNIEnv *, jclass, jmethodID, ...);jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list);jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jchar (*CallStaticCharMethod)(JNIEnv *, jclass, jmethodID, ...);jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list);jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jshort (*CallStaticShortMethod)(JNIEnv *, jclass, jmethodID, ...);jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list);jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jint (*CallStaticIntMethod)(JNIEnv *, jclass, jmethodID, ...);jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list);jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jlong (*CallStaticLongMethod)(JNIEnv *, jclass, jmethodID, ...);jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list);jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jfloat (*CallStaticFloatMethod)(JNIEnv *, jclass, jmethodID, ...);jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list);jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);jdouble (*CallStaticDoubleMethod)(JNIEnv *, jclass, jmethodID, ...);jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list);jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);void (*CallStaticVoidMethod)(JNIEnv *, jclass, jmethodID, ...);void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list);void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);/** * 根据class对象获取静态成员变量的field ID * * @param env JNI接口指针 * @param clazz class对象 * @param name 变量名 * @param sig 变量签名 * * @return field ID or NULL * * @throws NoSuchFieldError 找不到对应的变量ID * @throws ExceptionInInitializerError class初始化失败 * @throws OutOfMemoryError 内存不足 */jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *);/** * 根据field id取出对象中相应的变量值，field Id通过GetStaticFieldID()获取 * * @param env JNI接口指针 * @param clazz class对象 * @param fieldID 有效的field id * * @return 相应的静态变量值 */jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID);jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID);jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID);jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID);jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID);jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID);jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID);jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID);jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID);/** * 根据field id为相应的静态变量设置新的值，field Id通过GetStaticFieldID()获取 * * @param env JNI接口指针 * @param clazz class对象 * @param fieldID 有效的field id * @param value 要设置的值 */void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject);void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean);void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte);void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar);void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort);void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint);void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong);void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat);void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble);/** * 创建一个新的java.lang.String对象 * * @param env JNI接口指针 * @param unicodeChars 指向Unicode字符串的指针 * @param len Unicode字符串的长度 * * @return String对象 or NULL * * @throws OutOfMemoryError 内存不足 */jstring (*NewString)(JNIEnv *, const jchar *, jsize);/** * 返回java.lang.String的长度（Unicode字符数） * * @param env JNI接口指针 * @param string String对象 * * @return 长度 */jsize (*GetStringLength)(JNIEnv *, jstring);/** * 返回指向Unicode字符数组的指针 * 该指针在调用ReleaseStringchars()前一直有效 * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE * * @param env JNI接口指针 * @param string String对象 * @param isCopy 指向boolean的指针 * * @return 指向字符串的指针 or NULL */const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *);/** * 通知VM无需再访问chars * chars是一个指针，通过GetStringChars() * * @param env JNI接口指针 * @param string String对象 * @param chars 指向字符串的指针 */void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *);/** * 根据UTF-8编码的字符数组创建一个新的java.lang.String对象 * * @param env JNI接口指针 * @param bytes 指向UTF-8字符串的指针 * * @return String对象 or NULL * * @throws OutOfMemoryError 内存不足 */jstring (*NewStringUTF)(JNIEnv *, const char *);/** * 返回字符串以UTF-8为编码的字节数 * * @param env JNI接口指针 * @param string String对象 * * @return 字符串的UTF-8字节数 */jsize (*GetStringUTFLength)(JNIEnv *, jstring);/** * 返回指向UTF-8编码字符数组的指针 * 该指针在调用ReleaseStringUTFChars()前一直有效 * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE * * @param env JNI接口指针 * @param string String对象 * @param isCopy 指向boolean的指针 * * @return 指向字符串的指针 or NULL */const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *);/** * 通知VM无需再访问utf * utf是一个指针，通过GetStringUTFChars() * * @param env JNI接口指针 * @param string String对象 * @param utf 指向字符串的指针 */void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *);/** * 获取数组元素个数 * * @param env JNI接口指针 * @param array java数组对象 * * @return 数组长度 */jsize (*GetArrayLength)(JNIEnv *, jarray);/** * 创建新的elementClass类型数组，所有元素初始值均设为initialElement * * @param env JNI接口指针 * @param length 数组大小 * @param elementClass 数组类型 * @param initialElement 初始值 * * @return 数组对象 or NULL */jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject);/** * 获取对象数组中指定index的值 * * @param env JNI接口指针 * @param array java数组 * @param index 索引 * * @return 索引对象的对象 * * @throws ArrayIndexOutOfBoundsException */jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize);/** * 设置对象数组中指定index的值 * * @param env JNI接口指针 * @param array java数组 * @param index 索引 * @param value 新的值 * * @throws ArrayIndexOutOfBoundsException */void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject);/** * ArrayType New&lt;PrimitiveType&gt;Array(JNIEnv *env, jsize length); * 创建基本类型数组对象 * * @param env JNI接口指针 * @param length 数组大小 * * @return 数组对象 or NULL */jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize);jbyteArray (*NewByteArray)(JNIEnv *, jsize);jcharArray (*NewCharArray)(JNIEnv *, jsize);jshortArray (*NewShortArray)(JNIEnv *, jsize);jintArray (*NewIntArray)(JNIEnv *, jsize);jlongArray (*NewLongArray)(JNIEnv *, jsize);jfloatArray (*NewFloatArray)(JNIEnv *, jsize);jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize);/** * NativeType *Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy); * 返回基本类型数组中的数据，通过返回的指针可以访问这些数据，若虚拟机支持pinning，则指针指向原始数组，否则指向原始数组的拷贝 * 返回的指针在Release&lt;PrimitiveType&gt;ArrayElements()调用前一直有效 * 数组用使用结束后，调用Release&lt;PrimitiveType&gt;ArrayElements，并在调用参数中决定是否把修改提交给java * * @param env JNI接口指针 * @param array java数组 * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE * * @return 指向数组元素的指针 or NULL */jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *);jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *);jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *);jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *);jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *);jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *);jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *);jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *);/** * Release&lt;PrimitiveType&gt;ArrayElements * 通知VM不再需要访问这些数组，根据mode参数的不同，将决定是否把数组的修改复制到源数组 * * @param env JNI接口指针 * @param array java数组对象 * @param elems 指向数组元素的指针 * @param mode 释放模式，0：把数据复制回源数组并释放elems缓冲区，JNI_COMMIT：把数据复制回源数组但不释放elems缓冲区，JNI_ABORT：不把数据复制回源数组，释放elems缓冲区 */void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint);void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint);void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint);void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint);void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint);void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint);void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint);void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint);/** * void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf); * 把基本类型数组拷贝到buf中 * * @param env JNI接口指针 * @param array java数组 * @param start 开始index * @param len 拷贝长度 * @param buf 目标地址 * * @throws ArrayIndexOutOfBoundsException */void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *);void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *);void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *);void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *);void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *);void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *);void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *);void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *);/** * void Set&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, const NativeType *buf); * 把buf中的内容拷贝回数组中 * * @param env JNI接口指针 * @param array java数组 * @param start 开始index * @param len 拷贝长度 * @param buf 源数据 * * @throws ArrayIndexOutOfBoundsException */void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *);void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *);void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *);void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *);void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *);void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *);void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *);void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *);/** * 为clazz类注册本地方法 * * @param env JNI接口指针 * @param clazz class对象 * @param methods clazz类中的本地方法，指向方法数组 * @param nMethods 本地方法个数 * * @return 0：成功， 负数：失败 * * @throws NoSuchMethodError */jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint);/** * 取消clazz类本地方法的注册 * * @param env JNI接口指针 * @param clazz class对象 * * @return 0：成功， 负数：失败 */jint (*UnregisterNatives)(JNIEnv *, jclass);/** * 进入与obj所引用的Java对象相关联的监控，obj 必须为非空 * * @param env JNI接口指针 * @param obj java对象 或 class对象 * * @return 0：成功， 负数：失败 */jint (*MonitorEnter)(JNIEnv *, jobject);/** * 退出与obj所引用的Java对象相关联的监控，obj 必须为非空 * 当前线程必须是与obj所引用的Java对象相关联的监控程序的所有者 * 监控程序次数的计数器减 1。如果计数器的值变为 0，则释放当前线程的监控程序 * * @param env JNI接口指针 * @param obj java对象 或 class对象 * * @return 0：成功， 负数：失败 */jint (*MonitorExit)(JNIEnv *, jobject);/** * 获取当前线程关联的Java VM接口 * * @param env JNI接口指针 * @param vm java VM接口指针 * * @return 0：成功， 负数：失败 */jint (*GetJavaVM)(JNIEnv *, JavaVM **);/** * 从start index开始，拷贝len个Unicode字符到buf * * @param env JNI接口指针 * @param str string对象 * @param start 开始index * @param len 拷贝长度 * @param buf 目标地址 * * @throws StringIndexOutOfBoundsException */void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *);/** * 从start index开始，取出len个Unicode字符转换为UTF-8编码后拷贝到buf * * @param env JNI接口指针 * @param str string对象 * @param start 开始index * @param len 拷贝长度 * @param buf 目标地址 * * @throws StringIndexOutOfBoundsException */void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *);/** * 与Get/Release&lt;primitivetype&gt;ArrayElements方法非常相似，在这个方法中VM尽量返回指向原始数组的指针 * * @since JDK/JRE 1.2 * * @param env JNI接口指针 * @param array java数组 * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE * * @return 指向数组元素的指针 or NULL */void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *);void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint);/** * 与Get/ReleaseStringChars方法非常相似，在这个方法中VM尽量返回指向原始字符串的指针 * * @since JDK/JRE 1.2 * * @param env JNI接口指针 * @param string String对象 * @param isCopy 指向boolean的指针 * * @return 指向字符串的指针 or NULL */const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *);void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *);/** * 为传入的obj创建弱全局引用 * 弱全局引用不会阻止VM释放所引用的对象，程序中可以通过使用IsSameObject比较弱全局引用和NULL来确认所引用的对象是否被释放 * * @param env JNI接口指针 * @param obj 全局或局部引用 * * @return 弱全局引用 or NULL */jweak (*NewWeakGlobalRef)(JNIEnv *, jobject);/** * 删除弱全局引用 * * @param env JNI接口指针 * @param obj 弱全局引用 */void (*DeleteWeakGlobalRef)(JNIEnv *, jweak);/** * 判断是否有未处理异常 * * @param env JNI接口指针 * * @return JNI_TRUE表示有未处理异常，否则为JNI_FALSE */jboolean (*ExceptionCheck)(JNIEnv *);/** * 创建并返回java.nio.ByteBuffer对象，该对象引用以address为开始地址，大小为capacity的内存块 * * @since JDK/JRE 1.4 * * @param env JNI接口指针 * @param address 开始地址 * @param capacity 内存大小 * * @return Jjava.nio.ByteBuffer or NULL * * @throws OutOfMemoryError */jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong);/** * 根据java.nio.ByteBuffer对象，获取相应的内存数据并返回开始地址 * * @since JDK/JRE 1.4 * * @param env JNI接口指针 * @param buf java.nio.ByteBuffer对象 * * @return 数据的开始地址 or NULL */void *(*GetDirectBufferAddress)(JNIEnv *, jobject);/** * 根据java.nio.ByteBuffer对象，获取相应的内存数据的大小 * * @since JDK/JRE 1.4 * * @param env JNI接口指针 * @param buf java.nio.ByteBuffer对象 * * @return 数据大小 or -1 */jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject);/** * 获取java对象的引用类型，可能的返回值有： * JNIInvalidRefType * JNILocalRefType：局部引用 * JNIGlobalRefType：全局引用 * JNIWeakGlobalRefType ：全局弱若引用 * * @since JDK/JRE 1.6 * * @param env JNI接口指针 * @param obj java对象的引用 * * @return 引用类型 */jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jni</tag>
        <tag>java native interface specification</tag>
        <tag>ndk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 2.2 NDK开发环境搭建]]></title>
    <url>%2F2016%2F10%2F09%2FAndroid-Studio-2.2-NDK%2F</url>
    <content type="text"><![CDATA[Android应用程序使用NDK的意义在这里就不说了，本文主要讲解如何在Android Studio 2.2下如何一步步搭建NDK开发环境。 下载NDK和工具Android Studio2.2开始推荐开发者使用CMake去构建本地代码，在构建之前，我们需先安装下面三个依赖： NDK: a set of tools that allows you to use C and C++ code with Android. CMake: an external build tool that works alongside Gradle to build your native library. You do not need this component if you only plan to use ndk-build. LLDB: the debugger Android Studio uses to debug native code. 我们可以使用SDK Manager进行下载，菜单位置：Tools &gt; Android &gt; SDK Manager，勾选后安装即可 创建或者导入native项目创建工程在这里要注意勾选这个Include C++ Support 接下来一路next最后finish，工程就创建好了。创建好之后系统默认生成了个demo。在Android Studio2.2下，目录结构发生了变化 所有c/c++文件都应放置在src/main/cpp/目录（以前是在jni目录） 配置build.gradle123456789101112131415161718192021222324252627282930android &#123; ... defaultConfig &#123; ... externalNativeBuild &#123; cmake &#123; //设置编译工具链 arguments "-DANDROID_TOOLCHAIN=clang" //需编译生成的ABI类型 abiFilters 'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'arm64-v8a' &#125; &#125; ndk &#123; //打包进APK的ABI类型 abiFilters "armeabi", "armeabi-v7a", "x86" &#125; &#125; externalNativeBuild &#123; cmake &#123; //配置CMakeLists.txt的路径 path 'CMakeLists.txt' &#125; &#125; ...&#125; 配置之后，我们就会发现工程终于变成这种结构了，其中cpp里面的是源文件，External Build Files是CMakeLists文件。 当然，想要正常编译，我们还需要学习CMake文件，这里推荐一篇文章：CMake 入门实战]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio NDK</tag>
        <tag>NDK开发</tag>
        <tag>JNI</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProGuard代码混淆详细攻略]]></title>
    <url>%2F2016%2F09%2F15%2Fproguard%2F</url>
    <content type="text"><![CDATA[ProGuard简介和工作流程ProGuard能够通过压缩、优化、混淆、预检等操作，检测并删除未使用的类,字段,方法和属性，分析和优化字节码，使用简短无意义的名称来重命名类，字段和方法。从而使代码更小、更高效、更难进行逆向工程。 上图就是ProGuard的工作流程，分别会经过四个阶段： 压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性 优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令 混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名 预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检 以上四个步骤都是可选的，我们可以通过配置脚本来决定其中的哪几个步骤。比如我们可以配置只压缩和混淆，不进行优化，不进行预检。ProGuard的官网有使用指导：http://proguard.sourceforge.net/ PrgGuard环境配置和使用运行PrgGuard需要以下依赖： proguard.jar或者proguardgui.jar。proguardgui提供了一个简单的配置界面（如下图），可以在上面进行配置，而progua.jar则是使用配置文件进行处理 Java运行环境 如何运行ProGuardProGuard可以通过命令行调用，如： java -jar proguardgui.jar：启动图形化配置界面 java -jar proguard.jar @config.file –options …：通过配置文件进行ProGuard处理 执行成功后，用jd-gui打开处理后的jar文件： 可以发现，类已经被混淆处理了。 PrgGuard配置文件使用Entry points的概念这里，我们引入Entry points的概念。Entry points是在ProGuard过程中不会处理的类或者方法。在Shrink的步骤中，ProGuard会递归遍历，搜索使用了哪些类和成员，对于没有使用的类和类成员，就会在压缩阶段丢弃。接下来在Optimize阶段，那些非Entry points的类、方法都会被设置为private、static或者final，没有使用的参数会被移除，此外，有些方法会被标记为内联。在Obfuscate的步骤中，ProGuard会对非Entry points的类和方法进行重命名。 会用到的指令参数说明Modifier Includedescriptorclasses：一般用于保证native方法名，确保方法的参数类型不会重命名，确保方法签名不会被改变，这样才能跟native libraries相匹配。 Allowshrinking：允许压缩 Allowoptimization：允许优化 Allowobfuscation：允许混淆名称 Class SpecificationsClass Specifications是用来描述类和方法的模板，下面是这个模板的格式： 其中，[]中的内容是可选，名称可以使用通配符，匹配构造函数、匹配成员、匹配方法，详细请参考：http://proguard.sourceforge.net/manual/usage.html#keepoptionmodifiers 基本指令-basedirectory directoryname：在配置文件中出现的相对路径均是相对于该路径，如图： -injars class_path指定处理的jar包（或者aars, wars, ears, zips, apks, directories）等，这个jar包里面的类将会被ProGuard处理并写入到输出的jar包里去。一般非class文件会不做任何处理直接直接复制到输出文件中，injars可以多次使用，引入不同的需要处理的文件。注意，该选项可以指定一个目录，那么该目录下所有文件都会被当作input file处理。 -outjars class_path设置处理完成后的输出文件路径 -libraryjars class_path指定要处理应用程序的jar(或者aars, wars, ears, zips, apks, directories)，这些文件不会包含到输出文件中。一般是指被处理文件所依赖的一些jar包，而那些jar包是不需要被处理以及写入到输出文件的。比如： -skipnonpubliclibraryclasses忽略library里面非public修饰的类。从而加快ProGuard的处理速度和降低ProGuard的使用内存。一般而言，library里的非公开类是不能被程序使用的，忽略掉这些类可以加快混淆速度。但是请注意，有一种特殊情况：有些人编写的代码与类库中的类在同一个包下，而且对该包的非public类进行了使用，在这种情况下，就不能使用该选项了。 –dontskipnonpubliclibraryclasses不忽略library里面非public修饰的类 -dontskipnonpubliclibraryclassmembers指定不忽略非public类里面的成员和方法。ProGuard默认会忽略类库里非public类里的成员和方法，但是由于一些3.2.5里面的一些原因，应用程序里可能会用到这些，这时候就需要这个选项来指定不忽略它们。 -keepdirectories [directory_filter]指定要保留在输出文件内的目录。默认情况下，目录会被移除。这会减少输出文件的大小，但如果你的代码引用到它们时可能会导致程序崩溃（如mypackage.MyCalss.class.getResource(“”)）。这时就需要指定-keepdirectories mypackage。-keepdirectories mydirectory匹配 mydirectory 目录；-keepdirectories mydirectory/匹配 mydirectory 的直接子目录；-keepdirectorie mydirectory/*匹配所有子目录，如果没有指定过滤器，所有目录会被保留。 -target version指定被处理class文件所使用的java版本，可选的有: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5 (or just 5), 1.6 (or just 6), 1.7 (or just 7), or 1.8 (or just 8). -forceprocessing强制输出，即使输出文件已经是最新状态 -keep [,modifier,…] class_specification指定该类以及类的成员和方法为entry points，不被ProGuard混淆 -keepclassmembers [,modifier,…] class_specification指定类的某些成员不被混淆，注意类名还是会被混淆，如： -keepclasseswithmembers [,modifier,…] class_specification通过成员来指定哪些类不被混淆处理。比如可以用来保留包含main方法的类： 如果指定了多条规则，如下，那么必须同时包含sayHello和test两个方法的类才会被保留 -keepnames class_specification-keepclassmembers,allowshrinking class_specification的别名，保留名称不被混淆，但可以被压缩 -keepclassmembernames class_specification-keepclasseswithmembers,allowshrinking class_specification的别名，保留名称不被混淆，但可以被压缩 -keepclasseswithmembernames class_specification-keepclasseswithmembers,allowshrinking class_specification的别名 -printseeds [filename]把keep匹配的类和方法输出到文件中，可以用来验证自己设定的规则是否生效. -dontshrink指定不进行压缩. -printusage [filename]把没有使用的代码输出到文件中，方便查看哪些代码被压缩丢弃了。. -dontoptimize指定不对输入代码进行优化处理。优化选项是默认打开的。 -optimizations指定混淆是采用的算法，后面的参数是一个过滤器，这个过滤器是谷歌推荐的算法，一般不做更改 -optimizationpasses n指定优化的级别，在0-7之间，默认为5. -assumenosideeffects class_specification可以指定移除哪些方法没有副作用，如在android开发中，如想在release版本可以把所有log输出都移除，可以配置： 那么所有log代码将会在优化阶段被去除。 –dontobfuscate指定不进行混淆 -printmapping [filename]生成map文件，记录混淆前后的名称对应关系，注意，这个比较重要，因为混淆后运行的名称会变得不可读，只有依靠这个map文件来还原。 -applymapping filename主要是用来维持两次混淆公用一份mapping，确保相同的代码前后两次混淆后是一样的命名 -obfuscationdictionary filename指定外部模糊字典 -classobfuscationdictionary filename指定class模糊字典. -packageobfuscationdictionary filename指定package模糊字典 –useuniqueclassmembernames类和成员混淆的时候，使用唯一的名字 -dontusemixedcaseclassnames不使用大小写混合类名，注意，windows用户必须为ProGuard指定该选项，因为windows对文件的大小写是不敏感的，也就是比如a.java和A.java会认为是同一个文件。如果不这样做并且你的项目中有超过26个类的话，那么ProGuard就会默认混用大小写文件名，导致class文件相互覆盖。 -keeppackagenames [package_filter]保持packagename 不混淆 -flattenpackagehierarchy [package_name]指定重新打包,所有包重命名,这个选项会进一步模糊包名，将包里的类混淆成n个再重新打包到一个个的package中 -repackageclasses [package_name]将包里的类混淆成n个再重新打包到一个统一的package中，会覆盖flattenpackagehierarchy选项 -keepattributes [attribute_filter]混淆时可能被移除下面这些东西，如果想保留，需要用该选项，对于一般注解处理如 -keepattributes Annotation。 attribute_filter : Exceptions, Signature, Deprecated, SourceFile, SourceDir, LineNumberTable, LocalVariableTable, LocalVariableTypeTable, Synthetic, #EnclosingMethod, RuntimeVisibleAnnotations, RuntimeInvisibleAnnotations, RuntimeVisibleParameterAnnotations, RuntimeInvisibleParameterAnnotations, AnnotationDefault. -dontpreverify指定不执行预检 -verbose把所有信息都输出，而不仅仅是输出出错信息 -dontnote [class_filter]不输出指定类的错误信息. -dontwarn [class_filter]不打印指定类的警告信息 -ignorewarnings遇到警告的时候，忽略警告继续执行ProGuard，不建议添加此项。 -printconfiguration [filename]输出当前ProGuard所使用的配置 -dump [filename]指定输出所处理的类的结构 反射的处理在代码中，如果用到了反射，混淆会改变类和成员的名字，导致反射找不到相应的类或者方法，所以开发者在混淆的时候，必须把用到了反射的类保留，不进行混淆。一般而言，使用反射一般会有以下方式，可以搜索代码，找到相关的类，然后在混淆配置里面进行保留： Class.forName(“SomeClass”) SomeClass.class SomeClass.class.getField(“someField”) SomeClass.class.getDeclaredField(“someField”) SomeClass.class.getMethod(“someMethod”, new Class[] {}) SomeClass.class.getMethod(“someMethod”, new Class[] { A.class }) SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class }) SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {}) SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class }) SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class }) AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”) AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”) AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”) 12# reflectClass类使用了反射，保留该类-keep class package.reflectClass &#123; *; &#125; PrgGuard的基本使用demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5#指定混淆是采用的算法，后面的参数是一个过滤器，这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/*#混合时不使用大小写混合，混合后的类名为小写,windows下必须使用该选项-dontusemixedcaseclassnames#指定不去忽略非公共库的类和成员-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers#输出详细信息-verbose#输出类名-&gt;混淆后类名的映射关系-printmapping map.txt#不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify#保留Annotation不混淆-keepattributes *Annotation*,InnerClasses#避免混淆泛型-keepattributes Signature#抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable#保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;#保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; 另外，由于Android平台在使用混淆的时候，还要特别注意要添加以下一些配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#保留我们使用的四大组件，自定义的Application等等这些类不被混淆-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService#保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125;#保留R下面的资源-keep class **.R$* &#123;*;&#125;#保留在Activity中的方法参数是view的方法，-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;#保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;#对于带有回调函数的onXXEvent的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event);&#125;#在我们的app中使用了webView需要进行特殊处理-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;# 在app中与HTML5的JavaScript的交互进行特殊处理，如# package com.ljd.example;## public class JSInterface &#123;# @JavascriptInterface# public void callAndroidMethod()&#123;# // do something# &#125;# &#125;#我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理-keepclassmembers class com.ljd.example.JSInterface &#123; &lt;methods&gt;;&#125;#内嵌类经常被混淆，结果在调用的时候就崩溃了，如果需要保留内嵌类，则用以下方法来保留内嵌类，如暴力MyClass里面的内嵌类，$就是用来分割内嵌类和母体的标志-keep class com.test.MyClass$* &#123;*;&#125;#-----------以下处理反射类---------------]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>java代码混淆</tag>
        <tag>PrgGuard</tag>
        <tag>Android混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua和C交互的简易教程]]></title>
    <url>%2F2016%2F09%2F07%2Flua-and-c%2F</url>
    <content type="text"><![CDATA[Lua栈要理解Lua和C++交互，首先要理解Lua堆栈。简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出 在Lua中，Lua堆栈就是一个struct，堆栈索引的方式可是是正数也可以是负数，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶,如图： 入栈的数据类型包括数值, 字符串, 指针, talbe, 闭包等, 下面是一个栈的例子: 执行下面的代码就可以让你的lua栈上呈现图中的情况: 1234567891011// 创建并压入一个闭包lua_pushcclosure(L, func, 0);// 新建并压入一个表lua_createtable(L, 0, 0);// 压入一个数字lua_pushnumber(L, 100);// 压入一个字符串lua_pushstring(L, "hello，lua"); 这里要说明的是, 你压入的类型有数值, 字符串, 表和闭包[在c中看来是不同类型的值], 但是最后都是统一用TValue这种数据结构来保存的,下面用图简单的说明一下这种数据结构: TValue结构对应于lua中的所有数据类型, 是一个{值, 类型} 结构,这就lua中动态类型的实现, 它把值和类型绑在一起, 用tt记录value的类型, value是一个联合结构, 由Value定义, 可以看到这个联合有四个域, 先说明简单的 p – 可以存一个指针, 实际上是lua中的light userdata结构 n – 所有的数值存在这里, 不过是int , 还是float b – Boolean值存在这里, 注意, lua_pushinteger不是存在这里, 而是存在n中, b只存布尔 gc – 其他诸如table, thread, closure,string需要内存管理垃圾回收的类型都存在这里,gc是一个指针, 它可以指向的类型由联合体GCObject定义, 从图中可以看出, 有string, userdata, closure, table, proto, upvalue, thread 可以的得出如下结论: lua中, number, boolean, nil, light userdata四种类型的值是直接存在栈上元素里的, 和垃圾回收无关. lua中, string, table, closure, userdata, thread存在栈上元素里的只是指针, 他们都会在生命周期结束后被垃圾回收. 堆栈的操作因为Lua与C/C++是通过栈来通信，我们先来看一个最简单的例子: 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include "../lua/lauxlib.h"int main(int argc, const char *argv[]) &#123; //1.创建一个state lua_State *L = luaL_newstate(); //2.入栈操作 lua_pushstring(L, "I am so cool~"); lua_pushnumber(L, 20); //3.取值操作 if (lua_isstring(L, 1)) &#123; //这里的index也可以是-2 printf("[line:%d] lua_tostring(L, 1):%s\n", __LINE__, lua_tostring(L, 1)); &#125; if (lua_isnumber(L, 2)) &#123; //这里的index也可以是-1 printf("[line:%d] lua_tonumber(L, 2):%f\n", __LINE__, lua_tonumber(L, 2)); &#125; //4.关闭state lua_close(L); return 0;&#125; 其他一些栈操作： 1234567891011121314151617//返回栈顶索引（即栈长度） int lua_gettop (lua_State *L); //将栈顶设置为一个指定的位置，即修改栈中元素的数量。如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，则原栈高出的部分舍弃。所以可以用lua_settop(0)来清空栈void lua_settop (lua_State *L, int idx); //新增一个元素到栈顶，值与index位置的值相同void lua_pushvalue(lua_State *L, int idx);//移除idx索引上的值，高于index的元素的索引将全部-1 void lua_remove(lua_State *L, int idx); //把栈顶元素挪到index位置，原index位置的元素往栈顶移动void lua_insert(lua_State *L, int idx); //把栈顶元素挪到index位置，并删除原index位置的元素void lua_replace (lua_State *L, int idx); C调用Lua现在有这样一个hello.lua 文件： 123456str = "Hello, Lua !"table = &#123;name = "hans", id = 123456&#125;function add(x, y) return x + yend 我们写一个main.c来读取它： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include "../lua/lauxlib.h"lua_State *load_lua(char *filename) &#123; lua_State *L = luaL_newstate(); luaL_openlibs(L); //加载脚本并运行 if (luaL_loadfile(L, filename) || lua_pcall(L, 0, 0, 0)) &#123; printf("load Lua script failed: %s\n", lua_tostring(L, -1)); return NULL; &#125; return L;&#125;int main(int argc, const char *argv[]) &#123; char* lua_filename = "E:\\work\\luaJni\\resource\\test.lua"; lua_State *L = load_lua(lua_filename); if (NULL == L) &#123; return -1; &#125; //读取变量 lua_getglobal(L, "str"); printf("[line:%d] luaV_tostring(L, -1):%s\n", __LINE__, lua_tostring(L, -1)); //读取table lua_getglobal(L, "table"); lua_getfield(L, -1, "name"); printf("[line:%d] lua_tostring(L,-1);:%s\n", __LINE__, lua_tostring(L, -1)); //调用函数 lua_getglobal(L, "add"); //读取函数到栈顶 lua_pushnumber(L, 10); //压入参数 lua_pushnumber(L, 20); if (lua_pcall(L, 2, 1, 0) != 0) &#123; printf("lua_pcall failed: %s\n", lua_tostring(L, -1)); return -1; &#125; int result = lua_tonumber(L, -1); printf("[line:%d] result:%d\n", __LINE__, result); //至此，栈中的情况是： //=================== 栈顶 =================== // 索引 类型 值 // 4 int： 30 // 3 string： hans // 2 table: table // 1 string: Hello, Lua ! //=================== 栈底 =================== lua_close(L); return 0;&#125; 知道怎么读取后，我们来看下如何修改上面代码中table的值： 1234//将需要设置的值设置到栈中 lua_pushstring(L, "Hello，hahaha"); //将这个值设置到table中（此时table在栈的位置为2） lua_setfield(L, 2, "name"); 我们还可以新建一个table： 12345//创建一个新的table，并压入栈 lua_newtable(L); //往table中设置值 lua_pushstring(L, "hello, new table !"); //将值压入栈 lua_setfield(L, -2, "str"); //将值设置到table中，并将hello, new table !出栈 需要注意的是：栈操作是基于栈顶的，就是说它只会去操作栈顶的值。举个比较简单的例子，函数调用流程是先将函数入栈，参数入栈，然后用lua_pcall调用函数，此时栈顶为参数，栈底为函数，所以栈过程大致会是：参数出栈-&gt;保存参数-&gt;函数出栈-&gt;调用函数-&gt;返回结果入栈 类似的还有lua_setfield，设置一个表的值，肯定要先将值出栈，保存，再去找表的位置 Lua调用C我们可以加入我们自己的函数。函数要遵循规范（可在lua.h中查看）如下： 12//所有的函数必须接收一个lua_State作为参数，同时返回一个整数值。因为这个函数使用Lua栈作为参数，所以它可以从栈里面读取任意数量和任意类型的参数。而这个函数的返回值则表示函数返回时有多少返回值被压入Lua栈typedef int (*lua_CFunction) (lua_State *L); 123--lua_call_c.luaa, b = getTwoVar('hello, this string is from lua world', 123)print(a, b) 1234567891011121314151617181920212223242526/** * 定义在lua中可调用的函数，要遵循规范：返回值必须为int，需传入lua_State */int getTwoVar(lua_State *L) &#123; dumpStack(L); // =================== 栈顶 =================== // index type value // 2 number 123.000000 // 1 string hello, this string is from lua world // =================== 栈底 =================== lua_pushnumber(L, 10); lua_pushstring(L, "hello"); return 2;&#125;void lua_call_c() &#123; char* lua_filename = "E:\\work\\luaJni\\resource\\lua_call_c.lua"; lua_State *L = load_lua(lua_filename, FALSE); if (NULL == L) &#123; return; &#125; lua_register(L, "getTwoVar", getTwoVar); lua_pcall(L, 0, 0, 0);&#125; 还可以使用dll动态链接的方式，把c实现的代码打包成dllh文件如下： 1234567891011121314#pragma once extern "C" &#123; #include "lua.h" #include "lualib.h" #include "lauxlib.h" &#125; #ifdef LUA_EXPORTS #define LUA_API __declspec(dllexport) #else #define LUA_API __declspec(dllimport) #endif extern "C" LUA_API int luaopen_mLualib(lua_State *L);//定义导出函数 C文件如下： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include "mLualib.h" static int averageFunc(lua_State *L) &#123; int n = lua_gettop(L); double sum = 0; int i; /* 循环求参数之和 */ for (i = 1; i &lt;= n; i++) sum += lua_tonumber(L, i); lua_pushnumber(L, sum / n); //压入平均值 lua_pushnumber(L, sum); //压入和 return 2; //返回两个结果 &#125; static int sayHelloFunc(lua_State* L) &#123; printf("hello world!"); return 0; &#125; static const struct luaL_Reg myLib[] = &#123; &#123;"average", averageFunc&#125;, &#123;"sayHello", sayHelloFunc&#125;, &#123;NULL, NULL&#125; //数组中最后一对必须是&#123;NULL, NULL&#125;，用来表示结束 &#125;; int luaopen_mLualib(lua_State *L) &#123; luaL_register(L, "ss", myLib); return 1; // 把myLib表压入了栈中，所以就需要返回1 &#125; 在lua中我们这样子来调用（调用之前记得把dll文件复制到lua文件目录下）： 1234require "mylib" local ave,sum = ss.average(1,2,3,4,5) -- 参数对应堆栈中的数据 print(ave,sum) -- 3 15 ss.sayHello() -- hello world! 至此都发生了什么呢？梳理一下： 我们编写了averageFunc求平均值和sayHelloFunc函数 然后把函数封装myLib数组里面，类型必须是luaL_Reg 由luaopen_mLualib函数导出并在lua中注册这两个函数 实际上当我们在Lua中： 1require "mLualib" 这样子写的时候，Lua会这么干： 123local path = "mLualib.dll" local f = package.loadlib(path,"luaopen_mLualib") -- 返回luaopen_mLualib函数 f() 所以当我们在编写一个这样的模块的时候，编写luaopen_xxx导出函数的时候，xxx最好是和项目名一样 总结 Lua和C++是通过一个虚拟栈来交互的。 C调用Lua实际上是：由C先把数据放入栈中，由Lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回C Lua调C也一样：先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数 本文不涉及lua语法学习，如果有需要，请移步：http://book.luaer.cn/]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>lua和c交互</tag>
        <tag>lua和c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua快速入门]]></title>
    <url>%2F2016%2F08%2F30%2Flua-guide%2F</url>
    <content type="text"><![CDATA[什么是LuaLua 是一门强大、快速、轻量的嵌入式脚本语言。它由巴西里约热内卢 Pontifical Catholic 大学的 PUC-Rio 团队 开发。 Lua 是一个 自由软件， 广泛应用于世界上无数产品和项目 应用场景： 游戏开发 独立应用脚本 Web 应用脚本 扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench 安全系统，如入侵检测系统 基本语法注释 单行注释:两个减号是单行注释 多行注释： 123456-- 这是一个单行注释--[[ 多行注释 多行注释 --]] 标识符Lua表示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母、下划线、数字（0到9）。最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 W3c 与 w3c 是两个不同的标示符 关键字1234and break do else elseif endfalse for function goto if inlocal nil not or repeat returnthen true until while 数据类型 nil：只有值nil属于该类，表示一个无效值（在条件表达式中相当于false） boolean：包含两个值：false和true number：有两种内部表现方式，整数和浮点数。标准Lua使用 64 位整数和双精度（64位）浮点数 string：string表示一个不可变的字节序列，由一对双引号或单引号来表示 function：由C或Lua编写的函数 userdata：表示任意存储在变量中的C数据结构 thread：表示执行的独立线路，用于执行协同程序 table：Lua 中的表（table）其实是一个”关联数组”（associative arrays），这个数组不仅仅以数字做索引，除了nil和NaN之外的所有Lua值都可以做索引。 （Not a Number是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 0/0），也就是说，表内可以包含任何类型的值（ nil 除外）。任何键的值若为nil 就不会被记入表结构内部。table的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表 表、函数、线程、以及完全用户数据在 Lua 中被称为 对象： 变量并不真的持有 它们的值，而仅保存了对这些对象的引用。赋值、参数传递、函数返回，都是针对引用而不是针对值的操作 我们可以使用type函数测试给定变量或者值的类型： 1234567print(type("Hello world")) --&gt; stringprint(type(10.4*3)) --&gt; numberprint(type(print)) --&gt; functionprint(type(type)) --&gt; functionprint(type(true)) --&gt; booleanprint(type(nil)) --&gt; nilprint(type(type(X))) --&gt; string 变量变量类型Lua 变量有三种类型：全局变量、局部变量、表中的域。 除非用local显示声明为局部变量，否则Lua中的变量全是全局变量，哪怕是语句块或是函数里。局部变量的作用域为从声明位置开始到所在语句块结束。变量的默认值均为 nil。 应该尽可能的使用局部变量，有两个好处： 避免命名冲突 访问局部变量的速度比全局变量更快 12345678910111213141516171819-- test.lua 文件脚本a = 5 -- 全局变量local b = 5 -- 局部变量function joke() c = 5 -- 全局变量 local d = 6 -- 局部变量endjoke()print(c,d) --&gt; 5 nildo local a = 6 -- 局部变量 b = 6 -- 全局变量 print(a,b); --&gt; 6 6endprint(a,b) --&gt; 5 6 赋值语句赋值是改变一个变量的值和改变表域的最基本的方法 12a = "hello" .. "world" --字符串拼接t.n = t.n + 1 Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量 1a, b = 10, 2*x &lt;--&gt; a=10; b=2*x 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值: 12x, y = y, x -- swap 'x' for 'y'a[i], a[j] = a[j], a[i] -- swap 'a[i]' for 'a[j]' 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略: 变量个数 &gt; 值的个数: 按变量个数补足nil 变量个数 &lt; 值的个数: 多余的值会被忽略 12345678a, b, c = 0, 1print(a,b,c) --&gt; 0 1 nil a, b = a+1, b+1, b+2 -- value of b+2 is ignoredprint(a,b) --&gt; 1 2 a, b, c = 0print(a,b,c) --&gt; 0 nil nil 多值赋值经常用来交换变量，或将函数调用返回给变量: 1a, b = f() -- f()返回两个值，第一个赋给a，第二个赋给b 循环while基本语法： 123456789101112while(condition)do statementsend-- 举例a=10while( a &lt; 20 )do print("a 的值为:", a) a = a+1end for循环数值for循环：12345678910111213-- var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次"执行体"。exp3是可选的，如果不指定，默认为1for var=exp1,exp2,exp3 do &lt;执行体&gt; end --举例for i=1, f(5) do --f(x)只在循环开始前求值一次 print(i)end for i=10, 1, -1 do print(i)end 泛型for循环123for K, v in pairs/ipairs(table) do print(v) end 根据官方手册的描述，pairs会遍历表中所有的key-value值，而ipairs会根据key的数值从1开始加1递增遍历对应的table[i]值，直到table[i]的值是nil的时候就退出。 123456789101112131415161718192021stars = &#123;[1] = "Sun", [2] = "Moon", [5] = 'Earth'&#125;for i, v in pairs(stars) do print(i, v)end--[[输出：1 Sun2 Moon5 Earth --]] for i, v in ipairs(stars) do print(i, v)end--[[输出：1 Sun2 Moon因为stars[3]是nil --]] repeat…until 循环repeat…until 是条件后行,所以repeat…until 的循环体里面至少要运行一次基本语法： 123repeat statementswhile( condition ) 1234567--[ 变量定义 --]a = 10--[ 执行循环 --]repeat print("a的值为:", a) a = a + 1until( a &gt; 15 ) 输出结果 123456a的值为: 10a的值为: 11a的值为: 12a的值为: 13a的值为: 14a的值为: 15 流程控制基本语法： 1234567891011121314if( 布尔表达式 1)then --[ 在布尔表达式 1 为 true 时执行该语句块 --]elseif( 布尔表达式 2)then --[ 在布尔表达式 2 为 true 时执行该语句块 --]elseif( 布尔表达式 3)then --[ 在布尔表达式 3 为 true 时执行该语句块 --]else --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]end 函数基本使用在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。 Lua 函数主要有两种用途： 完成指定的任务，这种情况下函数作为调用语句使用 计算并返回值，这种情况下函数作为赋值语句的表达式使用 Lua 编程语言函数定义格式如下： 1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separatedend optional_function_scope:该参数是可选的制定函数是全局函数还是局部函数，未设置该参数末尾为全局函数，如果你需要设置函数为局部函数需要使用关键字 local function_name:函数名称 函数参数：多个参数以逗号隔开，函数也可以不带参数 函数返回值：Lua语言函数可以返回多个值，每个值以逗号隔开 Lua中，函数是first class，我们可以将函数作为参数传递给函数，如下实例： 123456789101112myprint = function(param) print("这是打印函数 - ##",param,"##")endfunction add(num1,num2,functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result)end-- myprint 函数作为参数传递add(2,5,myprint) 多返回值Lua函数中，在return后列出要返回的值得列表即可返回多值，如： 123456789101112131415function maximum (a) local mi = 1 -- 最大值索引 local m = a[mi] -- 最大值 for i,val in ipairs(a) do if val &gt; m then mi = i m = val end end return m, miendvalue, key = maximum(&#123;8,10,23,12,5&#125;)print(key) --输出3print(value) --输出23 可变参数Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（…)表示函数有可变的参数 Lua将函数的参数放在一个叫arg的表中，#arg 表示传入参数的个数。例如，我们计算几个数的平均值： 12345678910function average(...) result = 0 for i,v in ipairs(arg) do result = result + v end print("总共传入 " .. #arg .. " 个数") return result/#argendprint("平均值为: ",average(10,5,3,4,5,6)) 运算符算术运算符 关系运算符 逻辑运算符 其他运算符 运算符优先级12345678^not - (unary)* /+ -..&lt; &gt; &lt;= &gt;= ~= ==andor table不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表: 12345678910-- 创建一个空的 tablelocal tbl1 = &#123;&#125; -- 直接初始表local tbl2 = &#123;"apple", "pear", "orange", "grape"&#125;-- 初始化的时候设置key,注意，key不需要带引号，且初始化的时候不能以数字作为keylocal tbl2 = &#123;apple = "apple", pear = "pear", orange = "orange", grape = "grape"&#125;--可以通过table[i]、table['key']、table.key的方式访问数据 Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串: 12345678a = &#123;&#125;a["key"] = "value"key = 10a[key] = 22a[key] = a[key] + 11for k, v in pairs(a) do print(k .. " : " .. v)end]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>lua语法介绍</tag>
        <tag>lua入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android最大方法数和解决方案]]></title>
    <url>%2F2016%2F08%2F26%2FAndroid-64k-issue%2F</url>
    <content type="text"><![CDATA[什么是64K限制和LinearAlloc限制64K限制随着Android应用功能的增加，代码量不断地增大，当应用方法数量超过了65536的时候，编译的时候便会提示： 这个Android著名的Dex 64k method数量上限。那么，是什么原因导致方法数不能超过64K呢？网上搜集了一下资料，原因一般有： DexOpt优化的限制：当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。但是在早期的Android系统中，DexOpt有一个问题，也就是这篇文章想要说明并解决的问题。DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对老系统做兼容 dalvik bytecode的限制：因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能引用 65535 个方法，参考链接：http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160，http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html 鉴于以上原因，在打包Android应用的时候，会对方法数做一个检测，当方法数超过了DexFormat.MAX_MEMBER_IDX（定义为0Xffff, 注意，这个不是Dex文件格式的限制，Dex文件中存储方法ID用的并不是short类型，无论最新的DexFile.h新定义的u4是uint32_t，还是老版本DexFile引用的vm/Common.h里定义的u4是uint32或者unsigned int，都不是short类型，特此说明）便报错 LinearAlloc限制即使方法数没有超过65536，能正常编译打包成apk，在安装的时候，也有可能会提示INSTALL_FAILED_DEXOPT而导致安装失败，这个一般就是因为LinearAlloc的限制导致的。这个主要是因为Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃 谷歌分包方案谷歌提供了一个multiDex的分包方案，当方法数超过65536的时候，生成多个dex文件，把应用启动时必须用到的类和该类的直接引用类放到main dex中，把其他类放到second dex中。当应用启动之后，动态加载second dex，从而避免64k问题。使用Android Studio很容易实现分包方案： 在build.gradle中添加：multiDexEnabled true 加入依赖‘compile ‘com.android.support:multidex:1.0.1’’ 让应用的Application类直接使用或者继承MultiDexApplication 如果你想使用自定义的Application，又不想继承MultiDexApplication，那么可以在attachBaseContext方法里执行MultiDex.install(base) 以上就是谷歌multiDex方案所需做的设置，通过配置multiDex，便可解决64k方法数限制 谷歌multiDex存在的问题虽然谷歌的分包方案很简单，但是效果并不是那么好，谷歌本身也枚举了分包方案的缺点： 如果在主线程中执行MultiDex.install，加载second dex，因为加载从dex是同步的，会阻塞线程，second dex太大的话，有可能导致ANR API Level 14之前，由于Dalvik LinearAlloc bug（问题22586，就是上文提到的LinearAlloc问题），很可能会出问题的 应用程序使用了multiedex配置的，会造成使用比较大的内存 对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法 如何解决谷歌分包方案的问题针对上面的问题，参考网上的一些解决方案，如美团、facebook、微信等，初步使用的解决方法如下： 第一次启动的时候，检测到未曾加载过second dex，那么启动欢迎页面（启动新的进程，原来进程进入阻塞等待，注意，此时不会发生ANR，因为已经不是前台进程了），在欢迎页面里面进行second dex的加载，加载完成后通知主线程继续 设定单个dex文件最大方法数为48000（经验值）而不是65536，避免内存问题 同上 控制程序逻辑，未曾加载完second dex之前，进入阻塞等待，直到加载完程序才往下走 下面是流程图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>multidex</tag>
        <tag>最大方法数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile使用指南]]></title>
    <url>%2F2016%2F08%2F17%2Fmakefile%2F</url>
    <content type="text"><![CDATA[什么是MakefileMakefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，文件之间有哪些依赖等。Makefile有自己的书写格式、关键字、函数。像C 语言有自己的格式、关键字和函数一样。而且在Makefile中可以使用系统shell所提供的任何命令来完成想要的工作。Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率 makefile的文件名默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。 当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如： 12make -f Make.Linuxmake --file Make.AIX Makefile的规则显示规则12target ... : prerequisites ... command target：要生成的目标，也可以是一个标签 prerequisites：目标所依赖的列表 command：任意shell指令，一般用于生成target。必须以[Tab键]开头，也可以和prerequisites在一行，用分号做为分隔 这是一个文件的依赖关系，也就是说，target依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行(command一定要以Tab键开始，否则编译器无法识别command）。这就是Makefile的规则，也是Makefile中最核心的内容。 举个栗子： 1234567891011test : test1.o test2.o cc -o test test1.o test2.o test1.o : test1.c test1.h cc -c test1.c test2.o : test2.c test2.h cc -c test2.c clean : rm test test1.o test2.o 在这里，test是最终的目标，生成test，依赖于test1.o和test2.o也就是说，有以下情况发生时，会执行cc -o test test1.o test2.o指令，以重新生成target test不存在 test存在，但test1.o的修改时间比test新 test存在，但test2.o的修改时间比test新 把所有依赖关系都在makefile里列举出来之后，执行make命令的时候，就会根据依赖关系自动编译链接了 但是这里的clean又是干什么的呢？它并没有其他依赖，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字，比如make clean。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 隐晦规则每个.o文件的依赖文件默认会有同名的.c文件，比如有一个target是test.o，那么test.c默认就是test.O的依赖文件，这个是makefile的隐晦规则，是make会自动推导出来的 make是怎么工作的？在默认的方式下，也就是我们只输入make命令。那么： make会在当前目录下找名字叫“Makefile”或“makefile”的文件 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“test”这个文件，并把这个文件作为最终的目标文件 如果test文件不存在，或是test所依赖的后面的 .o 文件的文件修改时间要比test这个文件新，那么，他就会执行后面所定义的命令来生成test这个文件 如果test所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件 makefile中使用变量变量的基础为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，比如我们可以定义一个objects变量，并通过$(objects)的方式来使用这个变量。变量类似与C语言的宏定义，在执行的时候，变量的值会被扩展到被使用的地方 123456objects = test1.o test2.o test : $(objects) cc -o test $(objects)# --------------------------------------test : test1.o test2.o cc -o test test1.o test2.o 第一种写法和第二种写法的作用完全是一样的 变量中的变量在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。 先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如： 123456foo = $(bar)bar = $(ugh)ugh = Huh?all: echo $(foo) #我们执行“make all”将会打出变量$(foo)的值是“Huh?” 这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，不好的地方，那就是递归定义： 123A = $(B)B = $(A)#这会让make陷入无限的变量展开过程中去,当然，我们的make是有能力检测这样的定义，并会报错 为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符: 12345678x := fooy := $(x) barx := later#这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量,上下两种方式是等价的y := foo barx := later 追加变量值我们可以使用“+=”操作符给变量追加值，如： 12objects = main.o foo.o bar.o utils.oobjects += another.o 于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了） 如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如： 12variable := valuevariable += more 等价于： 12variable := valuevariable := $(variable) more 但如果是这种情况： 12variable = valuevariable += more 由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。 变量的高级用法变量值的替换我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符还是看一个示例吧： 123foo := a.o b.o c.obar := $(foo:.o=.c)# 把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，最终bar的值是a.c b.c c.c 另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如： 123foo := a.o b.o c.obar := $(foo:%.o=%.c)# 这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c” 把变量的值再当成变量1234x = yy = za := $($(x))# 在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z” 让make自动推导GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令。 只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂 清空目标文件的规则每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁，一般风格是： 123.PHONY : cleanclean : rm test $(objects) makefile注释Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，如： 12# 这是在makefile中的注释1# 这是在makefile中的注释2 引用其它的Makefile在Makefile使用include关键字可以把别的Makefile包含进来，make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： 123456include &lt;filename&gt;# 在include前面可以有一些空字符，但是绝不能是[Tab]键开始# filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）-include &lt;filename&gt;# 无论include过程中出现什么错误，都不要报错继续执行。上面那条指令若是找不到include的目标文件，会报错 伪目标最早先的一个例子中，我们提到过一个“clean”的目标。 12clean: rm *.o temp 伪目标不会自动被执行，只能显式地调用执行。但是上面伪目标的写法有一个缺陷，若是当前目录下存在有一个文件名为”clean”，那么根据我们的规则，command将不会被执行，因为目标已经存在了，为了解决这个问题，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标” 123.PHONY : cleanclean: rm *.o temp 通过.PHONY，无论是否存在“clean”文件，我们的command都将会被执行了 命令出错每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。 有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。 为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： 12clean: -rm -f *.o]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>makefile教程</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用keytool、openssl生成证书文件]]></title>
    <url>%2F2016%2F08%2F16%2Fkeytool-openssl-ca%2F</url>
    <content type="text"><![CDATA[用openssl指令逐步生成各个文件 生成服务器密钥：openssl genrsa -out server_private.key 2048 从密钥生成公钥（非必须）：openssl rsa -in server_private.key -pubout &gt; server_public.key 生成证书请求文件，这里会让你输入一堆信息，比如组织名称、个人信息等：openssl req -new -key server_private.key -out server_req.csr 初始化CA环境 123456mkdir demoCAcd demoCAmkdir certs crl newcertstouch index.txt serialecho 00 &gt; serialcd .. 生成ca密钥：openssl genrsa -out ca.key 2048 生成ca证书：openssl req -new -x509 -key ca.key -out ca.crt 用ca对服务器证书请求文件进行签名:openssl ca -in server_req.csr -out server.crt -cert ca.crt -keyfile ca.key -config /usr/ssl/openssl.cnf 可以把服务端的私钥和已签名的证书合并到一个pkcs12格式的文件：openssl pkcs12 -export -out server.pfx -inkey server_private.key -in server.crt 也可以把pkcs12格式转化为java常用的jks格式：keytool -importkeystore -v -srckeystore server.pfx -srcstoretype pkcs12 -srcstorepass 123456 -destkeystore server.jks -deststoretype jks -deststorepass 123456 用keytool生成keytool主要可以帮我们： 创建一个新的JKS(Java Key Store)文件（里面包含了一个新生成的服务器密钥） 导出一个CSR(Certificate Signung Request)证书申请文件 导入一个签名后的证书文件到jks文件中 以下是操作步骤： 生成新的jks文件：keytool -genkeypair -alias server -keyalg RSA -keystore server.jks 到出证书请求文件：keytool -certreq -alias server -file server.csr -keystore server.jks 用ca对请求文件进行签名（ca的生成请参考上面）：openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key -config demoCA/config/openssl.cnf 导入已签名的证书到jks：keytool -importcert -alias server -file server.crt -keystore server.jks 这样，我们就得到了一个包含了服务器密钥以及已签名证书的jks文件了 最终生成的文件最终服务端需要用到的文件有： 服务器私钥 经过CA签名的证书（包含服务器公钥、基本信息） 客户端需要用到的文件有： CA的证书（包含了CA的公钥，用以对服务器的证书解密，校验证书真伪） 有些服务器配置可以使用私钥+证书合并在一起的文件，如jks或者pkcs12文件，这类文件一般叫key.keystore。客户端使用的ca证书一般称为：truststore 遇到的问题openssl对证书签名的时候有可能报国家、组织、地区需一致的错误，是因为在openssl.cfg中的policy_match里面的前三个都选了match，可以修改optional，修改后就可以了]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>非对称加密</tag>
        <tag>keytool,rsa</tag>
        <tag>证书生成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用和介绍-基础指令]]></title>
    <url>%2F2016%2F08%2F15%2Fgit-guide-1%2F</url>
    <content type="text"><![CDATA[参考文档：Pro Git（中文版） git已经越来越常用了，但是很多用惯了svn的童鞋使用git的时候，一开始对git应该不太习惯，比如我~~，但是用习惯了之后，发现git还真是好用，哈哈。git的使用和介绍分为两篇，第一篇将一些基础的指令和概念，第二篇讲git分支。下面就整理了一些git常用的命令： 查看已有配置1git config --list 取消已有的配置1git config --global --unset user.name 设置用户名12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your_email@youremail.com&quot; 设置代理123git config --global http.sslverify falsegit config --global http.proxy http://192.168.0.24:808git config --global https.proxy http://192.168.0.24:808 文件状态了解git，首先要弄清楚对象在被git管理过程中所处的4个阶段，分别是：工作目录、index(又称为暂存区staged)、本地仓库和远程仓库。 未跟踪（untracked）：表示此文件尚未纳入版本控制管理（使用add指令可把文件添加到staged状态） 已修改（modified）：表示修改了某个文件，但还没有提交保存（使用add指令可把文件添加到staged状态） 已暂存（staged）：表示把已修改的文件放在下次提交时要保存的清单中（使用commit命令可把staged中的提交到本地代码仓库HEAD中） 已提交（committed）：表示该文件已经被安全地保存在本地数据库中了 要确定哪些文件当前处于什么状态，可以用 git status 命令 如何创建代码仓库有两种取得 Git 项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来 在工作目录中初始化新仓库：git init。初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中 从现有仓库克隆： git clone [url]。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字，如：git clone git://github.com/schacon/grit.git mygrit 忽略某些文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式 123*.[oa]*~#第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的是目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 查看已暂存和未暂存的更新 git diff：是查看working tree与暂存区index的差别的，也就是修改之后还没有暂存起来的变化内容 git diff –cached：查看已经暂存起来的文件(staged)和上次提交时的快照之间(HEAD)的差异。 git diff HEAD：显示工作版本(Working tree)和HEAD的差别 提交更新在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit。另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新，如： 1git commit -m &quot;Story 182: Fix benchmarks for speed&quot; 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 123456789101112$ git status # On branch master # # Changes not staged for commit: # # modified: benchmarks.rb #$ git commit -a -m &apos;added new benchmarks&apos; [master 83e38c7] added new benchmarks 1 files changed, 5 insertions(+), 0 deletions(-) # 看到了吗？提交之前不再需要 git add 文件 benchmarks.rb 了,直接被提交了 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了 12345678git rm grit.gemspec# 注意，执行git rm会把working index的文件也一起删除，如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。git rm -f grit.gemspec# 即使grit.gemspec文件有修改，也会强行删除文件git rm --cached grit.gemspec# 不会删除working index中的文件 移动文件1git mv file_from file_to 其实，运行 git mv 就相当于运行了下面三条命令： 123$ mv README.txt README$ git rm README.txt$ git add README 查看提交历史123git loggit log -p -2# 我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 撤消操作任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果 修改最后一次提交12git commit --amend# 把此次commit提交到上一个快照当中，若要增减文件，就先把修改提交到stage区域后再执行git commit --amend。此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样 取消已经暂存的文件12git reset HEAD benchmarks.rb# add的反操作 取消对文件的修改12345git checkout -- benchmarks.rb# 相当于svn的revert，从index恢复到workinggit checkout HEAD -- benchmarks.rb# 相当于svn的revert，从HEAD恢复到index和working。working和index的内容都将被恢复为HEAD 远程仓库的使用查看当前的远程库要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库 123git remotegit remote -v# 也可以加上 -v 选项（译注：此为 --verbose 的简写，取首字母），显示对应的克隆地址 添加远程仓库要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]，以新增githuh仓库为栗子。shortname可以用来指代url 12345678echo &quot;# dd&quot; &gt;&gt; README.mdgit init #初始化所在目录为git目录git add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/shensky711/dd.git #origin为shortname， https://github.com/shensky711/dd.git是urlgit push -u origin master#把本地仓库推送到远程仓库 从远程仓库抓取数据此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟 123456git fetch [remote-name]# 并不会合并数据到当前工作分区git pull# git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;，git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并# 如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支 如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并 推送数据到远程仓库项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name] 12git push origin master# 把本地的 master 分支推送到 origin 服务器上 只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送 查看远程仓库信息1git remote show [remote-name] 远程仓库的删除和重命名12345git remote rename pb paul# 重命名git remote rm paul# 删除 打标签列出当前的tag列表12git tag# 显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重 新建标签创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可： 12git tag -a v1.4 -m &apos;my version 1.4&apos;# -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中 分享标签默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可 12345git push origin v1.5# 推送v1.5标签git push origin --tags# 推送所有标签]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git使用教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https安全在哪里，原理是什么？]]></title>
    <url>%2F2016%2F08%2F15%2Fwhy-https-safe%2F</url>
    <content type="text"><![CDATA[Https通信基本过程在通信过程中，https是如何保证通信的安全的？如何加密信息，如何防止中间人攻击？以下是客户端发起https请求的时候的流程： 流程解析如下： 客户端发送随机数client_random和支持的加密方式列表 服务器返回随机数server_random，选择的加密方式和证书（经过ca颁发，或者自签名的证书，该证书包含公钥） 客户端验证证书，使用证书中的公钥加密premaster secret发送给服务端 服务端使用私钥解密得到premaster secret 两端分别通过client_random，server_random和premaster secret生成master secret，用于对称加密后续通信内容 整个过程主要的作用是让双方安全地协商出一个key，这个key会用于对称加密中。第三方即使截取了所有的通信数据，也是无法获取到这个key的。既然第三方无法获取这个key，自然也对加密过的数据无可奈何了。大家看到这里可能一脸懵逼，可能会有以下疑问： 这个过程是如何保证key不会被中间人窃取呢？ 客户端/服务端如何确认对方就是“正确的人”，而不是其他中间人呢？ 什么是RSA非对称加密 在解答上面的问题之前，首先我们得先了解一些基本的知识： RSA非对称加密：RSA分为公钥和私钥，从私钥可以生成公钥，但是不能通过公钥生成私钥。公钥加密过的信息，只有私钥能解开，私钥加密的信息，只有公钥能解开 https如何保证key不会被中间人窃取在步骤（1）中，客户端的随机数client_random是完全可以被中间人窃取的，然后在步骤（2）中服务端返回的server_random也是完全可被中间人窃取的。关键是在步骤（3），客户端会把生成的premaster secret通过公钥进行加密，然后再发送给服务器，中间人当然也可以窃取加密后的premaster secret数据，但是中间人却不能解密出原始的premaster secret，这是为什么呢？因为公钥加密的数据，只有私钥能解开，而私钥是保存在服务端，不会外泄的！通过步骤1-4，服务器和客户端相互持有了client_random，server_random和premaster secret，而且只有客户端和服务端才有premaster secret，中间人是没有的。这时候通过前面三个key，生成master secret用于对称加密，确保通信安全。 为何最终使用对称加密，而不是全部通信都使用非对称加密呢？猜测是因为非对称加密效率和速度不如对称加密。而且对称加密的安全性并不是不高，对称加密的难点在于如何安全地交换key。 我一开始理解https的时候，遇到一个困惑：如果中间人从建立连接一开始就冒充服务器，转发客户端和服务端的所有数据，那么所有数据在中间人眼里应该都是透明的啊，中间人应该也能解密通信数据啊？是的，中间人确实是可以拿到所有数据，但是，中间人没有服务器的私钥！所以即使拿到了数据，也不能得到对称加密的key。其实说白了，一个https请求，不知会经过多少个中间人呢，所有路由转发都有可能是中间人，都有可能攻击你，但恰恰就是因为没有私钥而不能窃取数据，他们只能转发数据，但却不能解密数据。 如何确认对方就是“正确的人”，而不是其他中间人呢但是问题又来了，虽然通信内容不会被第三个人窃取了，但是我如何保证对方就是我想要找的人呢？比如我要访问www.baidu.com，确实有一个服务器给了我回复，但我怎么确定这个是真的“百度”给我的回复呢？万一我的请求被劫持了呢？ 这个就得依靠验证步骤（2）里的证书了。 什么是证书呢？数字证书就是一个人或者组织在网络世界中的身份证，其发证机关是证书管理机构(certificate authority,CA)，在这里CA是一个权威的机构，我们可以信任他，他信任的站点，我们也会认为是可信任的。个人电脑上无法对每一个网站都进行验证，因为这样几乎不可能，也不方便。在日常生活中，如果我们要验证一个人的身份，通常的做法是查看他的身份证。我们信任身份证颁发机构即政府机构的公信力，因此只要验证一个人的身份证不是伪造的，我们就相信这个人的身份和身份证上所描述的是一致的。 说到这里，又有同学可能要懵逼了，通俗点讲，就是所有网站都要去CA机构那里去登记，然后CA会发给那么网站一个“身份证”。但是我们如何验证一个人身份证的真伪呢？CA机构也会提供一个工具给我们，我们用那个工具就可以验证身份证的真伪。 网站身份证：网站证书，需要CA机构签发 真伪辨认工具：CA证书 那么，什么是CA颁发的“身份证”呢？ 服务端生成自己的证书请求文件（尚未被CA签名），里面包含了姓名、服务器私钥对应的公钥等信息 CA机构对该证书进行签名，也就是生成数字签名，注意，这个签名是用CA的私钥加密过的 把原始的证书和生成的数字签名合并在一起，形成证书 在https的步骤（2）的时候，服务器发给用户的证书就是这个签名过之后的证书，客户端收到证书后，会使用CA的公钥（这个是内置在浏览器的）对数字签名进行解密得出一个信息摘要，然后用哈希算法自己算出信息摘要，对比摘要，一致的话，证明该证书是CA机构颁发的。因为公钥只能解开私钥加密的数据，如果信息摘要是匹配的，那么证明该加密数据是由CA机构用私钥加密的，证书是可靠的。 到现在，我们终于可以愉快地确定对方的身份，愉快地通信了。主要是依赖一个CA公钥来判别对方证书的真伪。 但是会有同学问了，万一冒牌网站把正牌网站copy下来，转发给我了怎么办，转发的证书是由正牌网站copy的，肯定是真的，所以客户端可以验证通过的，那怎么办？确实是的，如果冒牌网站用正版网站的证书来忽悠客户端，那么客户端确实是会被“忽悠”过去的，但是不用担心，客户端是依靠证书上的公钥来生成premaster secret的，而公钥对应的私钥，冒牌网站是不可能拿得到的，也就不可能解密出正确的premaster secret，自然也无法正常和客户端正常沟通了。 现在很多android应用的服务端虽然采用的是https，但是却是没有经过ca机构认证的（因为要花钱），所以一般会自己给自己颁发数字证书（自己充当CA）。但国内很多开发者在android应用里面采用的做法是信任所有证书，这样是很不安全的，正确的做法应该是导入CA的证书，这样才能在拿到证书后，判断证书的真伪。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>rsa</tag>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MockWebServer使用指南]]></title>
    <url>%2F2016%2F07%2F12%2Fmock-web-server%2F</url>
    <content type="text"><![CDATA[MockWebServer介绍MockWebServer是square出品的跟随okhttp一起发布，用来Mock服务器行为的库。MockWebServer使用在单元测试中，专门用来测试http请求。其原理是启动了一个本地web server，监听了本地某个端口。所以在测试的时候，需要把请求的url替换为MockWebServer提供的地址，然后web server会handle请求，记录请求，根据预设的stubbing进行反馈。MockWebServer提供接口，让我们可以在发起请求之后，验证请求是否和预期的一样，比如验证header、path等等。 MockWebServer能帮我们做什么MockWebServer可以mock反馈，验证请求，以下是MockWebServer能帮我们做的事情: 可以设置http response，设置response的header、body、status code等 可以记录接收到的请求，获取请求的body、header、method、path、HTTP version（在单元测试中很有用） 可以模拟网速慢的网络环境 提供Dispatcher，让mockWebServer可以根据不同的请求进行不同的反馈 MockWebServer不能帮我们做什么MockWebServer是在单元测试中启动一个web server的，主要用于测试验证。并不能像tomcat、moco一样，独立运行一个web server服务。如果需要长期运行一个web server，请选用moco或者tomcat等来搭建一个web server MockWebServer环境配置Android Studio中使用MockWebServer很简单，只需要在build.gradle文件中加入依赖即可。如图： 添加依赖之后，点击sync,即可自动下载： MockWebServer一般步骤 为mock server设置response 客户端发起请求 用mockWebServer记录的请求进行验证 下面是一个使用的例子： MockWebServer使用方法添加预置的响应 预置的相应，会按照添加的顺序依次返回给客户端。可以给MockResponse设置header、状态码、body。 模拟网速慢的情况 设置这个MockResponse返回的时候，以低速率传输。 RecordedRequest的使用 按顺序从web server把接收到的request取出来，这是一个阻塞的方法，会一直等待到web server接收到了请求之后再返回。RecordedRequest可以帮助我们验证我们的请求客户端是否按预期生成了请求，可以验证的内容分别有： 请求method 请求path 请求header 请求body 请求HTTP version Dispatcher的使用有时候我们希望web server能根据我们的请求返回不同的response，dispatcher可以帮助我们做到这个，使用方法如下： 开发者也可以根据不同的设定（如method、header等）放回不同的响应。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>MockWebServer使用</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mockito使用指南 - 单元测试的正确姿势]]></title>
    <url>%2F2016%2F06%2F21%2Fmockito%2F</url>
    <content type="text"><![CDATA[mock和Mockito的关系在软件开发中提及”mock”，通常理解为模拟对象。 为什么需要模拟? 在我们一开始学编程时,我们所写的对象通常都是独立的，并不依赖其他的类，也不会操作别的类。但实际上，软件中是充满依赖关系的，比如我们会基于service类写操作类,而service类又是基于数据访问类(DAO)的，依次下去，形成复杂的依赖关系。 单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。 有些时候，我们代码所需要的依赖可能尚未开发完成，甚至还不存在，那如何让我们的开发进行下去呢？使用mock可以让开发进行下去，mock技术的目的和作用就是模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试与测试边界以外的对象隔离开。 我们可以自己编写自定义的Mock对象实现mock技术，但是编写自定义的Mock对象需要额外的编码工作，同时也可能引入错误。现在实现mock技术的优秀开源框架有很多，Mockito就是一个优秀的用于单元测试的mock框架。Mockito已经在github上开源，详细请点击：https://github.com/mockito/mockito 除了Mockito以外，还有一些类似的框架，比如： EasyMock：早期比较流行的MocK测试框架。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常 PowerMock：这个工具是在EasyMock和Mockito上扩展出来的，目的是为了解决EasyMock和Mockito不能解决的问题，比如对static, final, private方法均不能mock。其实测试架构设计良好的代码，一般并不需要这些功能，但如果是在已有项目上增加单元测试，老代码有问题且不能改时，就不得不使用这些功能了 JMockit：JMockit 是一个轻量级的mock框架是用以帮助开发人员编写测试程序的一组工具和API，该项目完全基于 Java 5 SE 的 java.lang.instrument 包开发，内部使用 ASM 库来修改Java的Bytecode Mockito已经被广泛应用，所以这里重点介绍Mockito。 Mockito使用举例这里我们直接通过一个代码来说明mockito对单元测试的帮助，代码有三个类，分别如下：Person类： 123456789101112131415161718public class Person &#123; private final int id; private final String name; public Person(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125;&#125; PersonDAO： 123456public interface PersonDao &#123; Person getPerson(int id); boolean update(Person person);&#125; PersonService： 123456789101112131415161718public class PersonService &#123; private final PersonDao personDao; public PersonService(PersonDao personDao) &#123; this.personDao = personDao; &#125; public boolean update(int id, String name) &#123; Person person = personDao.getPerson(id); if (person == null) &#123; return false; &#125; Person personUpdate = new Person(person.getId(), name); return personDao.update(personUpdate); &#125;&#125; 在这里，我们要进行测试的是PersonService类的update方法，我们发现，update方法依赖PersonDAO，在开发过程中，PersonDAO很可能尚未开发完成，所以我们测试PersonService的时候，所以该怎么测试update方法呢？连接口都还没实现，怎么知道返回的是true还是false？在这里，我们可以这样认为，单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。所以我们的做法是mock一个PersonDAO对象，至于实际环境中，PersonDAO行为是否能按照预期执行，比如update是否能成功，查询是否返回正确的数据，就跟PersonService没关系了。PersonService的单元测试只测试自己的逻辑是否有问题 下面编写测试代码： 1234567891011121314151617181920212223242526272829303132333435public class PersonServiceTest &#123; private PersonDao mockDao; private PersonService personService; @Before public void setUp() throws Exception &#123; //模拟PersonDao对象 mockDao = mock(PersonDao.class); when(mockDao.getPerson(1)).thenReturn(new Person(1, "Person1")); when(mockDao.update(isA(Person.class))).thenReturn(true); personService = new PersonService(mockDao); &#125; @Test public void testUpdate() throws Exception &#123; boolean result = personService.update(1, "new name"); assertTrue("must true", result); //验证是否执行过一次getPerson(1) verify(mockDao, times(1)).getPerson(eq(1)); //验证是否执行过一次update verify(mockDao, times(1)).update(isA(Person.class)); &#125; @Test public void testUpdateNotFind() throws Exception &#123; boolean result = personService.update(2, "new name"); assertFalse("must true", result); //验证是否执行过一次getPerson(1) verify(mockDao, times(1)).getPerson(eq(1)); //验证是否执行过一次update verify(mockDao, never()).update(isA(Person.class)); &#125;&#125; 我们对PersonDAO进行mock，并且设置stubbing，stubbing设置如下： 当getPerson方法传入1的时候，返回一个Person对象，否则默认返回空 当调update方法的时候，返回true 我们验证了两种情况： 更新id为1的Person的名字，预期：能在DAO中找到Person并更新成功 更新id为2的Person的名字，预期：不能在DAO中找到Person，更新失败 这样，根据PersonService的update方法的逻辑，通过这两个test case之后，我们认为代码是没有问题的。mockito在这里扮演了一个为我们模拟DAO对象，并且帮助我们验证行为（比如验证是否调用了getPerson方法及update方法）的角色 Android Studio工程配置MockitoAndroid Studio中使用Mockito非常简单，只需要在build.gradle文件中加入依赖即可。如图： 12345dependencies &#123; ... testCompile 'org.mockito:mockito-core:1.10.19' ...&#125; Mockito使用方法Mockito的使用，有详细的api文档，具体可以查看：http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html，下面是整理的一些常用的使用方式。 验证行为 一旦创建，mock会记录所有交互，你可以验证所有你想要验证的东西 1234567891011121314151617@Testpublic void testVerify() throws Exception &#123; //mock creation List mockedList = mock(List.class); //using mock object mockedList.add("one"); mockedList.add("two"); mockedList.add("two"); mockedList.clear(); //verification verify(mockedList).add("one");//验证是否调用过一次 mockedList.add("one")方法，若不是（0次或者大于一次），测试将不通过 verify(mockedList, times(2)).add("two"); //验证调用过2次 mockedList.add("two")方法，若不是，测试将不通过 verify(mockedList).clear();//验证是否调用过一次 mockedList.clear()方法，若没有（0次或者大于一次），测试将不通过&#125; Stubbing1234567891011121314151617181920212223@Testpublic void testStubbing() throws Exception &#123; //你可以mock具体的类，而不仅仅是接口 LinkedList mockedList = mock(LinkedList.class); //设置桩 when(mockedList.get(0)).thenReturn("first"); when(mockedList.get(1)).thenThrow(new RuntimeException()); //打印 "first" System.out.println(mockedList.get(0)); //这里会抛runtime exception System.out.println(mockedList.get(1)); //这里会打印 "null" 因为 get(999) 没有设置 System.out.println(mockedList.get(999)); //Although it is possible to verify a stubbed invocation, usually it's just redundant //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed). //If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See here. verify(mockedList).get(0);&#125; 对于stubbing，有以下几点需要注意： 对于有返回值的方法，mock会默认返回null、空集合、默认值。比如，为int/Integer返回0，为boolean/Boolean返回false stubbing可以被覆盖，但是请注意覆盖已有的stubbing有可能不是很好 一旦stubbing，不管调用多少次，方法都会永远返回stubbing的值 当你对同一个方法进行多次stubbing，最后一次stubbing是最重要的 参数匹配1234567891011121314@Testpublic void testArgumentMatcher() throws Exception &#123; LinkedList mockedList = mock(LinkedList.class); //用内置的参数匹配器来stub when(mockedList.get(anyInt())).thenReturn("element"); //打印 "element" System.out.println(mockedList.get(999)); //你也可以用参数匹配器来验证，此处测试通过 verify(mockedList).get(anyInt()); //此处测试将不通过，因为没调用get(33) verify(mockedList).get(eq(33));&#125; 如果你使用了参数匹配器，那么所有参数都应该使用参数匹配器 12345verify(mock).someMethod(anyInt(), anyString(), eq("third argument"));//上面是正确的，因为eq返回参数匹配器verify(mock).someMethod(anyInt(), anyString(), "third argument");//上面将会抛异常，因为第三个参数不是参数匹配器，一旦使用了参数匹配器来验证，那么所有参数都应该使用参数匹配 验证准确的调用次数，最多、最少、从未等1234567891011121314151617181920212223242526272829303132@Testpublic void testInvocationTimes() throws Exception &#123; LinkedList mockedList = mock(LinkedList.class); //using mock mockedList.add("once"); mockedList.add("twice"); mockedList.add("twice"); mockedList.add("three times"); mockedList.add("three times"); mockedList.add("three times"); //下面两个是等价的， 默认使用times(1) verify(mockedList).add("once"); verify(mockedList, times(1)).add("once"); //验证准确的调用次数 verify(mockedList, times(2)).add("twice"); verify(mockedList, times(3)).add("three times"); //从未调用过. never()是times(0)的别名 verify(mockedList, never()).add("never happened"); //用atLeast()/atMost()验证 verify(mockedList, atLeastOnce()).add("three times"); //下面这句将不能通过测试 verify(mockedList, atLeast(2)).add("five times"); verify(mockedList, atMost(5)).add("three times");&#125; 为void方法抛异常12345678@Testpublic void testVoidMethodsWithExceptions() throws Exception &#123; LinkedList mockedList = mock(LinkedList.class); doThrow(new RuntimeException()).when(mockedList).clear(); //下面会抛RuntimeException mockedList.clear();&#125; 验证调用顺序12345678910111213141516171819202122232425262728293031@Testpublic void testVerificationInOrder() throws Exception &#123; // A. Single mock whose methods must be invoked in a particular order List singleMock = mock(List.class); //使用单个mock对象 singleMock.add("was added first"); singleMock.add("was added second"); //创建inOrder InOrder inOrder = inOrder(singleMock); //验证调用次数，若是调换两句，将会出错，因为singleMock.add("was added first")是先调用的 inOrder.verify(singleMock).add("was added first"); inOrder.verify(singleMock).add("was added second"); // 多个mock对象 List firstMock = mock(List.class); List secondMock = mock(List.class); //using mocks firstMock.add("was called first"); secondMock.add("was called second"); //创建多个mock对象的inOrder inOrder = inOrder(firstMock, secondMock); //验证firstMock先于secondMock调用 inOrder.verify(firstMock).add("was called first"); inOrder.verify(secondMock).add("was called second");&#125; 验证mock对象没有产生过交互123456789101112@Testpublic void testInteractionNeverHappened() &#123; List mockOne = mock(List.class); List mockTwo = mock(List.class); //测试通过 verifyZeroInteractions(mockOne, mockTwo); mockOne.add(""); //测试不通过，因为mockTwo已经发生过交互了 verifyZeroInteractions(mockOne, mockTwo);&#125; 查找是否有未验证的交互 不建议过多使用，api原文：A word of warning: Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. verifyNoMoreInteractions() is not recommended to use in every test method. verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it’s relevant. Abusing it leads to overspecified, less maintainable tests. 123456789101112@Testpublic void testFindingRedundantInvocations() throws Exception &#123; List mockedList = mock(List.class); //using mocks mockedList.add("one"); mockedList.add("two"); verify(mockedList).add("one"); //验证失败，因为mockedList.add("two")尚未验证 verifyNoMoreInteractions(mockedList);&#125; @Mock注解 减少代码 增强可读性 让verify出错信息更易读，因为变量名可用来描述标记mock对象 1234567891011121314151617public class MockTest &#123; @Mock List&lt;String&gt; mockedList; @Before public void initMocks() &#123; //必须,否则注解无效 MockitoAnnotations.initMocks(this); &#125; @Test public void testMock() throws Exception &#123; mockedList.add("one"); verify(mockedList).add("one"); &#125;&#125; 根据调用顺序设置不同的stubbing12345678910111213141516171819202122private interface MockTest &#123; String someMethod(String arg);&#125;@Testpublic void testStubbingConsecutiveCalls() throws Exception &#123; MockTest mock = mock(MockTest.class); when(mock.someMethod("some arg")).thenThrow(new RuntimeException("")).thenReturn("foo"); //第一次调用，抛RuntimeException mock.someMethod("some arg"); //第二次调用返回foo System.out.println(mock.someMethod("some arg")); //后续继续调用，返回“foo”，以最后一个stub为准 System.out.println(mock.someMethod("some arg")); //下面是一个更简洁的写法 when(mock.someMethod("some arg")).thenReturn("one", "two", "three");&#125; doReturn()|doThrow()| doAnswer()|doNothing()|doCallRealMethod()等用法1234567@Testpublic void testDoXXX() throws Exception &#123; List mockedList = mock(List.class); doThrow(new RuntimeException()).when(mockedList).clear(); //以下会抛异常 mockedList.clear();&#125; spy监视真正的对象 spy是创建一个拷贝，如果你保留原始的list，并用它来进行操作，那么spy并不能检测到其交互 spy一个真正的对象+试图stub一个final方法，这样是会有问题的 123456789101112131415161718192021222324252627@Testpublic void testSpy() throws Exception &#123; List list = new LinkedList(); List spy = spy(list); //可选的，你可以stub某些方法 when(spy.size()).thenReturn(100); //调用"真正"的方法 spy.add("one"); spy.add("two"); //打印one System.out.println(spy.get(0)); //size()方法被stub了，打印100 System.out.println(spy.size()); //可选，验证spy对象的行为 verify(spy).add("one"); verify(spy).add("two"); //下面写法有问题，spy.get(10)会抛IndexOutOfBoundsException异常 when(spy.get(10)).thenReturn("foo"); //可用以下方式 doReturn("foo").when(spy).get(10);&#125; 为未stub的方法设置默认返回值12345678910111213@Testpublic void testDefaultValue() throws Exception &#123; List listOne = mock(List.class, Mockito.RETURNS_SMART_NULLS); List listTwo = mock(List.class, new Answer() &#123; @Override public Object answer(InvocationOnMock invocation) throws Throwable &#123; // TODO: 2016/6/13 return default value here return null; &#125; &#125;);&#125; 参数捕捉12345678910@Testpublic void testCapturingArguments() throws Exception &#123; List mockedList = mock(List.class); ArgumentCaptor&lt;String&gt; argument = ArgumentCaptor.forClass(String.class); mockedList.add("John"); //验证后再捕捉参数 verify(mockedList).add(argument.capture()); //验证参数 assertEquals("John", argument.getValue());&#125; 真正的部分模拟（TODO：尚未搞清楚啥意思。。。）12345678//you can create partial mock with spy() method:List list = spy(new LinkedList());//you can enable partial mock capabilities selectively on mocks:Foo mock = mock(Foo.class);//Be sure the real implementation is 'safe'.//If real implementation throws exceptions or depends on specific state of the object then you're in trouble.when(mock.someMethod()).thenCallRealMethod(); 重置mocks Don’t harm yourself. reset() in the middle of the test method is a code smell (you’re probably testing too much). 12345678@Testpublic void testReset() throws Exception &#123; List mock = mock(List.class); when(mock.size()).thenReturn(10); mock.add(1); reset(mock); //从这开始，之前的交互和stub将全部失效&#125; Serializable mocks WARNING: This should be rarely used in unit testing. 1234@Testpublic void testSerializableMocks() throws Exception &#123; List serializableMock = mock(List.class, withSettings().serializable());&#125; 更多的注解：@Captor, @Spy, @InjectMocks @Captor 创建ArgumentCaptor @Spy 可以代替spy(Object). @InjectMocks 如果此注解声明的变量需要用到mock对象，mockito会自动注入mock或spy成员 1234567//可以这样写@Spy BeerDrinker drinker = new BeerDrinker();//也可以这样写，mockito会自动实例化drinker@Spy BeerDrinker drinker;//会自动实例化@InjectMocks LocalPub; 超时验证12345678910111213141516171819202122232425262728private interface TimeMockTest &#123; void someMethod();&#125;@Testpublic void testTimeout() throws Exception &#123; TimeMockTest mock = mock(TimeMockTest.class); //测试程序将会在下面这句阻塞100毫秒，timeout的时候再进行验证是否执行过someMethod() verify(mock, timeout(100)).someMethod(); //和上面代码等价 verify(mock, timeout(100).times(1)).someMethod(); //阻塞100ms，timeout的时候再验证是否刚好执行了2次 verify(mock, timeout(100).times(2)).someMethod(); //timeout的时候，验证至少执行了2次 verify(mock, timeout(100).atLeast(2)).someMethod(); //timeout时间后，用自定义的检验模式验证someMethod() VerificationMode yourOwnVerificationMode = new VerificationMode() &#123; @Override public void verify(VerificationData data) &#123; // TODO: 2016/12/4 implement me &#125; &#125;; verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();&#125; 查看是否mock或者spy12Mockito.mockingDetails(someObject).isMock();Mockito.mockingDetails(someObject).isSpy();]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>mock</tag>
        <tag>Mockito</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock Server利器 - Moco]]></title>
    <url>%2F2016%2F06%2F20%2Fmoco%2F</url>
    <content type="text"><![CDATA[Moco介绍在开发过程中，经常会使用到一些http网络接口，而这部分功能通常是由第三方开发团队或者是后端同事进行开发的，在我们开发时不能给我们提供服务，更有甚者，要集成的服务在开发时还不存在。这为我们的联调和测试造成了麻烦，常见的解决方案是搭建一个web server。 为什么要开发Moco这个框架？ 具体到模拟服务上，处理的手法也是各种各样，因为服务以HTTP集成居多，无论是Web Service，还是REST，所以，一种典型的做法是，开发一个模拟服务，打成WAR包，部署到一个应用服务器上。而我们知道，一旦牵扯到应用服务器部署，就是非常耗时的，部署的时间量级通常是分钟级的。而且，模拟服务器通常不是一次性的工作，我们需要在开发过程中，反复调整，这就进一步增加了维护一个模拟服务器的成本。有的应用服务器是非常消耗资源的，要用专门的机器来部署它。更进一步，如果机器资源有限，团队就只能共享一台机器，这样，即便我为测试自己的部分做一个小的改动，很有可能因为得不到机器的使用权，而要等上几天时间 Moco就是针对这样一个特定的场景而生的。Moco是一个简单搭建模拟服务器的程序库/工具，这个基于 Java 开发的开源项目已经在 Github 上获得了不少的关注。该项目的简介是这样描述自己的：Moco 是一个简单搭建 stub 的框架，主要用于测试和集成。 开发团队只要根据自己的需要进行相应的配置，就会很方便得到一个模拟服务器。而且，由于 Moco 本身的灵活性，其用途已经不再局限于最初的集成测试，比如，Moco 可以用于移动开发，模拟尚未开发的服务；Moco 还可以用于前端开发，模拟一个完整的 Web 服务器等等。 Moco本身支持API和独立运行两种方式。通过使用API，开发人员可以在JUnit、JBehave等测试测试框架里使用Moco，极大程度地降低了集成点测试的复杂度 Moco可以提供以下服务： HTTP APIs Socket APIs REST API Moco原理简介：Moco会根据一些配置，启动一个真正的HTTP服务（会监听本地的某个端口）。当发起请求满足一个条件时，它就给回复一个应答。Moco的底层没有依赖于像Servlet这样的重型框架，而是基于一个叫Netty网络应用框架直接编写的，这样一来，绕过了复杂的应用服务器，所以，它的速度是极快的 Moco已经在github上开源，可点击连接：https://github.com/dreamhead/moco Moco独立运行所需环境Moco独立运行时所需准备的有： Java运行环境 moco-runner-0.11.0-standalone.jar 如何运行Moco启动http服务Moco的运行非常简单，只需要一行命令即可如在命令行中运行：java -jar &lt;path-to-moco-runner&gt; http -p &lt;monitor-port&gt; -c &lt; configuration -file&gt; &lt;path-to-moco-runner&gt;：moco-runner-0.11.0-standalone.jar包的路径 &lt;monitor-port&gt;：http服务监听的端口 &lt;configuration -file&gt;：配置文件路径 这就在本地启动了一个http server，其中监听端口为12345，配置文件是MocoApi.json。只要在本机发起一个请求，如：http://localhost:12345，该请求就会被这个web server handle 如果别的机子想访问这个服务，只要把localhost替换成本机IP即可 启动https服务启动https服务，需要先生成证书，并用如下命令启动服务：地方多发呆发地方的地方的地方的发呆发：java -jar &lt;path-to-moco-runner&gt; https -p &lt;monitor-port&gt; -c &lt; configuration -file&gt; --https &lt;path-to-cert.jks &gt; --cert mocohttps --keystore mocohttps &lt;path-to-moco-runner&gt;：moco-runner-0.11.0-standalone.jar包的路径 &lt;monitor-port&gt;：http服务监听的端口 &lt;configuration -file&gt;：配置文件路径 &lt;path-to-cert.jks&gt;：证书路径 这就在本地启动了一个http server，其中监听端口是12346，配置文件是MocoApi.json，证书文件是test.cer Moco HTTP(s) API配置启动服务之后，必然会根据需求stub出各种各样接口反馈，我们会把这个配置放在一个json文件中，启动Moco的时候，需要指定使用的配置文件路径，这样配置就可以生效了。Moco服务可以检测到配置文件的变更，假如你修改了配置文件，不需要重新启动Moco，服务照样可以生效。更详细的配置介绍请查看：https://github.com/dreamhead/moco/blob/master/moco-doc/apis.md 配置文件的工作原理大致如下： 如何在配置文件添加注释json不支持注释，想要添加注释的话，可以在description字段中加入描述 约定请求Body 约定接口的uri 约定请求参数 约定请求方法 约定HTTP版本 约定请求头部 约定cookie 约定请求form 表单可以添加多项，多项的时候，必须全部匹配，接口才算匹配成功 约定以指定xml作为请求body 用xpath对请求进行匹配 约定以指定json作为请求body 用正则表达式对请求进行匹配 匹配操作 设置Response content 设置Response 状态码 设置Response HTTP版本 设置Response 头部 设置重定向 设置cookie 挂载文件 template的用法Moco内置了一些变量，在response中可以使用这些变量，让反馈更智能，以下列举了常用的变量 req.version req.version req.method req.content req.headers req.queries req.forms req.cookies 使用举例如下： Moco在单元测试中使用Moco除了可以单独运行外，还可以在单元测试中运行，测试过程中，Moco会启动一个web server来处理我们的请求 运行在单元测试中的moco server也可以选择加载json配置文件 通过stub后台，便可对http请求进行测试了 Moco的不足Moco的使用很简单，配置也很方便，目前更是提供了http、rest、socket服务。但是也仅仅是能stub出接口，模拟出简单的场景。如果接收到请求后需要做一些处理，如需查询数据库、进行运算、或者一些复杂的操作，就无能为力了。所以是否选用Moco，就取决于开发者是否只是需要一个简单的模拟服务器。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Moco</tag>
        <tag>mock</tag>
        <tag>server</tag>
      </tags>
  </entry>
</search>
